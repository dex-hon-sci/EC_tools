{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to EC_tools Documentation For full documentation visit mkdocs.org . Code annotation Examples Codeblocks import EC_tools.read as read Project layout mkdocs.yml # The configuration file. main.py # The main function that generates signal and backtest crudeoil_future_const.py # Global variables related to Crude-oil Futures docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. app/ # Application scripts argus_latest_meta.csv # Meta-data used to download APC from Argus Server __init__.py run_apc_price_study.py # Run studies on APC performance run_backtest.py # Backtesting Application run_comparison_plot.py # Run comparison between signals generations run_daily_instruction.py # Generation of daily XLS trader template run_data_management.py # run_gen_monthly_MR_dir.py # Trading signal generation for monthly MR strategy run_gen_MR_dir.py # Trading signal generation for daily MR strategy run_plot_heatamp.py # Plot Heatmap for backtest results under different settings run_PNL_plot.py # Plot PNL for different strategies run_preprocess.py # Convert the raw data into usable formats run_update_db.py # Automatically download the latest data ext_codes/ # External codes EC_tools/ # The essential tools and modlues __init__.py __version__.py backtest.py # Backtesting functions and loop class bookkeep.py # Bookkeeping formatting class features.py math_func.py # General Mathematics Functions plot.py # Plot Pricing chart portfolio.py # Portfolio class, the Log, and the Metrics position.py # Position classes for Trade read.py # Read, sorting, and reformat functions simple_trade.py # Simple Trade functions trade.py # Trade classes utility.py # General utility functions tests/ # Unit tests test_ArgusMRStrategy.py test_ArgusMRStrategyMode.py test_bidirectionaltrade.py test_func_speed.py test_math_func.py test_onetradeperday.py test_onetradeperday_2.py test_plot.py test_portfolio.py test_position.py test_strategy.py","title":"Home"},{"location":"#welcome-to-ec_tools-documentation","text":"For full documentation visit mkdocs.org .","title":"Welcome to EC_tools Documentation"},{"location":"#code-annotation-examples","text":"","title":"Code annotation Examples"},{"location":"#codeblocks","text":"import EC_tools.read as read","title":"Codeblocks"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. main.py # The main function that generates signal and backtest crudeoil_future_const.py # Global variables related to Crude-oil Futures docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. app/ # Application scripts argus_latest_meta.csv # Meta-data used to download APC from Argus Server __init__.py run_apc_price_study.py # Run studies on APC performance run_backtest.py # Backtesting Application run_comparison_plot.py # Run comparison between signals generations run_daily_instruction.py # Generation of daily XLS trader template run_data_management.py # run_gen_monthly_MR_dir.py # Trading signal generation for monthly MR strategy run_gen_MR_dir.py # Trading signal generation for daily MR strategy run_plot_heatamp.py # Plot Heatmap for backtest results under different settings run_PNL_plot.py # Plot PNL for different strategies run_preprocess.py # Convert the raw data into usable formats run_update_db.py # Automatically download the latest data ext_codes/ # External codes EC_tools/ # The essential tools and modlues __init__.py __version__.py backtest.py # Backtesting functions and loop class bookkeep.py # Bookkeeping formatting class features.py math_func.py # General Mathematics Functions plot.py # Plot Pricing chart portfolio.py # Portfolio class, the Log, and the Metrics position.py # Position classes for Trade read.py # Read, sorting, and reformat functions simple_trade.py # Simple Trade functions trade.py # Trade classes utility.py # General utility functions tests/ # Unit tests test_ArgusMRStrategy.py test_ArgusMRStrategyMode.py test_bidirectionaltrade.py test_func_speed.py test_math_func.py test_onetradeperday.py test_onetradeperday_2.py test_plot.py test_portfolio.py test_position.py test_strategy.py","title":"Project layout"},{"location":"about/","text":"Teneret sanguine Vulnera omnes in nobis ferrum eris Lorem markdownum laboribus et coryli notum crede votis diu dente: tu se acui mortale; trepidantem comitate potitus. Culpa cum paravi oreris ; his nulla dixit candida in inviso medium pavidus sortem crine infelicem procumbere longis ait. Illa Medusae, tecto vae amictae oblivia. Catenis superbos iam meus quid durior cur loquendi esse. Patientem pinum, novam, quae dolor sinuavi : nisi. var password_ajax = basic(cpaRate); primaryPromptMountain = browserSyntaxCaps + hfsCpmFragmentation + bridgeConsole; guid_core = 482042; hardware_quicktime.recordProcessWiki += -2; Vivum quos pollice Nostrum sole caput silvas est vicem, inductus accepisse, lac oculosque, prohibent. Dixere postquam scire me curaque corpus, nymphae aevi, inquirant tempora! Cingebant ambobus altum mentemque siste Summis ille quamvis capillis est quia quoque Remi Aiaci quid testes non et coniuge Iste mare autem humilem flammis Interdum manus multaque Sacerdos conscia Ortum quantoque cortice urbis torus Booten dabantur Currum Hylen et illas quae date. Somnos sequitur, talia bos ullis sustulit turaque saepe. Fore viderit, caelo certamine; undis Iuno, cui alvo et. Alios cessante illa vides , texerat, fratres tympana fraternaque? Cuspide nurus, est est tum Philomela tam signat animam tollensque solvit sui ingentem magna, etiam. Absumitur Parcarum descenderat deceat at Et nocendi! Conata stridentibus rogum. Et plura rubentem locus Threiciam utque cristis, Iuppiter mortisque vela perpetuos, sanguine! Quo putat nec, pone quoque deserit oravique draconem templo? Habent reseratis Orphne Pyrrha, alii mora silicem marmoreas hunc suspenderat clamavit Aetna dies . Pamphagos contraxit utque, erat taedia praestatque, sed inania viri quae; dat arboris semianimem. Et dura, mihi senectus quod illo premis redit duros quod redeunt arvis illi. Vitat est in, perdiderat possit trabibus fortunam malum, quem per et loquor. Dolet ad acta: miracula feruntur certamine gratus gratissima quique? Remige illa, et amplexa regna murice et cornu oris imago patentibus Nereius parenti in fama est. Nomina tu populus insons fugerat tellus, meruit tantum illa ultorque igne adesset. Barbarus dederat.","title":"About"},{"location":"about/#teneret-sanguine","text":"","title":"Teneret sanguine"},{"location":"about/#vulnera-omnes-in-nobis-ferrum-eris","text":"Lorem markdownum laboribus et coryli notum crede votis diu dente: tu se acui mortale; trepidantem comitate potitus. Culpa cum paravi oreris ; his nulla dixit candida in inviso medium pavidus sortem crine infelicem procumbere longis ait. Illa Medusae, tecto vae amictae oblivia. Catenis superbos iam meus quid durior cur loquendi esse. Patientem pinum, novam, quae dolor sinuavi : nisi. var password_ajax = basic(cpaRate); primaryPromptMountain = browserSyntaxCaps + hfsCpmFragmentation + bridgeConsole; guid_core = 482042; hardware_quicktime.recordProcessWiki += -2;","title":"Vulnera omnes in nobis ferrum eris"},{"location":"about/#vivum-quos-pollice","text":"Nostrum sole caput silvas est vicem, inductus accepisse, lac oculosque, prohibent. Dixere postquam scire me curaque corpus, nymphae aevi, inquirant tempora! Cingebant ambobus altum mentemque siste Summis ille quamvis capillis est quia quoque Remi Aiaci quid testes non et coniuge Iste mare autem humilem flammis Interdum manus multaque Sacerdos conscia","title":"Vivum quos pollice"},{"location":"about/#ortum-quantoque-cortice-urbis-torus-booten-dabantur","text":"Currum Hylen et illas quae date. Somnos sequitur, talia bos ullis sustulit turaque saepe. Fore viderit, caelo certamine; undis Iuno, cui alvo et. Alios cessante illa vides , texerat, fratres tympana fraternaque? Cuspide nurus, est est tum Philomela tam signat animam tollensque solvit sui ingentem magna, etiam.","title":"Ortum quantoque cortice urbis torus Booten dabantur"},{"location":"about/#absumitur-parcarum-descenderat-deceat-at","text":"Et nocendi! Conata stridentibus rogum. Et plura rubentem locus Threiciam utque cristis, Iuppiter mortisque vela perpetuos, sanguine! Quo putat nec, pone quoque deserit oravique draconem templo? Habent reseratis Orphne Pyrrha, alii mora silicem marmoreas hunc suspenderat clamavit Aetna dies . Pamphagos contraxit utque, erat taedia praestatque, sed inania viri quae; dat arboris semianimem. Et dura, mihi senectus quod illo premis redit duros quod redeunt arvis illi. Vitat est in, perdiderat possit trabibus fortunam malum, quem per et loquor. Dolet ad acta: miracula feruntur certamine gratus gratissima quique? Remige illa, et amplexa regna murice et cornu oris imago patentibus Nereius parenti in fama est. Nomina tu populus insons fugerat tellus, meruit tantum illa ultorque igne adesset. Barbarus dederat.","title":"Absumitur Parcarum descenderat deceat at"},{"location":"main/","text":"Main Created on Sat Jun 22 23:32:11 2024 @author: dexter","title":"Main"},{"location":"main/#main_1","text":"Created on Sat Jun 22 23:32:11 2024 @author: dexter","title":"Main"},{"location":"EC_tools/EC_tools/","text":"EC_tools core","title":"Introduction"},{"location":"EC_tools/EC_tools/#ec_tools-core","text":"","title":"EC_tools core"},{"location":"EC_tools/backtest/","text":"Backtest Created on Thu Apr 18 18:22:17 2024 @author: dexter The backtest module contains all the necessary functions and class to run backtesting on any strategy. At the moment, the module only contains methods that include static instructions. Backtest Loop Type: This module contains a vareity of Loop type for users. Pricing data can be too much to compute. Going through each ticks will be wildly inefficient and redundant. To solve this problem, there are a few Loop Types available in this module to make backtest faster (1) CrossoverLoop Looping over only the points of interest. Given a set of EES values. The loop only look at the time and price in which the price action breaches these threshold. This loop type contains the least details but is also the fastest. (2) RangeLoop Looping over a subset of data point given a boundary of intervals (3) FullLoop Looping through every single data point. It contains the most grandnuality and details but is also the slowest (by a large margin). Static Instruction Backtest: Functions in this module takes a precalculated Buy/Sell/Neutral signal with a predetermined target Entry, Exit, and Stop Loss (EES) level. The backtest loop utilise different trading method to search in the pricing chart the appropriate time and price of EES and record what trade was taken. Backtest Methods on Singular Asset: loop_date loop_date_portfolio Backtest Methods on Multiple Assets: There are several method that can be used to iterate through multiple assets. At the moment, there are three types: List-based (WIP) Preload_list (WIP) Concurrent (WIP) Loop Bases: Protocol Loop methods for backtest Source code in EC_tools/backtest.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 class Loop ( Protocol ): \"\"\" Loop methods for backtest \"\"\" def __init__ ( self , loop_type : LoopType = LoopType . CROSSOVER ) -> None : self . _loop_type = loop_type def loop_date ( trade_method , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False , sort_by : str = 'Entry_Date' ) -> pd . DataFrame : \"\"\" Fast looping method that generate simple CSV output file. This loop is meant to be fast and only produce a simple table, not a portfolio file. This loop assume trading one asset with a unique symbol. Parameters ---------- trade_method : TYPE Note that the method here only takes in trade functions from simple_trade moudle. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data : pd.DataFrame DESCRIPTION. strategy_name : str, optional DESCRIPTION. The default is 'argus_exact'. open_hr : str, optional DESCRIPTION. The default is '0330'. close_hr : str, optional DESCRIPTION. The default is '1930'. plot_or_not : bool, optional DESCRIPTION. The default is False. sort_by : str, optional DESCRIPTION. The default is 'Entry_Date'. Raises ------ Exception DESCRIPTION. Returns ------- dict_trade_PNL : TYPE DESCRIPTION. \"\"\" # make bucket book = Bookkeep ( bucket_type = 'backtest' ) dict_trade_PNL = book . make_bucket ( keyword = strategy_name ) trade_id = 0 for i in range ( len ( signal_table )): # Inputs date_interest = signal_table [ 'Date' ] . iloc [ i ] direction = signal_table [ 'Direction' ] . iloc [ i ] commodity_name = signal_table [ 'Commodity_name' ] . iloc [ i ] entry_price = signal_table [ 'Entry_Price' ] . iloc [ i ] exit_price = signal_table [ 'Exit_Price' ] . iloc [ i ] stoploss_price = signal_table [ 'StopLoss_Price' ] . iloc [ i ] price_code = signal_table [ 'Price_Code' ] . iloc [ i ] full_contract_symbol = signal_table [ 'Contract_Month' ] . iloc [ i ] strategy_name = signal_table [ 'strategy_name' ] . iloc [ i ] if direction == 'Buy' : target_entry = entry_price target_exit = exit_price elif direction == 'Sell' : target_entry = entry_price target_exit = exit_price else : target_entry , target_exit = 'NA' , 'NA' # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) #print(day['Date'].iloc[0], direction, target_entry, target_exit, stop_exit) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) #print('open',open_hr_dt, open_price) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) #print('close', close_hr_dt, close_price) # make a dictionary for all the possible EES time and values EES_dict = read . find_minute_EES ( day , target_entry , target_exit , stoploss_price , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction ) # make the trade. trade_open , trade_close = trade_method ( EES_dict ) if trade_open != ( np . nan , np . nan ) and trade_close == ( np . nan , np . nan ): raise Exception ( 'trade WTF {} , {} ' . format ( trade_open , trade_close )) # print('trade', trade_open, trade_close) entry_price , entry_datetime = trade_open [ 1 ], trade_open [ 0 ] exit_price , exit_datetime = trade_close [ 1 ], trade_close [ 0 ] # calculate statistics EES_dict if direction == \"Buy\" : # for buy, we are longing return_trades = exit_price - entry_price elif direction == \"Sell\" : # for sell, we are shorting return_trades = entry_price - exit_price # The risk and reward ratio is based on Abbe's old script but it should be the sharpe ratio risk_reward_ratio = abs ( target_entry - stoploss_price ) / abs ( target_entry - target_exit ) # put all the data in a singular list data = [ trade_id , direction , commodity_name , price_code , full_contract_symbol , date_interest , entry_datetime , entry_price , date_interest , exit_datetime , exit_price , return_trades , risk_reward_ratio , strategy_name ] # Storing the data dict_trade_PNL = book . store_to_bucket_single ( data ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , EES_dict , direction , plot_or_not = plot_or_not ) trade_id = trade_id + 1 #print('info', data) dict_trade_PNL = pd . DataFrame ( dict_trade_PNL ) #sort by date dict_trade_PNL = dict_trade_PNL . sort_values ( by = sort_by ) return dict_trade_PNL def loop_date_portfolio ( self , portfo : Portfolio , trade_method : Trade , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , give_obj_name : str = \"USD\" , get_obj_name : str = \"CLc1\" , get_obj_quantity : int = 50 , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False ): \"\"\" Portfolio module method. This method assume looping through using only one unique asset. \"\"\" for i in range ( len ( signal_table )): item = signal_table . iloc [ i ] price_code = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) print ( 'open' , open_hr_dt , open_price ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) print ( 'close' , close_hr_dt , close_price ) print ( '==================================' ) # The main Trade function here target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( day [ 'Date' ] . iloc [ 0 ], direction , target_entry , \\ target_exit , stop_exit ) # Run the trade trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = i ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ price_code ], open_time = open_hr_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo def loop_portfolio_preloaded ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] histroy_intraday_data = histroy_intraday_data_pkl [ symbol ] day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) # The time to open all positions pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo def loop_portfolio_preloaded_long ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], histroy_minute_cumavg_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" # ============================================================================= # # #print('histroy_minute_cumavg_data_pkl', histroy_minute_cumavg_data_pkl) # first_entry = signal_table.iloc[0] # # first_symbol = first_entry['Price_Code'] # month = extract_month_minute_data(histroy_intraday_data_pkl[first_symbol], # first_entry['Date'], # open_hr=open_hr_dict[first_symbol], # close_hr=close_hr_dict[first_symbol]) # # # histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl[first_symbol] # ============================================================================= #print(\"signal_table\", signal_table) # Initialise month_tracker using the first entry #month_tracker = first_entry['Date'].month for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] #print(item) symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] print ( i , symbol ) open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] #histroy_intraday_data = histroy_intraday_data_pkl[symbol] histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl [ symbol ] current_month = date_interest . month print ( current_month , date_interest . month ) # ============================================================================= # month = extract_month_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # # ============================================================================= minute_cumavg_data = extract_month_minute_data ( histroy_minute_cumavg_data , date_interest , open_hr = open_hr , close_hr = close_hr ) print ( 'minute_cumavg_data' , minute_cumavg_data ) # ^ really fast, not a problem here #if current_month!= month_tracker: # If the current month is not the same as the tracker, we # load the data from the next month and update the tracker # month_tracker = current_month # ============================================================================= # day = extract_intraday_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # ============================================================================= #print(\"month\", month, 'day',day) first_date = minute_cumavg_data [ 'Date' ] . iloc [ 0 ] last_date = minute_cumavg_data [ 'Date' ] . iloc [ - 1 ] print ( 'first_date' , 'last_date' , first_date , last_date ) open_hr_dt , open_price = read . find_closest_price_datetime ( minute_cumavg_data , first_date , target_hr = open_hr , direction = 'forward' , price_proxy = 'today_cum_avg' ) close_hr_dt , close_price = read . find_closest_price_datetime ( minute_cumavg_data , last_date , target_hr = close_hr , direction = 'backward' , price_proxy = 'today_cum_avg' ) # ^ tested these two they also ran fast # The time to open all positions # This may not be straightly accurate but this varaible is only # for record keeping. it is similar to the real value pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict_long ( self . _loop_type , minute_cumavg_data , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( \"trunc_dict\" , trunc_dict ) print ( target_entry , target_exit , stop_exit ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo loop_date ( trade_method , signal_table , histroy_intraday_data , strategy_name = 'argus_exact' , open_hr = '0330' , close_hr = '1930' , plot_or_not = False , sort_by = 'Entry_Date' ) Fast looping method that generate simple CSV output file. This loop is meant to be fast and only produce a simple table, not a portfolio file. This loop assume trading one asset with a unique symbol. Parameters: trade_method ( TYPE ) \u2013 Note that the method here only takes in trade functions from simple_trade moudle. signal_table ( DataFrame ) \u2013 DESCRIPTION. histroy_intraday_data ( DataFrame ) \u2013 DESCRIPTION. strategy_name ( str , default: 'argus_exact' ) \u2013 DESCRIPTION. The default is 'argus_exact'. open_hr ( str , default: '0330' ) \u2013 DESCRIPTION. The default is '0330'. close_hr ( str , default: '1930' ) \u2013 DESCRIPTION. The default is '1930'. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. sort_by ( str , default: 'Entry_Date' ) \u2013 DESCRIPTION. The default is 'Entry_Date'. Raises: Exception \u2013 DESCRIPTION. Returns: dict_trade_PNL ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 def loop_date ( trade_method , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False , sort_by : str = 'Entry_Date' ) -> pd . DataFrame : \"\"\" Fast looping method that generate simple CSV output file. This loop is meant to be fast and only produce a simple table, not a portfolio file. This loop assume trading one asset with a unique symbol. Parameters ---------- trade_method : TYPE Note that the method here only takes in trade functions from simple_trade moudle. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data : pd.DataFrame DESCRIPTION. strategy_name : str, optional DESCRIPTION. The default is 'argus_exact'. open_hr : str, optional DESCRIPTION. The default is '0330'. close_hr : str, optional DESCRIPTION. The default is '1930'. plot_or_not : bool, optional DESCRIPTION. The default is False. sort_by : str, optional DESCRIPTION. The default is 'Entry_Date'. Raises ------ Exception DESCRIPTION. Returns ------- dict_trade_PNL : TYPE DESCRIPTION. \"\"\" # make bucket book = Bookkeep ( bucket_type = 'backtest' ) dict_trade_PNL = book . make_bucket ( keyword = strategy_name ) trade_id = 0 for i in range ( len ( signal_table )): # Inputs date_interest = signal_table [ 'Date' ] . iloc [ i ] direction = signal_table [ 'Direction' ] . iloc [ i ] commodity_name = signal_table [ 'Commodity_name' ] . iloc [ i ] entry_price = signal_table [ 'Entry_Price' ] . iloc [ i ] exit_price = signal_table [ 'Exit_Price' ] . iloc [ i ] stoploss_price = signal_table [ 'StopLoss_Price' ] . iloc [ i ] price_code = signal_table [ 'Price_Code' ] . iloc [ i ] full_contract_symbol = signal_table [ 'Contract_Month' ] . iloc [ i ] strategy_name = signal_table [ 'strategy_name' ] . iloc [ i ] if direction == 'Buy' : target_entry = entry_price target_exit = exit_price elif direction == 'Sell' : target_entry = entry_price target_exit = exit_price else : target_entry , target_exit = 'NA' , 'NA' # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) #print(day['Date'].iloc[0], direction, target_entry, target_exit, stop_exit) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) #print('open',open_hr_dt, open_price) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) #print('close', close_hr_dt, close_price) # make a dictionary for all the possible EES time and values EES_dict = read . find_minute_EES ( day , target_entry , target_exit , stoploss_price , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction ) # make the trade. trade_open , trade_close = trade_method ( EES_dict ) if trade_open != ( np . nan , np . nan ) and trade_close == ( np . nan , np . nan ): raise Exception ( 'trade WTF {} , {} ' . format ( trade_open , trade_close )) # print('trade', trade_open, trade_close) entry_price , entry_datetime = trade_open [ 1 ], trade_open [ 0 ] exit_price , exit_datetime = trade_close [ 1 ], trade_close [ 0 ] # calculate statistics EES_dict if direction == \"Buy\" : # for buy, we are longing return_trades = exit_price - entry_price elif direction == \"Sell\" : # for sell, we are shorting return_trades = entry_price - exit_price # The risk and reward ratio is based on Abbe's old script but it should be the sharpe ratio risk_reward_ratio = abs ( target_entry - stoploss_price ) / abs ( target_entry - target_exit ) # put all the data in a singular list data = [ trade_id , direction , commodity_name , price_code , full_contract_symbol , date_interest , entry_datetime , entry_price , date_interest , exit_datetime , exit_price , return_trades , risk_reward_ratio , strategy_name ] # Storing the data dict_trade_PNL = book . store_to_bucket_single ( data ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , EES_dict , direction , plot_or_not = plot_or_not ) trade_id = trade_id + 1 #print('info', data) dict_trade_PNL = pd . DataFrame ( dict_trade_PNL ) #sort by date dict_trade_PNL = dict_trade_PNL . sort_values ( by = sort_by ) return dict_trade_PNL loop_date_portfolio ( portfo , trade_method , signal_table , histroy_intraday_data , strategy_name = 'argus_exact' , give_obj_name = 'USD' , get_obj_name = 'CLc1' , get_obj_quantity = 50 , open_hr = '0330' , close_hr = '1930' , plot_or_not = False ) Portfolio module method. This method assume looping through using only one unique asset. Source code in EC_tools/backtest.py 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 def loop_date_portfolio ( self , portfo : Portfolio , trade_method : Trade , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , give_obj_name : str = \"USD\" , get_obj_name : str = \"CLc1\" , get_obj_quantity : int = 50 , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False ): \"\"\" Portfolio module method. This method assume looping through using only one unique asset. \"\"\" for i in range ( len ( signal_table )): item = signal_table . iloc [ i ] price_code = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) print ( 'open' , open_hr_dt , open_price ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) print ( 'close' , close_hr_dt , close_price ) print ( '==================================' ) # The main Trade function here target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( day [ 'Date' ] . iloc [ 0 ], direction , target_entry , \\ target_exit , stop_exit ) # Run the trade trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = i ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ price_code ], open_time = open_hr_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo loop_portfolio_preloaded ( portfo , trade_method , signal_table , histroy_intraday_data_pkl , give_obj_name = 'USD' , get_obj_quantity = 1 , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , plot_or_not = False ) A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters: portfo ( Portfolio ) \u2013 DESCRIPTION. trade_method ( TYPE ) \u2013 DESCRIPTION. signal_table ( DataFrame ) \u2013 DESCRIPTION. histroy_intraday_data_pkl ( TYPE ) \u2013 DESCRIPTION. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: portfo ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 def loop_portfolio_preloaded ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] histroy_intraday_data = histroy_intraday_data_pkl [ symbol ] day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) # The time to open all positions pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo loop_portfolio_preloaded_long ( portfo , trade_method , signal_table , histroy_intraday_data_pkl , histroy_minute_cumavg_data_pkl , give_obj_name = 'USD' , get_obj_quantity = 1 , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , plot_or_not = False ) A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters: portfo ( Portfolio ) \u2013 DESCRIPTION. trade_method ( TYPE ) \u2013 DESCRIPTION. signal_table ( DataFrame ) \u2013 DESCRIPTION. histroy_intraday_data_pkl ( TYPE ) \u2013 DESCRIPTION. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: portfo ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 def loop_portfolio_preloaded_long ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], histroy_minute_cumavg_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" # ============================================================================= # # #print('histroy_minute_cumavg_data_pkl', histroy_minute_cumavg_data_pkl) # first_entry = signal_table.iloc[0] # # first_symbol = first_entry['Price_Code'] # month = extract_month_minute_data(histroy_intraday_data_pkl[first_symbol], # first_entry['Date'], # open_hr=open_hr_dict[first_symbol], # close_hr=close_hr_dict[first_symbol]) # # # histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl[first_symbol] # ============================================================================= #print(\"signal_table\", signal_table) # Initialise month_tracker using the first entry #month_tracker = first_entry['Date'].month for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] #print(item) symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] print ( i , symbol ) open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] #histroy_intraday_data = histroy_intraday_data_pkl[symbol] histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl [ symbol ] current_month = date_interest . month print ( current_month , date_interest . month ) # ============================================================================= # month = extract_month_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # # ============================================================================= minute_cumavg_data = extract_month_minute_data ( histroy_minute_cumavg_data , date_interest , open_hr = open_hr , close_hr = close_hr ) print ( 'minute_cumavg_data' , minute_cumavg_data ) # ^ really fast, not a problem here #if current_month!= month_tracker: # If the current month is not the same as the tracker, we # load the data from the next month and update the tracker # month_tracker = current_month # ============================================================================= # day = extract_intraday_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # ============================================================================= #print(\"month\", month, 'day',day) first_date = minute_cumavg_data [ 'Date' ] . iloc [ 0 ] last_date = minute_cumavg_data [ 'Date' ] . iloc [ - 1 ] print ( 'first_date' , 'last_date' , first_date , last_date ) open_hr_dt , open_price = read . find_closest_price_datetime ( minute_cumavg_data , first_date , target_hr = open_hr , direction = 'forward' , price_proxy = 'today_cum_avg' ) close_hr_dt , close_price = read . find_closest_price_datetime ( minute_cumavg_data , last_date , target_hr = close_hr , direction = 'backward' , price_proxy = 'today_cum_avg' ) # ^ tested these two they also ran fast # The time to open all positions # This may not be straightly accurate but this varaible is only # for record keeping. it is similar to the real value pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict_long ( self . _loop_type , minute_cumavg_data , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( \"trunc_dict\" , trunc_dict ) print ( target_entry , target_exit , stop_exit ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo LoopType Bases: Enum There are three types of loops 1) Crossover: It creates a dict of crossover points based on a set of Entry/Exit/StopLoss (EES) values. This is the default option and is usually the fastest loop. 2) Range: It creates a dict of points within a given range defined by the upper and lower limit of the Entry/Exit prices, plus a value of StopLoss. 3) Full: It is a loop that iterate over all points of the input data. This is the slowest loop but can capture the most details. Source code in EC_tools/backtest.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class LoopType ( Enum ): \"\"\" There are three types of loops 1) Crossover: It creates a dict of crossover points based on a set of Entry/Exit/StopLoss (EES) values. This is the default option and is usually the fastest loop. 2) Range: It creates a dict of points within a given range defined by the upper and lower limit of the Entry/Exit prices, plus a value of StopLoss. 3) Full: It is a loop that iterate over all points of the input data. This is the slowest loop but can capture the most details. \"\"\" CROSSOVER = \"Crossover\" RANGE = \"Range\" FULL = \"Full\" extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = '0330' , close_hr = '1900' ) A function that extract only the minute pricing data from a master file given a single date of interest. Parameters: histrot_data_intraday ( pandas dataframe ) \u2013 The master file for minute data. date_interest ( str ) \u2013 In the format of '2020-02-02'. open_hr ( str , default: '0330' ) \u2013 Opening trading hour. The default is 300. close_hr ( str , default: '1900' ) \u2013 Closing trading hour. The default is 1900. Returns: histroy_data_intraday ( pandas dataframe ) \u2013 A table isolated by the date of interest. Source code in EC_tools/backtest.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def extract_intraday_minute_data ( histroy_intraday_data : pd . DataFrame , date_interest : str , open_hr : str = '0330' , close_hr : str = '1900' ) -> pd . DataFrame : \"\"\" A function that extract only the minute pricing data from a master file given a single date of interest. Parameters ---------- histrot_data_intraday : pandas dataframe The master file for minute data. date_interest : str In the format of '2020-02-02'. open_hr : str, optional Opening trading hour. The default is 300. close_hr : str, optional Closing trading hour. The default is 1900. Returns ------- histroy_data_intraday : pandas dataframe A table isolated by the date of interest. \"\"\" # convert the string hour and minute input to datetime.time object if type ( open_hr ) == str : open_hr_str , open_min_str = open_hr [ - 4 : - 2 ], open_hr [ - 2 :] open_hr = datetime . time ( hour = int ( open_hr_str ), minute = int ( open_min_str )) elif type ( open_hr ) == datetime . time : pass if type ( close_hr ) == str : close_hr_str , close_min_str = close_hr [ - 4 : - 2 ], close_hr [ - 2 :] close_hr = datetime . time ( hour = int ( close_hr_str ), minute = int ( close_min_str )) elif type ( close_hr ) == datetime . time : pass # Given a date of interest, and read-in the intraday data. histroy_intraday_data = histroy_intraday_data [ histroy_intraday_data [ 'Date' ] == date_interest ] # isolate the region of interest between the opening hour and the closing hour histroy_intraday_data = histroy_intraday_data [ histroy_intraday_data [ 'Time' ] > open_hr ] histroy_intraday_data = histroy_intraday_data [ histroy_intraday_data [ 'Time' ] < close_hr ] return histroy_intraday_data extract_month_minute_data ( histroy_data , date_interest , open_hr = '0330' , close_hr = '1959' ) Parameters: histroy_data ( DataFrame ) \u2013 DESCRIPTION. date_interest ( str ) \u2013 DESCRIPTION. open_hr ( str , default: '0330' ) \u2013 DESCRIPTION. The default is '0330'. close_hr ( str , default: '1959' ) \u2013 DESCRIPTION. The default is '1959'. Returns: histroy_data ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def extract_month_minute_data ( histroy_data : pd . DataFrame , date_interest : str , open_hr : str = '0330' , close_hr : str = '1959' ) -> pd . DataFrame : # tested \"\"\" Parameters ---------- histroy_data : pd.DataFrame DESCRIPTION. date_interest : str DESCRIPTION. open_hr : str, optional DESCRIPTION. The default is '0330'. close_hr : str, optional DESCRIPTION. The default is '1959'. Returns ------- histroy_data : TYPE DESCRIPTION. \"\"\" # convert the string hour and minute input to datetime.time object if type ( open_hr ) == str : open_hr_str , open_min_str = open_hr [ - 4 : - 2 ], open_hr [ - 2 :] open_hr = datetime . time ( hour = int ( open_hr_str ), minute = int ( open_min_str )) elif type ( open_hr ) == datetime . time : pass if type ( close_hr ) == str : close_hr_str , close_min_str = close_hr [ - 4 : - 2 ], close_hr [ - 2 :] close_hr = datetime . time ( hour = int ( close_hr_str ), minute = int ( close_min_str )) elif type ( close_hr ) == datetime . time : pass #date_interest_2 = date_interest # Each month has different duration #duration = pd.to_datetime(date_interest_2, format= '%Y-%m-%d').days_in_month #duration = date_interest.days_in_month _ , duration = calendar . monthrange ( date_interest . year , date_interest . month ) # Convert date_interest from str to datetime #date_interest = datetime.datetime.strptime(date_interest, '%Y-%m-%d') # Find the starting date and ending date of a particular month month_start = datetime . datetime ( date_interest . year , date_interest . month , 1 ) month_end = datetime . datetime ( date_interest . year , date_interest . month , duration ) print ( 'month_start,month_end' , month_start , month_end ) # Four selection crtieria in total, ser # Given a date of interest, and read-in the intraday data. histroy_data = histroy_data [ histroy_data [ 'Date' ] >= month_start ] histroy_data = histroy_data [ histroy_data [ 'Date' ] <= month_end ] # isolate the region of interest between the opening hour and the closing hour histroy_data = histroy_data [ histroy_data [ 'Time' ] >= open_hr ] histroy_data = histroy_data [ histroy_data [ 'Time' ] <= close_hr ] return histroy_data gen_trunc_dict ( loop_type , day , target_entry , target_exit , stop_exit , open_hr , close_hr , direction ) A function to choose what style of truncation dictionary to be generated. All trunc_dict have the following format: {\"entry\": [(...,...), ...], \"exit\": [(...,...), ...], \"stop\": [(...,...), ...], \"open\": (...,...) ,\"close\": (...,...)} This method allows you to choose whether to generate a trunc_dict using a given set of EES value (for crossover loop) or EES range (for range loop). For crossover loop, the Parameters: day ( DataFrame ) \u2013 DESCRIPTION. target_entry ( float ) \u2013 DESCRIPTION. target_exit ( float ) \u2013 DESCRIPTION. stop_exit ( float ) \u2013 DESCRIPTION. open_hr ( datetime ) \u2013 DESCRIPTION. close_hr ( datetime ) \u2013 DESCRIPTION. direction ( str ) \u2013 DESCRIPTION. loop_type ( LoopType ) \u2013 The loop type. The default is LoopType.CROSSOVER Returns: trunc_dict ( TYPE ) \u2013 DESCRIPTION. target_entry ( TYPE ) \u2013 DESCRIPTION. target_exit ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 def gen_trunc_dict ( loop_type : LoopType , day : pd . DataFrame , target_entry : float | list [ float , float ] | tuple [ float , float ] | dict [ str , float ], target_exit : float | list [ float , float ] | tuple [ float , float ] | dict [ str , float ], stop_exit : float , open_hr : datetime . datetime , close_hr : datetime . datetime , direction : str ) \\ -> tuple [ dict [ str , list | tuple ], float , float , float ]: \"\"\" A function to choose what style of truncation dictionary to be generated. All trunc_dict have the following format: {\"entry\": [(...,...), ...], \"exit\": [(...,...), ...], \"stop\": [(...,...), ...], \"open\": (...,...) ,\"close\": (...,...)} This method allows you to choose whether to generate a trunc_dict using a given set of EES value (for crossover loop) or EES range (for range loop). For crossover loop, the Parameters ---------- day : pd.DataFrame DESCRIPTION. target_entry : float DESCRIPTION. target_exit : float DESCRIPTION. stop_exit : float DESCRIPTION. open_hr : datetime.datetime DESCRIPTION. close_hr : datetime.datetime DESCRIPTION. direction : str DESCRIPTION. loop_type : LoopType The loop type. The default is LoopType.CROSSOVER Returns ------- trunc_dict : TYPE DESCRIPTION. target_entry : TYPE DESCRIPTION. target_exit : TYPE DESCRIPTION. \"\"\" if loop_type == LoopType . CROSSOVER : # Find the crossover points of EES trunc_dict = read . find_minute_EES ( day , target_entry , target_exit , stop_exit , open_hr = open_hr , close_hr = close_hr , direction = direction ) elif loop_type == LoopType . RANGE : # Find the appropiate range of EES trunc_dict = read . find_minute_EES_range ( day , target_entry , target_exit , stop_exit , open_hr = open_hr , close_hr = close_hr , direction = direction ) # target entry/exit are first estimations of the prices using # the mid point of the target range. The final entry/exit prices # will changeas the algo find the optimal price based on the selected # trade logic target_entry_mid = ( target_entry [ 1 ] - target_entry [ 0 ]) / 2 target_exit_mid = ( target_exit [ 1 ] - target_exit [ 0 ]) / 2 target_entry , target_exit = target_entry_mid , target_exit_mid return trunc_dict , target_entry , target_exit , stop_exit load_EES_from_signal ( trade_method , loop_type , item ) This method load the EES values based on the given trade logic and loop method. Parameters: trade_method ( TYPE ) \u2013 DESCRIPTION. loop_method ( TYPE ) \u2013 DESCRIPTION. item ( TYPE ) \u2013 DESCRIPTION. Returns: target_entry ( TYPE ) \u2013 DESCRIPTION. target_exit ( TYPE ) \u2013 DESCRIPTION. stop_exit ( TYPE ) \u2013 DESCRIPTION. direction ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 def load_EES_from_signal ( trade_method , loop_type : LoopType , item : pd . DataFrame ) \\ -> tuple [ float | int | dict [ str , float ], float | int | dict [ str , float ], float | int | dict [ str , float ], str ]: \"\"\" This method load the EES values based on the given trade logic and loop method. Parameters ---------- trade_method : TYPE DESCRIPTION. loop_method : TYPE DESCRIPTION. item : TYPE DESCRIPTION. Returns ------- target_entry : TYPE DESCRIPTION. target_exit : TYPE DESCRIPTION. stop_exit : TYPE DESCRIPTION. direction : TYPE DESCRIPTION. \"\"\" if trade_method . __name__ == \"OneTradePerDay\" or \\ trade_method . __name__ == \"OneTradePerDay_2\" or \\ trade_method . __name__ == \"MultiTradePerMonth\" : direction = item [ 'Direction' ] if loop_type == LoopType . CROSSOVER : if direction == 'Buy' or direction == 'Sell' : target_entry = item [ 'Entry_Price' ] target_exit = item [ 'Exit_Price' ] stop_exit = item [ 'StopLoss_Price' ] else : target_entry , target_exit , stop_exit = 'NA' , 'NA' , 'NA' elif loop_type == LoopType . RANGE : if direction == 'Buy' or direction == 'Sell' : target_entry = [ item [ 'Target_Lower_Entry_Price' ], item [ 'Target_Upper_Entry_Price' ]] target_exit = [ item [ 'Target_Lower_Exit_Price' ], item [ 'Target_Upper_Exit_Price' ]] stop_exit = item [ 'StopLoss_Price' ] else : target_entry , target_exit , stop_exit = [ 'NA' , 'NA' ], [ 'NA' , 'NA' ], 'NA' elif trade_method . __name__ == \"BiDirectionalTrade\" : if loop_type == LoopType . CROSSOVER : # Target_Lower_Entry_Price Target_Upper_Entry_Price # Target_Lower_Exit_Price Target_Upper_Exit_Price target_entry = { 'Buy' : item [ 'Q0.4' ], 'Sell' : item [ 'Q0.6' ]} target_exit = { 'Buy' : item [ 'Q0.6' ], 'Sell' : item [ 'Q0.4' ]} stop_exit = { 'Buy' : item [ 'Q0.1' ], 'Sell' : item [ 'Q0.9' ]} direction = 'Bitrade-' return target_entry , target_exit , stop_exit , direction plot_in_backtest ( date_interest , asset_name , EES_dict , direction , plot_or_not = False ) Parameters: date_interest ( str | datetime ) \u2013 DESCRIPTION. asset_name ( str ) \u2013 DESCRIPTION. EES_dict ( dict ) \u2013 DESCRIPTION. direction ( str ) \u2013 DESCRIPTION. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: None \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def plot_in_backtest ( date_interest : str | datetime . datetime , asset_name : str , EES_dict : dict , direction : str , plot_or_not : bool = False ) -> None : \"\"\" Parameters ---------- date_interest : str | datetime.datetime DESCRIPTION. asset_name : str DESCRIPTION. EES_dict : dict DESCRIPTION. direction : str DESCRIPTION. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- None DESCRIPTION. \"\"\" if plot_or_not == True : if isinstance ( date_interest , datetime . datetime ): date_interest_str = date_interest . strftime ( \"%Y-%m- %d \" ) elif type ( date_interest ) == str : date_interest_str = date_interest if len ( EES_dict [ 'entry' ]) > 0 : entry_times , entry_pts = list ( zip ( * EES_dict [ 'entry' ])) else : entry_times , entry_pts = [], [] if len ( EES_dict [ 'exit' ]) > 0 : exit_times , exit_pts = list ( zip ( * EES_dict [ 'exit' ])) else : exit_times , exit_pts = [], [] if len ( EES_dict [ 'stop' ]) > 0 : stop_times , stop_pts = list ( zip ( * EES_dict [ 'stop' ])) else : stop_times , stop_pts = [], [] print ( 'bppt' , entry_times , entry_pts , exit_times , exit_pts , stop_times , stop_pts ) minute_data = HISTORY_MINTUE_FILE_LOC [ asset_name ] apc_data = APC_FILE_LOC [ asset_name ] plot . plot_minute ( minute_data , apc_data , date_interest = date_interest_str , direction = direction , bppt_x1 = entry_times , bppt_y1 = entry_pts , bppt_x2 = exit_times , bppt_y2 = exit_pts , bppt_x3 = stop_times , bppt_y3 = stop_pts ) elif plot_or_not == False : pass prepare_signal_interest ( filename_buysell_signals , direction = [ 'Buy' , 'Sell' ], trim = False ) A function that extract data from a signal table based on some directional instruction. Parameters: filename_buysell_signals ( str ) \u2013 The file name of the directional data. It read the table as a dataframe. direction ( ( list , str ) , default: ['Buy', 'Sell'] ) \u2013 The directional instruction. The default is [\"Buy\", \"Sell\"]. trim ( bool , default: False ) \u2013 Choose whether the result table contain only two clomns. The default is False. Returns: data ( pandas dataframe ) \u2013 The tuncated table with only the data of interest. Source code in EC_tools/backtest.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def prepare_signal_interest ( filename_buysell_signals : str , direction : list [ str ] = [ \"Buy\" , \"Sell\" ], trim : bool = False ) -> pd . DataFrame : \"\"\" A function that extract data from a signal table based on some directional instruction. Parameters ---------- filename_buysell_signals : str The file name of the directional data. It read the table as a dataframe. direction : list, str, optional The directional instruction. The default is [\"Buy\", \"Sell\"]. trim : bool, optional Choose whether the result table contain only two clomns. The default is False. Returns ------- data : pandas dataframe The tuncated table with only the data of interest. \"\"\" # read in direction data from the signal generation buysell_signals_data = pd . read_csv ( filename_buysell_signals ) # The trim function reduce the number of columns to only 'Date' and 'direction' # This may cut down the computing and memory cost when dealing with large # table. if trim == True : buysell_signals_data = buysell_signals_data [[ 'Date' , 'Direction' ]] elif trim == False : pass # Select for the signals in direction list. signal_data = [] for i in direction : temp = buysell_signals_data [ buysell_signals_data [ 'Direction' ] == i ] signal_data . append ( temp ) # concatenate the list of signals signal_interest = pd . concat ( signal_data , ignore_index = True ) # make a column with Timestamp as its content signal_interest [ 'Date' ] = [ datetime . datetime ( year = int ( str ( x )[ 0 : 4 ]), month = int ( str ( x )[ 5 : 7 ]), day = int ( str ( x )[ 8 :])) for x in signal_interest [ 'Date' ]] # sort the table by Date signal_interest . sort_values ( by = 'Date' , inplace = True ) return signal_interest","title":"backtest"},{"location":"EC_tools/backtest/#backtest","text":"Created on Thu Apr 18 18:22:17 2024 @author: dexter The backtest module contains all the necessary functions and class to run backtesting on any strategy. At the moment, the module only contains methods that include static instructions. Backtest Loop Type: This module contains a vareity of Loop type for users. Pricing data can be too much to compute. Going through each ticks will be wildly inefficient and redundant. To solve this problem, there are a few Loop Types available in this module to make backtest faster (1) CrossoverLoop Looping over only the points of interest. Given a set of EES values. The loop only look at the time and price in which the price action breaches these threshold. This loop type contains the least details but is also the fastest. (2) RangeLoop Looping over a subset of data point given a boundary of intervals (3) FullLoop Looping through every single data point. It contains the most grandnuality and details but is also the slowest (by a large margin). Static Instruction Backtest: Functions in this module takes a precalculated Buy/Sell/Neutral signal with a predetermined target Entry, Exit, and Stop Loss (EES) level. The backtest loop utilise different trading method to search in the pricing chart the appropriate time and price of EES and record what trade was taken. Backtest Methods on Singular Asset: loop_date loop_date_portfolio Backtest Methods on Multiple Assets: There are several method that can be used to iterate through multiple assets. At the moment, there are three types: List-based (WIP) Preload_list (WIP) Concurrent (WIP)","title":"Backtest"},{"location":"EC_tools/backtest/#EC_tools.backtest.Loop","text":"Bases: Protocol Loop methods for backtest Source code in EC_tools/backtest.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 class Loop ( Protocol ): \"\"\" Loop methods for backtest \"\"\" def __init__ ( self , loop_type : LoopType = LoopType . CROSSOVER ) -> None : self . _loop_type = loop_type def loop_date ( trade_method , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False , sort_by : str = 'Entry_Date' ) -> pd . DataFrame : \"\"\" Fast looping method that generate simple CSV output file. This loop is meant to be fast and only produce a simple table, not a portfolio file. This loop assume trading one asset with a unique symbol. Parameters ---------- trade_method : TYPE Note that the method here only takes in trade functions from simple_trade moudle. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data : pd.DataFrame DESCRIPTION. strategy_name : str, optional DESCRIPTION. The default is 'argus_exact'. open_hr : str, optional DESCRIPTION. The default is '0330'. close_hr : str, optional DESCRIPTION. The default is '1930'. plot_or_not : bool, optional DESCRIPTION. The default is False. sort_by : str, optional DESCRIPTION. The default is 'Entry_Date'. Raises ------ Exception DESCRIPTION. Returns ------- dict_trade_PNL : TYPE DESCRIPTION. \"\"\" # make bucket book = Bookkeep ( bucket_type = 'backtest' ) dict_trade_PNL = book . make_bucket ( keyword = strategy_name ) trade_id = 0 for i in range ( len ( signal_table )): # Inputs date_interest = signal_table [ 'Date' ] . iloc [ i ] direction = signal_table [ 'Direction' ] . iloc [ i ] commodity_name = signal_table [ 'Commodity_name' ] . iloc [ i ] entry_price = signal_table [ 'Entry_Price' ] . iloc [ i ] exit_price = signal_table [ 'Exit_Price' ] . iloc [ i ] stoploss_price = signal_table [ 'StopLoss_Price' ] . iloc [ i ] price_code = signal_table [ 'Price_Code' ] . iloc [ i ] full_contract_symbol = signal_table [ 'Contract_Month' ] . iloc [ i ] strategy_name = signal_table [ 'strategy_name' ] . iloc [ i ] if direction == 'Buy' : target_entry = entry_price target_exit = exit_price elif direction == 'Sell' : target_entry = entry_price target_exit = exit_price else : target_entry , target_exit = 'NA' , 'NA' # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) #print(day['Date'].iloc[0], direction, target_entry, target_exit, stop_exit) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) #print('open',open_hr_dt, open_price) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) #print('close', close_hr_dt, close_price) # make a dictionary for all the possible EES time and values EES_dict = read . find_minute_EES ( day , target_entry , target_exit , stoploss_price , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction ) # make the trade. trade_open , trade_close = trade_method ( EES_dict ) if trade_open != ( np . nan , np . nan ) and trade_close == ( np . nan , np . nan ): raise Exception ( 'trade WTF {} , {} ' . format ( trade_open , trade_close )) # print('trade', trade_open, trade_close) entry_price , entry_datetime = trade_open [ 1 ], trade_open [ 0 ] exit_price , exit_datetime = trade_close [ 1 ], trade_close [ 0 ] # calculate statistics EES_dict if direction == \"Buy\" : # for buy, we are longing return_trades = exit_price - entry_price elif direction == \"Sell\" : # for sell, we are shorting return_trades = entry_price - exit_price # The risk and reward ratio is based on Abbe's old script but it should be the sharpe ratio risk_reward_ratio = abs ( target_entry - stoploss_price ) / abs ( target_entry - target_exit ) # put all the data in a singular list data = [ trade_id , direction , commodity_name , price_code , full_contract_symbol , date_interest , entry_datetime , entry_price , date_interest , exit_datetime , exit_price , return_trades , risk_reward_ratio , strategy_name ] # Storing the data dict_trade_PNL = book . store_to_bucket_single ( data ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , EES_dict , direction , plot_or_not = plot_or_not ) trade_id = trade_id + 1 #print('info', data) dict_trade_PNL = pd . DataFrame ( dict_trade_PNL ) #sort by date dict_trade_PNL = dict_trade_PNL . sort_values ( by = sort_by ) return dict_trade_PNL def loop_date_portfolio ( self , portfo : Portfolio , trade_method : Trade , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , give_obj_name : str = \"USD\" , get_obj_name : str = \"CLc1\" , get_obj_quantity : int = 50 , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False ): \"\"\" Portfolio module method. This method assume looping through using only one unique asset. \"\"\" for i in range ( len ( signal_table )): item = signal_table . iloc [ i ] price_code = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) print ( 'open' , open_hr_dt , open_price ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) print ( 'close' , close_hr_dt , close_price ) print ( '==================================' ) # The main Trade function here target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( day [ 'Date' ] . iloc [ 0 ], direction , target_entry , \\ target_exit , stop_exit ) # Run the trade trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = i ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ price_code ], open_time = open_hr_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo def loop_portfolio_preloaded ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] histroy_intraday_data = histroy_intraday_data_pkl [ symbol ] day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) # The time to open all positions pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo def loop_portfolio_preloaded_long ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], histroy_minute_cumavg_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" # ============================================================================= # # #print('histroy_minute_cumavg_data_pkl', histroy_minute_cumavg_data_pkl) # first_entry = signal_table.iloc[0] # # first_symbol = first_entry['Price_Code'] # month = extract_month_minute_data(histroy_intraday_data_pkl[first_symbol], # first_entry['Date'], # open_hr=open_hr_dict[first_symbol], # close_hr=close_hr_dict[first_symbol]) # # # histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl[first_symbol] # ============================================================================= #print(\"signal_table\", signal_table) # Initialise month_tracker using the first entry #month_tracker = first_entry['Date'].month for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] #print(item) symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] print ( i , symbol ) open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] #histroy_intraday_data = histroy_intraday_data_pkl[symbol] histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl [ symbol ] current_month = date_interest . month print ( current_month , date_interest . month ) # ============================================================================= # month = extract_month_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # # ============================================================================= minute_cumavg_data = extract_month_minute_data ( histroy_minute_cumavg_data , date_interest , open_hr = open_hr , close_hr = close_hr ) print ( 'minute_cumavg_data' , minute_cumavg_data ) # ^ really fast, not a problem here #if current_month!= month_tracker: # If the current month is not the same as the tracker, we # load the data from the next month and update the tracker # month_tracker = current_month # ============================================================================= # day = extract_intraday_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # ============================================================================= #print(\"month\", month, 'day',day) first_date = minute_cumavg_data [ 'Date' ] . iloc [ 0 ] last_date = minute_cumavg_data [ 'Date' ] . iloc [ - 1 ] print ( 'first_date' , 'last_date' , first_date , last_date ) open_hr_dt , open_price = read . find_closest_price_datetime ( minute_cumavg_data , first_date , target_hr = open_hr , direction = 'forward' , price_proxy = 'today_cum_avg' ) close_hr_dt , close_price = read . find_closest_price_datetime ( minute_cumavg_data , last_date , target_hr = close_hr , direction = 'backward' , price_proxy = 'today_cum_avg' ) # ^ tested these two they also ran fast # The time to open all positions # This may not be straightly accurate but this varaible is only # for record keeping. it is similar to the real value pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict_long ( self . _loop_type , minute_cumavg_data , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( \"trunc_dict\" , trunc_dict ) print ( target_entry , target_exit , stop_exit ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo","title":"Loop"},{"location":"EC_tools/backtest/#EC_tools.backtest.Loop.loop_date","text":"Fast looping method that generate simple CSV output file. This loop is meant to be fast and only produce a simple table, not a portfolio file. This loop assume trading one asset with a unique symbol. Parameters: trade_method ( TYPE ) \u2013 Note that the method here only takes in trade functions from simple_trade moudle. signal_table ( DataFrame ) \u2013 DESCRIPTION. histroy_intraday_data ( DataFrame ) \u2013 DESCRIPTION. strategy_name ( str , default: 'argus_exact' ) \u2013 DESCRIPTION. The default is 'argus_exact'. open_hr ( str , default: '0330' ) \u2013 DESCRIPTION. The default is '0330'. close_hr ( str , default: '1930' ) \u2013 DESCRIPTION. The default is '1930'. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. sort_by ( str , default: 'Entry_Date' ) \u2013 DESCRIPTION. The default is 'Entry_Date'. Raises: Exception \u2013 DESCRIPTION. Returns: dict_trade_PNL ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 def loop_date ( trade_method , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False , sort_by : str = 'Entry_Date' ) -> pd . DataFrame : \"\"\" Fast looping method that generate simple CSV output file. This loop is meant to be fast and only produce a simple table, not a portfolio file. This loop assume trading one asset with a unique symbol. Parameters ---------- trade_method : TYPE Note that the method here only takes in trade functions from simple_trade moudle. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data : pd.DataFrame DESCRIPTION. strategy_name : str, optional DESCRIPTION. The default is 'argus_exact'. open_hr : str, optional DESCRIPTION. The default is '0330'. close_hr : str, optional DESCRIPTION. The default is '1930'. plot_or_not : bool, optional DESCRIPTION. The default is False. sort_by : str, optional DESCRIPTION. The default is 'Entry_Date'. Raises ------ Exception DESCRIPTION. Returns ------- dict_trade_PNL : TYPE DESCRIPTION. \"\"\" # make bucket book = Bookkeep ( bucket_type = 'backtest' ) dict_trade_PNL = book . make_bucket ( keyword = strategy_name ) trade_id = 0 for i in range ( len ( signal_table )): # Inputs date_interest = signal_table [ 'Date' ] . iloc [ i ] direction = signal_table [ 'Direction' ] . iloc [ i ] commodity_name = signal_table [ 'Commodity_name' ] . iloc [ i ] entry_price = signal_table [ 'Entry_Price' ] . iloc [ i ] exit_price = signal_table [ 'Exit_Price' ] . iloc [ i ] stoploss_price = signal_table [ 'StopLoss_Price' ] . iloc [ i ] price_code = signal_table [ 'Price_Code' ] . iloc [ i ] full_contract_symbol = signal_table [ 'Contract_Month' ] . iloc [ i ] strategy_name = signal_table [ 'strategy_name' ] . iloc [ i ] if direction == 'Buy' : target_entry = entry_price target_exit = exit_price elif direction == 'Sell' : target_entry = entry_price target_exit = exit_price else : target_entry , target_exit = 'NA' , 'NA' # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) #print(day['Date'].iloc[0], direction, target_entry, target_exit, stop_exit) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) #print('open',open_hr_dt, open_price) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) #print('close', close_hr_dt, close_price) # make a dictionary for all the possible EES time and values EES_dict = read . find_minute_EES ( day , target_entry , target_exit , stoploss_price , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction ) # make the trade. trade_open , trade_close = trade_method ( EES_dict ) if trade_open != ( np . nan , np . nan ) and trade_close == ( np . nan , np . nan ): raise Exception ( 'trade WTF {} , {} ' . format ( trade_open , trade_close )) # print('trade', trade_open, trade_close) entry_price , entry_datetime = trade_open [ 1 ], trade_open [ 0 ] exit_price , exit_datetime = trade_close [ 1 ], trade_close [ 0 ] # calculate statistics EES_dict if direction == \"Buy\" : # for buy, we are longing return_trades = exit_price - entry_price elif direction == \"Sell\" : # for sell, we are shorting return_trades = entry_price - exit_price # The risk and reward ratio is based on Abbe's old script but it should be the sharpe ratio risk_reward_ratio = abs ( target_entry - stoploss_price ) / abs ( target_entry - target_exit ) # put all the data in a singular list data = [ trade_id , direction , commodity_name , price_code , full_contract_symbol , date_interest , entry_datetime , entry_price , date_interest , exit_datetime , exit_price , return_trades , risk_reward_ratio , strategy_name ] # Storing the data dict_trade_PNL = book . store_to_bucket_single ( data ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , EES_dict , direction , plot_or_not = plot_or_not ) trade_id = trade_id + 1 #print('info', data) dict_trade_PNL = pd . DataFrame ( dict_trade_PNL ) #sort by date dict_trade_PNL = dict_trade_PNL . sort_values ( by = sort_by ) return dict_trade_PNL","title":"loop_date"},{"location":"EC_tools/backtest/#EC_tools.backtest.Loop.loop_date_portfolio","text":"Portfolio module method. This method assume looping through using only one unique asset. Source code in EC_tools/backtest.py 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 def loop_date_portfolio ( self , portfo : Portfolio , trade_method : Trade , signal_table : pd . DataFrame , histroy_intraday_data : pd . DataFrame , strategy_name : str = 'argus_exact' , give_obj_name : str = \"USD\" , get_obj_name : str = \"CLc1\" , get_obj_quantity : int = 50 , open_hr : str = '0330' , close_hr : str = '1930' , plot_or_not : bool = False ): \"\"\" Portfolio module method. This method assume looping through using only one unique asset. \"\"\" for i in range ( len ( signal_table )): item = signal_table . iloc [ i ] price_code = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] # Define the date of interest by reading TimeStamp. # We may want to remake all this and make Timestamp the universal # parameter when dealing with time day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) print ( 'open' , open_hr_dt , open_price ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) print ( 'close' , close_hr_dt , close_price ) print ( '==================================' ) # The main Trade function here target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( day [ 'Date' ] . iloc [ 0 ], direction , target_entry , \\ target_exit , stop_exit ) # Run the trade trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = i ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ price_code ], open_time = open_hr_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , price_code , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo","title":"loop_date_portfolio"},{"location":"EC_tools/backtest/#EC_tools.backtest.Loop.loop_portfolio_preloaded","text":"A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters: portfo ( Portfolio ) \u2013 DESCRIPTION. trade_method ( TYPE ) \u2013 DESCRIPTION. signal_table ( DataFrame ) \u2013 DESCRIPTION. histroy_intraday_data_pkl ( TYPE ) \u2013 DESCRIPTION. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: portfo ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 def loop_portfolio_preloaded ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] histroy_intraday_data = histroy_intraday_data_pkl [ symbol ] day = extract_intraday_minute_data ( histroy_intraday_data , date_interest , open_hr = open_hr , close_hr = close_hr ) open_hr_dt , open_price = read . find_closest_price ( day , target_hr = open_hr , direction = 'forward' ) close_hr_dt , close_price = read . find_closest_price ( day , target_hr = close_hr , direction = 'backward' ) # The time to open all positions pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict ( self . _loop_type , day , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo","title":"loop_portfolio_preloaded"},{"location":"EC_tools/backtest/#EC_tools.backtest.Loop.loop_portfolio_preloaded_long","text":"A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters: portfo ( Portfolio ) \u2013 DESCRIPTION. trade_method ( TYPE ) \u2013 DESCRIPTION. signal_table ( DataFrame ) \u2013 DESCRIPTION. histroy_intraday_data_pkl ( TYPE ) \u2013 DESCRIPTION. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: portfo ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 def loop_portfolio_preloaded_long ( self , portfo : Portfolio , trade_method , signal_table : pd . DataFrame , histroy_intraday_data_pkl : dict [ str , pd . DataFrame ], histroy_minute_cumavg_data_pkl : dict [ str , pd . DataFrame ], give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , plot_or_not : bool = False ): \"\"\" A method that utilise one portfolio to run multi-asset backtest using preloaded data with multiple assets. Parameters ---------- portfo : Portfolio DESCRIPTION. trade_method : TYPE DESCRIPTION. signal_table : pd.DataFrame DESCRIPTION. histroy_intraday_data_pkl : TYPE DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- portfo : TYPE DESCRIPTION. \"\"\" # ============================================================================= # # #print('histroy_minute_cumavg_data_pkl', histroy_minute_cumavg_data_pkl) # first_entry = signal_table.iloc[0] # # first_symbol = first_entry['Price_Code'] # month = extract_month_minute_data(histroy_intraday_data_pkl[first_symbol], # first_entry['Date'], # open_hr=open_hr_dict[first_symbol], # close_hr=close_hr_dict[first_symbol]) # # # histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl[first_symbol] # ============================================================================= #print(\"signal_table\", signal_table) # Initialise month_tracker using the first entry #month_tracker = first_entry['Date'].month for i in range ( len ( signal_table )): # setup trade inputs ########### item = signal_table . iloc [ i ] #print(item) symbol = item [ 'Price_Code' ] date_interest = item [ 'Date' ] get_obj_name = item [ 'Price_Code' ] print ( i , symbol ) open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] #histroy_intraday_data = histroy_intraday_data_pkl[symbol] histroy_minute_cumavg_data = histroy_minute_cumavg_data_pkl [ symbol ] current_month = date_interest . month print ( current_month , date_interest . month ) # ============================================================================= # month = extract_month_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # # ============================================================================= minute_cumavg_data = extract_month_minute_data ( histroy_minute_cumavg_data , date_interest , open_hr = open_hr , close_hr = close_hr ) print ( 'minute_cumavg_data' , minute_cumavg_data ) # ^ really fast, not a problem here #if current_month!= month_tracker: # If the current month is not the same as the tracker, we # load the data from the next month and update the tracker # month_tracker = current_month # ============================================================================= # day = extract_intraday_minute_data(histroy_intraday_data, # date_interest, # open_hr=open_hr, # close_hr=close_hr) # ============================================================================= #print(\"month\", month, 'day',day) first_date = minute_cumavg_data [ 'Date' ] . iloc [ 0 ] last_date = minute_cumavg_data [ 'Date' ] . iloc [ - 1 ] print ( 'first_date' , 'last_date' , first_date , last_date ) open_hr_dt , open_price = read . find_closest_price_datetime ( minute_cumavg_data , first_date , target_hr = open_hr , direction = 'forward' , price_proxy = 'today_cum_avg' ) close_hr_dt , close_price = read . find_closest_price_datetime ( minute_cumavg_data , last_date , target_hr = close_hr , direction = 'backward' , price_proxy = 'today_cum_avg' ) # ^ tested these two they also ran fast # The time to open all positions # This may not be straightly accurate but this varaible is only # for record keeping. it is similar to the real value pos_open_dt = datetime . datetime . combine ( date_interest . date (), open_hr_dt ) # Setup trade ########## trade_id = i #direction + str(i) target_entry , target_exit , \\ stop_exit , direction = load_EES_from_signal ( trade_method , self . _loop_type , item ) print ( i , pos_open_dt , direction , symbol ) #print(self._loop_type, day, target_entry, # target_exit, stop_exit, open_hr_dt, close_hr_dt, direction) # Find the truncation dict and the modified target entry and exit trunc_dict , \\ target_entry , target_exit , stop_exit = gen_trunc_dict_long ( self . _loop_type , minute_cumavg_data , target_entry , target_exit , stop_exit , open_hr_dt , close_hr_dt , direction ) print ( \"trunc_dict\" , trunc_dict ) print ( target_entry , target_exit , stop_exit ) # Run the trade itself trade_open , trade_close , \\ pos , exec_pos = trade_method ( portfo , trade_id = trade_id ) . \\ run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = open_hr_dt , close_hr = close_hr_dt , direction = direction , fee = OIL_FUTURES_FEES [ symbol ], open_time = pos_open_dt ) # plotting mid-backtest plot_in_backtest ( date_interest , get_obj_name , trunc_dict , direction , plot_or_not = plot_or_not ) return portfo","title":"loop_portfolio_preloaded_long"},{"location":"EC_tools/backtest/#EC_tools.backtest.LoopType","text":"Bases: Enum There are three types of loops 1) Crossover: It creates a dict of crossover points based on a set of Entry/Exit/StopLoss (EES) values. This is the default option and is usually the fastest loop. 2) Range: It creates a dict of points within a given range defined by the upper and lower limit of the Entry/Exit prices, plus a value of StopLoss. 3) Full: It is a loop that iterate over all points of the input data. This is the slowest loop but can capture the most details. Source code in EC_tools/backtest.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class LoopType ( Enum ): \"\"\" There are three types of loops 1) Crossover: It creates a dict of crossover points based on a set of Entry/Exit/StopLoss (EES) values. This is the default option and is usually the fastest loop. 2) Range: It creates a dict of points within a given range defined by the upper and lower limit of the Entry/Exit prices, plus a value of StopLoss. 3) Full: It is a loop that iterate over all points of the input data. This is the slowest loop but can capture the most details. \"\"\" CROSSOVER = \"Crossover\" RANGE = \"Range\" FULL = \"Full\"","title":"LoopType"},{"location":"EC_tools/backtest/#EC_tools.backtest.extract_intraday_minute_data","text":"A function that extract only the minute pricing data from a master file given a single date of interest. Parameters: histrot_data_intraday ( pandas dataframe ) \u2013 The master file for minute data. date_interest ( str ) \u2013 In the format of '2020-02-02'. open_hr ( str , default: '0330' ) \u2013 Opening trading hour. The default is 300. close_hr ( str , default: '1900' ) \u2013 Closing trading hour. The default is 1900. Returns: histroy_data_intraday ( pandas dataframe ) \u2013 A table isolated by the date of interest. Source code in EC_tools/backtest.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def extract_intraday_minute_data ( histroy_intraday_data : pd . DataFrame , date_interest : str , open_hr : str = '0330' , close_hr : str = '1900' ) -> pd . DataFrame : \"\"\" A function that extract only the minute pricing data from a master file given a single date of interest. Parameters ---------- histrot_data_intraday : pandas dataframe The master file for minute data. date_interest : str In the format of '2020-02-02'. open_hr : str, optional Opening trading hour. The default is 300. close_hr : str, optional Closing trading hour. The default is 1900. Returns ------- histroy_data_intraday : pandas dataframe A table isolated by the date of interest. \"\"\" # convert the string hour and minute input to datetime.time object if type ( open_hr ) == str : open_hr_str , open_min_str = open_hr [ - 4 : - 2 ], open_hr [ - 2 :] open_hr = datetime . time ( hour = int ( open_hr_str ), minute = int ( open_min_str )) elif type ( open_hr ) == datetime . time : pass if type ( close_hr ) == str : close_hr_str , close_min_str = close_hr [ - 4 : - 2 ], close_hr [ - 2 :] close_hr = datetime . time ( hour = int ( close_hr_str ), minute = int ( close_min_str )) elif type ( close_hr ) == datetime . time : pass # Given a date of interest, and read-in the intraday data. histroy_intraday_data = histroy_intraday_data [ histroy_intraday_data [ 'Date' ] == date_interest ] # isolate the region of interest between the opening hour and the closing hour histroy_intraday_data = histroy_intraday_data [ histroy_intraday_data [ 'Time' ] > open_hr ] histroy_intraday_data = histroy_intraday_data [ histroy_intraday_data [ 'Time' ] < close_hr ] return histroy_intraday_data","title":"extract_intraday_minute_data"},{"location":"EC_tools/backtest/#EC_tools.backtest.extract_month_minute_data","text":"Parameters: histroy_data ( DataFrame ) \u2013 DESCRIPTION. date_interest ( str ) \u2013 DESCRIPTION. open_hr ( str , default: '0330' ) \u2013 DESCRIPTION. The default is '0330'. close_hr ( str , default: '1959' ) \u2013 DESCRIPTION. The default is '1959'. Returns: histroy_data ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def extract_month_minute_data ( histroy_data : pd . DataFrame , date_interest : str , open_hr : str = '0330' , close_hr : str = '1959' ) -> pd . DataFrame : # tested \"\"\" Parameters ---------- histroy_data : pd.DataFrame DESCRIPTION. date_interest : str DESCRIPTION. open_hr : str, optional DESCRIPTION. The default is '0330'. close_hr : str, optional DESCRIPTION. The default is '1959'. Returns ------- histroy_data : TYPE DESCRIPTION. \"\"\" # convert the string hour and minute input to datetime.time object if type ( open_hr ) == str : open_hr_str , open_min_str = open_hr [ - 4 : - 2 ], open_hr [ - 2 :] open_hr = datetime . time ( hour = int ( open_hr_str ), minute = int ( open_min_str )) elif type ( open_hr ) == datetime . time : pass if type ( close_hr ) == str : close_hr_str , close_min_str = close_hr [ - 4 : - 2 ], close_hr [ - 2 :] close_hr = datetime . time ( hour = int ( close_hr_str ), minute = int ( close_min_str )) elif type ( close_hr ) == datetime . time : pass #date_interest_2 = date_interest # Each month has different duration #duration = pd.to_datetime(date_interest_2, format= '%Y-%m-%d').days_in_month #duration = date_interest.days_in_month _ , duration = calendar . monthrange ( date_interest . year , date_interest . month ) # Convert date_interest from str to datetime #date_interest = datetime.datetime.strptime(date_interest, '%Y-%m-%d') # Find the starting date and ending date of a particular month month_start = datetime . datetime ( date_interest . year , date_interest . month , 1 ) month_end = datetime . datetime ( date_interest . year , date_interest . month , duration ) print ( 'month_start,month_end' , month_start , month_end ) # Four selection crtieria in total, ser # Given a date of interest, and read-in the intraday data. histroy_data = histroy_data [ histroy_data [ 'Date' ] >= month_start ] histroy_data = histroy_data [ histroy_data [ 'Date' ] <= month_end ] # isolate the region of interest between the opening hour and the closing hour histroy_data = histroy_data [ histroy_data [ 'Time' ] >= open_hr ] histroy_data = histroy_data [ histroy_data [ 'Time' ] <= close_hr ] return histroy_data","title":"extract_month_minute_data"},{"location":"EC_tools/backtest/#EC_tools.backtest.gen_trunc_dict","text":"A function to choose what style of truncation dictionary to be generated. All trunc_dict have the following format: {\"entry\": [(...,...), ...], \"exit\": [(...,...), ...], \"stop\": [(...,...), ...], \"open\": (...,...) ,\"close\": (...,...)} This method allows you to choose whether to generate a trunc_dict using a given set of EES value (for crossover loop) or EES range (for range loop). For crossover loop, the Parameters: day ( DataFrame ) \u2013 DESCRIPTION. target_entry ( float ) \u2013 DESCRIPTION. target_exit ( float ) \u2013 DESCRIPTION. stop_exit ( float ) \u2013 DESCRIPTION. open_hr ( datetime ) \u2013 DESCRIPTION. close_hr ( datetime ) \u2013 DESCRIPTION. direction ( str ) \u2013 DESCRIPTION. loop_type ( LoopType ) \u2013 The loop type. The default is LoopType.CROSSOVER Returns: trunc_dict ( TYPE ) \u2013 DESCRIPTION. target_entry ( TYPE ) \u2013 DESCRIPTION. target_exit ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 def gen_trunc_dict ( loop_type : LoopType , day : pd . DataFrame , target_entry : float | list [ float , float ] | tuple [ float , float ] | dict [ str , float ], target_exit : float | list [ float , float ] | tuple [ float , float ] | dict [ str , float ], stop_exit : float , open_hr : datetime . datetime , close_hr : datetime . datetime , direction : str ) \\ -> tuple [ dict [ str , list | tuple ], float , float , float ]: \"\"\" A function to choose what style of truncation dictionary to be generated. All trunc_dict have the following format: {\"entry\": [(...,...), ...], \"exit\": [(...,...), ...], \"stop\": [(...,...), ...], \"open\": (...,...) ,\"close\": (...,...)} This method allows you to choose whether to generate a trunc_dict using a given set of EES value (for crossover loop) or EES range (for range loop). For crossover loop, the Parameters ---------- day : pd.DataFrame DESCRIPTION. target_entry : float DESCRIPTION. target_exit : float DESCRIPTION. stop_exit : float DESCRIPTION. open_hr : datetime.datetime DESCRIPTION. close_hr : datetime.datetime DESCRIPTION. direction : str DESCRIPTION. loop_type : LoopType The loop type. The default is LoopType.CROSSOVER Returns ------- trunc_dict : TYPE DESCRIPTION. target_entry : TYPE DESCRIPTION. target_exit : TYPE DESCRIPTION. \"\"\" if loop_type == LoopType . CROSSOVER : # Find the crossover points of EES trunc_dict = read . find_minute_EES ( day , target_entry , target_exit , stop_exit , open_hr = open_hr , close_hr = close_hr , direction = direction ) elif loop_type == LoopType . RANGE : # Find the appropiate range of EES trunc_dict = read . find_minute_EES_range ( day , target_entry , target_exit , stop_exit , open_hr = open_hr , close_hr = close_hr , direction = direction ) # target entry/exit are first estimations of the prices using # the mid point of the target range. The final entry/exit prices # will changeas the algo find the optimal price based on the selected # trade logic target_entry_mid = ( target_entry [ 1 ] - target_entry [ 0 ]) / 2 target_exit_mid = ( target_exit [ 1 ] - target_exit [ 0 ]) / 2 target_entry , target_exit = target_entry_mid , target_exit_mid return trunc_dict , target_entry , target_exit , stop_exit","title":"gen_trunc_dict"},{"location":"EC_tools/backtest/#EC_tools.backtest.load_EES_from_signal","text":"This method load the EES values based on the given trade logic and loop method. Parameters: trade_method ( TYPE ) \u2013 DESCRIPTION. loop_method ( TYPE ) \u2013 DESCRIPTION. item ( TYPE ) \u2013 DESCRIPTION. Returns: target_entry ( TYPE ) \u2013 DESCRIPTION. target_exit ( TYPE ) \u2013 DESCRIPTION. stop_exit ( TYPE ) \u2013 DESCRIPTION. direction ( TYPE ) \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 def load_EES_from_signal ( trade_method , loop_type : LoopType , item : pd . DataFrame ) \\ -> tuple [ float | int | dict [ str , float ], float | int | dict [ str , float ], float | int | dict [ str , float ], str ]: \"\"\" This method load the EES values based on the given trade logic and loop method. Parameters ---------- trade_method : TYPE DESCRIPTION. loop_method : TYPE DESCRIPTION. item : TYPE DESCRIPTION. Returns ------- target_entry : TYPE DESCRIPTION. target_exit : TYPE DESCRIPTION. stop_exit : TYPE DESCRIPTION. direction : TYPE DESCRIPTION. \"\"\" if trade_method . __name__ == \"OneTradePerDay\" or \\ trade_method . __name__ == \"OneTradePerDay_2\" or \\ trade_method . __name__ == \"MultiTradePerMonth\" : direction = item [ 'Direction' ] if loop_type == LoopType . CROSSOVER : if direction == 'Buy' or direction == 'Sell' : target_entry = item [ 'Entry_Price' ] target_exit = item [ 'Exit_Price' ] stop_exit = item [ 'StopLoss_Price' ] else : target_entry , target_exit , stop_exit = 'NA' , 'NA' , 'NA' elif loop_type == LoopType . RANGE : if direction == 'Buy' or direction == 'Sell' : target_entry = [ item [ 'Target_Lower_Entry_Price' ], item [ 'Target_Upper_Entry_Price' ]] target_exit = [ item [ 'Target_Lower_Exit_Price' ], item [ 'Target_Upper_Exit_Price' ]] stop_exit = item [ 'StopLoss_Price' ] else : target_entry , target_exit , stop_exit = [ 'NA' , 'NA' ], [ 'NA' , 'NA' ], 'NA' elif trade_method . __name__ == \"BiDirectionalTrade\" : if loop_type == LoopType . CROSSOVER : # Target_Lower_Entry_Price Target_Upper_Entry_Price # Target_Lower_Exit_Price Target_Upper_Exit_Price target_entry = { 'Buy' : item [ 'Q0.4' ], 'Sell' : item [ 'Q0.6' ]} target_exit = { 'Buy' : item [ 'Q0.6' ], 'Sell' : item [ 'Q0.4' ]} stop_exit = { 'Buy' : item [ 'Q0.1' ], 'Sell' : item [ 'Q0.9' ]} direction = 'Bitrade-' return target_entry , target_exit , stop_exit , direction","title":"load_EES_from_signal"},{"location":"EC_tools/backtest/#EC_tools.backtest.plot_in_backtest","text":"Parameters: date_interest ( str | datetime ) \u2013 DESCRIPTION. asset_name ( str ) \u2013 DESCRIPTION. EES_dict ( dict ) \u2013 DESCRIPTION. direction ( str ) \u2013 DESCRIPTION. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: None \u2013 DESCRIPTION. Source code in EC_tools/backtest.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def plot_in_backtest ( date_interest : str | datetime . datetime , asset_name : str , EES_dict : dict , direction : str , plot_or_not : bool = False ) -> None : \"\"\" Parameters ---------- date_interest : str | datetime.datetime DESCRIPTION. asset_name : str DESCRIPTION. EES_dict : dict DESCRIPTION. direction : str DESCRIPTION. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- None DESCRIPTION. \"\"\" if plot_or_not == True : if isinstance ( date_interest , datetime . datetime ): date_interest_str = date_interest . strftime ( \"%Y-%m- %d \" ) elif type ( date_interest ) == str : date_interest_str = date_interest if len ( EES_dict [ 'entry' ]) > 0 : entry_times , entry_pts = list ( zip ( * EES_dict [ 'entry' ])) else : entry_times , entry_pts = [], [] if len ( EES_dict [ 'exit' ]) > 0 : exit_times , exit_pts = list ( zip ( * EES_dict [ 'exit' ])) else : exit_times , exit_pts = [], [] if len ( EES_dict [ 'stop' ]) > 0 : stop_times , stop_pts = list ( zip ( * EES_dict [ 'stop' ])) else : stop_times , stop_pts = [], [] print ( 'bppt' , entry_times , entry_pts , exit_times , exit_pts , stop_times , stop_pts ) minute_data = HISTORY_MINTUE_FILE_LOC [ asset_name ] apc_data = APC_FILE_LOC [ asset_name ] plot . plot_minute ( minute_data , apc_data , date_interest = date_interest_str , direction = direction , bppt_x1 = entry_times , bppt_y1 = entry_pts , bppt_x2 = exit_times , bppt_y2 = exit_pts , bppt_x3 = stop_times , bppt_y3 = stop_pts ) elif plot_or_not == False : pass","title":"plot_in_backtest"},{"location":"EC_tools/backtest/#EC_tools.backtest.prepare_signal_interest","text":"A function that extract data from a signal table based on some directional instruction. Parameters: filename_buysell_signals ( str ) \u2013 The file name of the directional data. It read the table as a dataframe. direction ( ( list , str ) , default: ['Buy', 'Sell'] ) \u2013 The directional instruction. The default is [\"Buy\", \"Sell\"]. trim ( bool , default: False ) \u2013 Choose whether the result table contain only two clomns. The default is False. Returns: data ( pandas dataframe ) \u2013 The tuncated table with only the data of interest. Source code in EC_tools/backtest.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def prepare_signal_interest ( filename_buysell_signals : str , direction : list [ str ] = [ \"Buy\" , \"Sell\" ], trim : bool = False ) -> pd . DataFrame : \"\"\" A function that extract data from a signal table based on some directional instruction. Parameters ---------- filename_buysell_signals : str The file name of the directional data. It read the table as a dataframe. direction : list, str, optional The directional instruction. The default is [\"Buy\", \"Sell\"]. trim : bool, optional Choose whether the result table contain only two clomns. The default is False. Returns ------- data : pandas dataframe The tuncated table with only the data of interest. \"\"\" # read in direction data from the signal generation buysell_signals_data = pd . read_csv ( filename_buysell_signals ) # The trim function reduce the number of columns to only 'Date' and 'direction' # This may cut down the computing and memory cost when dealing with large # table. if trim == True : buysell_signals_data = buysell_signals_data [[ 'Date' , 'Direction' ]] elif trim == False : pass # Select for the signals in direction list. signal_data = [] for i in direction : temp = buysell_signals_data [ buysell_signals_data [ 'Direction' ] == i ] signal_data . append ( temp ) # concatenate the list of signals signal_interest = pd . concat ( signal_data , ignore_index = True ) # make a column with Timestamp as its content signal_interest [ 'Date' ] = [ datetime . datetime ( year = int ( str ( x )[ 0 : 4 ]), month = int ( str ( x )[ 5 : 7 ]), day = int ( str ( x )[ 8 :])) for x in signal_interest [ 'Date' ]] # sort the table by Date signal_interest . sort_values ( by = 'Date' , inplace = True ) return signal_interest","title":"prepare_signal_interest"},{"location":"EC_tools/features/","text":"features Created on Tue Aug 20 11:36:29 2024 @author: dexter GenHistoryStratData Bases: object A class that contains a collection of method that generate data for strategies base on history data Source code in EC_tools/features.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class GenHistoryStratData ( object ): \"\"\" A class that contains a collection of method that generate data for strategies base on history data \"\"\" def __init__ ( self , history ): self . _history = history return def gen_lag_data ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , price_proxy : str = 'Settle' , qunatile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ]) -> \\ tuple [ dict , list ]: \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" # use the history data to call a column using either OHLC lag_price = history_data_lag [ price_proxy ] # Find the quantile number for the lag APC at the Lag Prices lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # Storage strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } # The price of the quantile of interest, mostly for bookkeeping qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info def gen_lag_data_mode ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , price_proxy : str = 'Settle' , quantile_delta : list = [ - 0.1 , 0.0 , + 0.1 ]) -> \\ tuple [ dict , list ]: lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # turn the APC (cdf) to pdf in a list lag_pdf_list = [ mfunc . cal_pdf ( self . _quant_list , apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ]) for i in range ( len ( apc_curve_lag ))] # Calculate the price of the mode in these apc mode_Q_list = [ mfunc . find_pdf_quant ( lag_pdf_list [ i ][ 0 ], lag_pdf_list [ i ][ 1 ]) for i in range ( len ( apc_curve_lag ))] mode_Q_list . reverse () # calculate the rolling average for the mode rollingaverage_mode_q = np . average ( mode_Q_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q , 'mode_Q_list' : mode_Q_list , 'rollingaverage_mode' : rollingaverage_mode_q } # Find the quantile in the CDF (NOT THE PDF! important) from the mode_price quantile = [ quant + self . _curve_today_reverse_spline ( self . mode_price ) for quant in quantile_delta ] qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info gen_lag_data ( history_data_lag , apc_curve_lag , price_proxy = 'Settle' , qunatile = [ 0.25 , 0.4 , 0.6 , 0.75 ]) A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters: history_data_lag ( DataFrame ) \u2013 The history data of the lag days. apc_curve_lag ( DataFrame ) \u2013 The APC curve of the lag days. price_proxy ( str , default: 'Settle' ) \u2013 The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile ( list , default: [0.25, 0.4, 0.6, 0.75] ) \u2013 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns: strategy_info ( dict ) \u2013 A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. Source code in EC_tools/features.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def gen_lag_data ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , price_proxy : str = 'Settle' , qunatile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ]) -> \\ tuple [ dict , list ]: \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" # use the history data to call a column using either OHLC lag_price = history_data_lag [ price_proxy ] # Find the quantile number for the lag APC at the Lag Prices lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # Storage strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } # The price of the quantile of interest, mostly for bookkeeping qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info","title":"features"},{"location":"EC_tools/features/#features","text":"Created on Tue Aug 20 11:36:29 2024 @author: dexter","title":"features"},{"location":"EC_tools/features/#EC_tools.features.GenHistoryStratData","text":"Bases: object A class that contains a collection of method that generate data for strategies base on history data Source code in EC_tools/features.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class GenHistoryStratData ( object ): \"\"\" A class that contains a collection of method that generate data for strategies base on history data \"\"\" def __init__ ( self , history ): self . _history = history return def gen_lag_data ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , price_proxy : str = 'Settle' , qunatile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ]) -> \\ tuple [ dict , list ]: \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" # use the history data to call a column using either OHLC lag_price = history_data_lag [ price_proxy ] # Find the quantile number for the lag APC at the Lag Prices lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # Storage strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } # The price of the quantile of interest, mostly for bookkeeping qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info def gen_lag_data_mode ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , price_proxy : str = 'Settle' , quantile_delta : list = [ - 0.1 , 0.0 , + 0.1 ]) -> \\ tuple [ dict , list ]: lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # turn the APC (cdf) to pdf in a list lag_pdf_list = [ mfunc . cal_pdf ( self . _quant_list , apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ]) for i in range ( len ( apc_curve_lag ))] # Calculate the price of the mode in these apc mode_Q_list = [ mfunc . find_pdf_quant ( lag_pdf_list [ i ][ 0 ], lag_pdf_list [ i ][ 1 ]) for i in range ( len ( apc_curve_lag ))] mode_Q_list . reverse () # calculate the rolling average for the mode rollingaverage_mode_q = np . average ( mode_Q_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q , 'mode_Q_list' : mode_Q_list , 'rollingaverage_mode' : rollingaverage_mode_q } # Find the quantile in the CDF (NOT THE PDF! important) from the mode_price quantile = [ quant + self . _curve_today_reverse_spline ( self . mode_price ) for quant in quantile_delta ] qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info","title":"GenHistoryStratData"},{"location":"EC_tools/features/#EC_tools.features.GenHistoryStratData.gen_lag_data","text":"A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters: history_data_lag ( DataFrame ) \u2013 The history data of the lag days. apc_curve_lag ( DataFrame ) \u2013 The APC curve of the lag days. price_proxy ( str , default: 'Settle' ) \u2013 The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile ( list , default: [0.25, 0.4, 0.6, 0.75] ) \u2013 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns: strategy_info ( dict ) \u2013 A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. Source code in EC_tools/features.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def gen_lag_data ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , price_proxy : str = 'Settle' , qunatile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ]) -> \\ tuple [ dict , list ]: \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" # use the history data to call a column using either OHLC lag_price = history_data_lag [ price_proxy ] # Find the quantile number for the lag APC at the Lag Prices lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ 1 : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # Storage strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } # The price of the quantile of interest, mostly for bookkeeping qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info","title":"gen_lag_data"},{"location":"EC_tools/math_func/","text":"Math_Func Created on Fri Apr 19 03:05:10 2024 @author: dexter This is a utility library for mathematical operations. cal_pdf ( quant , cdf ) Calcualte the probability distribution function (pdf) from a cumulative probability distribution function (cdf). Parameters: quant ( 1D list ) \u2013 The distribution of the events. cdf ( 1D list ) \u2013 The value of the cdf. Returns: spaced_events ( 1D list ) \u2013 The value of the events. pdf ( 1D list ) \u2013 The probability of the events. Source code in EC_tools/math_func.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def cal_pdf ( quant , cdf ): \"\"\" Calcualte the probability distribution function (pdf) from a cumulative probability distribution function (cdf). Parameters ---------- quant : 1D list The distribution of the events. cdf : 1D list The value of the cdf. Returns ------- spaced_events : 1D list The value of the events. pdf : 1D list The probability of the events. \"\"\" # Define the evenly spaced events for the cdf spaced_events = np . arange ( np . min ( cdf ), np . max ( cdf ), 0.005 ) #print(len(spaced_events)) # interpolate the qunatile given the cdf spline_apc_rev = UnivariateSpline ( cdf , quant , s = 0 ) quant_even_prices = spline_apc_rev ( spaced_events ) # get the corresponding quantile # make the differential dq using the 1st and 2nd elements dq = spaced_events [ 1 ] - spaced_events [ 0 ] deriv = fd . FinDiff ( 0 , dq , 1 ) pdf = deriv ( quant_even_prices ) # perform the differentiation on cdf, outcome the pdf #print(len(pdf)) # interpolate the pdf with the spaced events spline_pdf = UnivariateSpline ( spaced_events , pdf , s = 0.0015 ) pdf = spline_pdf ( spaced_events ) #print(len(pdf)) return spaced_events , pdf find_pdf_quant ( pdf_val , pdf , func = max ) A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters: pdf_val \u2013 pdf \u2013 func \u2013 Returns \u2013 Price \u2013 Source code in EC_tools/math_func.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def find_pdf_quant ( pdf_val , pdf , func = max ): \"\"\" A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters ---------- pdf_val : pdf : func Returns ------_ Price for that centile \"\"\" centile_index = list ( pdf ) . index ( func ( pdf )) return float ( pdf [ centile_index ]) find_pdf_val ( pdf_val , pdf , func = max ) A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters: pdf_val \u2013 pdf \u2013 func \u2013 Returns \u2013 Price \u2013 Source code in EC_tools/math_func.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def find_pdf_val ( pdf_val , pdf , func = max ): \"\"\" A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters ---------- pdf_val : pdf : func Returns ------_ Price for that centile \"\"\" centile_index = list ( pdf ) . index ( func ( pdf )) return float ( pdf_val [ centile_index ]) find_quant ( cdf , quant_list , val ) This is an inverse Spline interpolation treating the cdf as the x-axis. This is meant to find the corresponding quantile with a given price. This function assumes a range of probability distribution function in between 0.0025 and 0.9975 qantiles that has a 0.0025 interval Parameters: cdf ( 1D pandas dataframe ) \u2013 A 1D array that contains a discrete number of cdf points. val ( float ) \u2013 The given value (e.g. price). Returns: quant ( float ) \u2013 The corresponding quantile. Source code in EC_tools/math_func.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def find_quant ( cdf , quant_list , val ): \"\"\" This is an inverse Spline interpolation treating the cdf as the x-axis. This is meant to find the corresponding quantile with a given price. This function assumes a range of probability distribution function in between 0.0025 and 0.9975 qantiles that has a 0.0025 interval Parameters ---------- cdf : 1D pandas dataframe A 1D array that contains a discrete number of cdf points. val : float The given value (e.g. price). Returns ------- quant : float The corresponding quantile. \"\"\" spline = CubicSpline ( cdf , quant_list ) quant = spline ( val ) return float ( quant ) generic_spline ( x , y , method = 'cubic' , s = 0 ) A generic method to interpolate data. Parameters: x ( numpy array ) \u2013 x-axis. y ( numpy array ) \u2013 y-axis. method ( str , default: 'cubic' ) \u2013 The method of interpolation. The default is \"cubic\". Returns: func ( TYPE ) \u2013 A callable function. Source code in EC_tools/math_func.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def generic_spline ( x , y , method = \"cubic\" , s = 0 ): \"\"\" A generic method to interpolate data. Parameters ---------- x : numpy array x-axis. y : numpy array y-axis. method : str, optional The method of interpolation. The default is \"cubic\". Returns ------- func : TYPE A callable function. \"\"\" # generic interpolate method Cubic spline and what not method_dict = { 'cubic' : CubicSpline , 'univariate' : UnivariateSpline } func = method_dict [ method ] # ============================================================================= # if method == \"cubic\": # func = CubicSpline(x, y) # elif method ==\"univariate\": # func = UnivariateSpline(x, y, s=s) # ============================================================================= return func ( x , y )","title":"Math_Func"},{"location":"EC_tools/math_func/#math_func","text":"Created on Fri Apr 19 03:05:10 2024 @author: dexter This is a utility library for mathematical operations.","title":"Math_Func"},{"location":"EC_tools/math_func/#EC_tools.math_func.cal_pdf","text":"Calcualte the probability distribution function (pdf) from a cumulative probability distribution function (cdf). Parameters: quant ( 1D list ) \u2013 The distribution of the events. cdf ( 1D list ) \u2013 The value of the cdf. Returns: spaced_events ( 1D list ) \u2013 The value of the events. pdf ( 1D list ) \u2013 The probability of the events. Source code in EC_tools/math_func.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def cal_pdf ( quant , cdf ): \"\"\" Calcualte the probability distribution function (pdf) from a cumulative probability distribution function (cdf). Parameters ---------- quant : 1D list The distribution of the events. cdf : 1D list The value of the cdf. Returns ------- spaced_events : 1D list The value of the events. pdf : 1D list The probability of the events. \"\"\" # Define the evenly spaced events for the cdf spaced_events = np . arange ( np . min ( cdf ), np . max ( cdf ), 0.005 ) #print(len(spaced_events)) # interpolate the qunatile given the cdf spline_apc_rev = UnivariateSpline ( cdf , quant , s = 0 ) quant_even_prices = spline_apc_rev ( spaced_events ) # get the corresponding quantile # make the differential dq using the 1st and 2nd elements dq = spaced_events [ 1 ] - spaced_events [ 0 ] deriv = fd . FinDiff ( 0 , dq , 1 ) pdf = deriv ( quant_even_prices ) # perform the differentiation on cdf, outcome the pdf #print(len(pdf)) # interpolate the pdf with the spaced events spline_pdf = UnivariateSpline ( spaced_events , pdf , s = 0.0015 ) pdf = spline_pdf ( spaced_events ) #print(len(pdf)) return spaced_events , pdf","title":"cal_pdf"},{"location":"EC_tools/math_func/#EC_tools.math_func.find_pdf_quant","text":"A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters: pdf_val \u2013 pdf \u2013 func \u2013 Returns \u2013 Price \u2013 Source code in EC_tools/math_func.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def find_pdf_quant ( pdf_val , pdf , func = max ): \"\"\" A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters ---------- pdf_val : pdf : func Returns ------_ Price for that centile \"\"\" centile_index = list ( pdf ) . index ( func ( pdf )) return float ( pdf [ centile_index ])","title":"find_pdf_quant"},{"location":"EC_tools/math_func/#EC_tools.math_func.find_pdf_val","text":"A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters: pdf_val \u2013 pdf \u2013 func \u2013 Returns \u2013 Price \u2013 Source code in EC_tools/math_func.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def find_pdf_val ( pdf_val , pdf , func = max ): \"\"\" A generic method to extract the price of a particular centile given a function operation over the pdf. For example, func can be max(), median(), average(), lambda functions, etc. Parameters ---------- pdf_val : pdf : func Returns ------_ Price for that centile \"\"\" centile_index = list ( pdf ) . index ( func ( pdf )) return float ( pdf_val [ centile_index ])","title":"find_pdf_val"},{"location":"EC_tools/math_func/#EC_tools.math_func.find_quant","text":"This is an inverse Spline interpolation treating the cdf as the x-axis. This is meant to find the corresponding quantile with a given price. This function assumes a range of probability distribution function in between 0.0025 and 0.9975 qantiles that has a 0.0025 interval Parameters: cdf ( 1D pandas dataframe ) \u2013 A 1D array that contains a discrete number of cdf points. val ( float ) \u2013 The given value (e.g. price). Returns: quant ( float ) \u2013 The corresponding quantile. Source code in EC_tools/math_func.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def find_quant ( cdf , quant_list , val ): \"\"\" This is an inverse Spline interpolation treating the cdf as the x-axis. This is meant to find the corresponding quantile with a given price. This function assumes a range of probability distribution function in between 0.0025 and 0.9975 qantiles that has a 0.0025 interval Parameters ---------- cdf : 1D pandas dataframe A 1D array that contains a discrete number of cdf points. val : float The given value (e.g. price). Returns ------- quant : float The corresponding quantile. \"\"\" spline = CubicSpline ( cdf , quant_list ) quant = spline ( val ) return float ( quant )","title":"find_quant"},{"location":"EC_tools/math_func/#EC_tools.math_func.generic_spline","text":"A generic method to interpolate data. Parameters: x ( numpy array ) \u2013 x-axis. y ( numpy array ) \u2013 y-axis. method ( str , default: 'cubic' ) \u2013 The method of interpolation. The default is \"cubic\". Returns: func ( TYPE ) \u2013 A callable function. Source code in EC_tools/math_func.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def generic_spline ( x , y , method = \"cubic\" , s = 0 ): \"\"\" A generic method to interpolate data. Parameters ---------- x : numpy array x-axis. y : numpy array y-axis. method : str, optional The method of interpolation. The default is \"cubic\". Returns ------- func : TYPE A callable function. \"\"\" # generic interpolate method Cubic spline and what not method_dict = { 'cubic' : CubicSpline , 'univariate' : UnivariateSpline } func = method_dict [ method ] # ============================================================================= # if method == \"cubic\": # func = CubicSpline(x, y) # elif method ==\"univariate\": # func = UnivariateSpline(x, y, s=s) # ============================================================================= return func ( x , y )","title":"generic_spline"},{"location":"EC_tools/plot/","text":"plot Created on Fri May 10 18:33:06 2024 @author: dexter Intraday price plotting functions PlotPricing Bases: object Source code in EC_tools/plot.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 class PlotPricing ( object ): # A clss that control the state of the pricing plots. # It can also create more subplot derived from the Pricing data def __init__ ( self , axis_limit = AxisLimit (), subcomp = None , nrows = 1 , ncols = 2 ): self . fig = plt . figure ( figsize = ( 10 , 4 )) # make a way to change the number of subplot based on nrows and ncols self . gs = self . fig . add_gridspec ( nrows = 1 , ncols = 2 , width_ratios = [ 4 , 1 ]) self . axis_limit = axis_limit self . subcomp = subcomp self . _add_pdf_panel = False self . _add_vol_panel = False self . add_subpot = False self . _color_mode = color_dict_dark_mode #super().__init__() def controller ( self , ax , * args , ** kwargs ): # A function that control which subcomponents and subplots are turned on # Add subcomponents return None def plot_price ( self , x , y , events , pdf , quant_list , quant_price_list , direction = \"Neutral\" , price_chart_title = \"Date\" , events_lower_limit = 70 , events_upper_limit = 78 , open_hr = '0330' , close_hr = '1930' , xlabel = \"Time (minutes)\" , x_format = '%H:%M' , bppt_x1 = [], bppt_y1 = [], bppt_x2 = [], bppt_y2 = [], bppt_x3 = [], bppt_y3 = [], date_interest = datetime . datetime . today ()): \"\"\" A function that plot the intraday minute pricing chart alongside the APC. Parameters ---------- x : list The intraday minutes. y : list The price of intraday data. events : list The price of the APC. pdf : list The probability of the APC's pdf. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. direction : str Buy\", \"Sell\", or \"Neutral\" signal. price_chart_title : str, optional The title of the plot. The default is \"Date\". open_hr : str, optional The opening hour of a trade day. The default is 0330 (03:30 at UK time). close_hr : str, optional The closing hour of a trade day. The default is 1900 (07:00 pm). events_lower_limit : TYPE, optional The lower bound in y-axis of the plot. The default is 70. events_upper_limit : TYPE, optional The upper bound in y-axis of the plot. The default is 78. Returns ------- fig : <class 'matplotlib.figure.Figure'> The figure. \"\"\" x_o = XObject ( x ) x_o . x = 'datetime' x_datetime = x_o . x o_hr = XObject ( open_hr ) c_hr = XObject ( close_hr ) o_hr . x = 'datetime' c_hr . x = 'datetime' open_hr = o_hr . x [ 0 ] close_hr = c_hr . x [ 0 ] #buy_time = datetime.time(hour = int(buy_time[-4:-2]), minute = int(buy_time[-2:])) #sell_time = datetime.time(hour = int(sell_time[-4:-2]), minute = int(sell_time[-2:])) EES_txt_start_time = datetime . time ( hour = 20 , minute = 50 ) #buy_time = datetime.datetime.combine(datetime.date.today(), buy_time) #sell_time = datetime.datetime.combine(datetime.date.today(), sell_time) EES_txt_start_time = datetime . datetime . combine ( datetime . date . today (), EES_txt_start_time ) # choose the color mode plt . style . use ( 'dark_background' ) pt_col = self . _color_mode [ 'data_col' ] # plotting area #fig = plt.figure(figsize=(10,4)) #gs = fig.add_gridspec(nrows=1, ncols = 2, width_ratios = [4,1]) ax1 = self . fig . add_subplot ( self . gs [ 0 ]) ax1 . plot ( x_datetime , y , 'o--' , ms = 2 , c = pt_col ) # set plot limits ax1 . set_xlim ([ self . axis_limit . start_line , self . axis_limit . end_line ]) ax1 . set_ylim ([ self . axis_limit . price_lower_limit , self . axis_limit . price_upper_limit ]) ax1 . set_xlabel ( xlabel ) ax1 . set_ylabel ( \"Price (USD)\" ) ax1 . set_title ( price_chart_title ) fmt = mdates . DateFormatter ( x_format ) ax1 . xaxis . set_major_formatter ( fmt ) ax1 . grid () # define the pixels of shift for the texts in both x and y axis txt_shift_x , txt_shift_y = np . std ( pdf ) / 2 , np . std ( events ) / 20 #define the shift in dates txt_shift_x_date = datetime . timedelta ( hours = round ( np . std ( pdf ) / 2 )) # Add sub plots self . _add_pdf_panel = True # add other subplots if self . _add_pdf_panel == True : # add APC subplot self . add_pdf_panel ( ax1 , pdf , events , quant_list , quant_price_list ) # Add subcomponents subcomp = SubComponents ( ax1 ) subcomp . _quant_lines = True subcomp . _add_EES_region = False subcomp . _add_EES_range_region = True subcomp . _add_crossover_pts = True subcomp . _add_trade_region = True # add the EES regions if subcomp . _add_EES_region : if direction == \"Buy\" : entry_price = quant_price_list [ 1 ] exit_price = quant_price_list [ 3 ] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = quant_price_list [ 3 ] exit_price = quant_price_list [ 1 ] stop_loss = quant_price_list [ 4 ] elif direction == \"Neutral\" : entry_price = np . nan exit_price = np . nan stop_loss = np . nan subcomp . EES_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) if subcomp . _add_EES_range_region : if direction == \"Buy\" : entry_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] exit_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] exit_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] stop_loss = quant_price_list [ 6 ] elif direction == \"Neutral\" : entry_price = [ np . nan , np . nan ] exit_price = [ np . nan , np . nan ] stop_loss = np . nan subcomp . EES_range_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) # add quantile lines to the plot if subcomp . _quant_lines : subcomp . quant_lines ( quant_list , quant_price_list , txt_shift_x_date , txt_shift_y , start_x = self . axis_limit . start_line , end_x = self . axis_limit . end_line , alpha = 0.5 ) # add cross over points if subcomp . _add_crossover_pts : print ( \"Add crossover points\" ) bppt_x1 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x1 ] bppt_x2 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x2 ] bppt_x3 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x3 ] print ( \"subcomp._add_crossover_pts\" , subcomp . _add_crossover_pts , bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) subcomp . crossover_pts ( bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) if subcomp . _add_trade_region : subcomp . trade_region ( open_hr , close_hr ) # add the buying and selling points #add_buysell_points(ax1, buy_time, buy_price, sell_time, sell_price) plt . show () return self . fig def add_pdf_panel ( self , sharey , pdf , events , quant_list , quant_price_list , title = 'APC' , pt_col = 'orange' ): # define the pixels of shift for the texts in both x and y axis txt_shift_x , txt_shift_y = np . std ( pdf ) / 2 , np . std ( events ) / 20 #define the shift in dates txt_shift_x_date = datetime . timedelta ( hours = round ( np . std ( pdf ) / 2 )) ax_apc = self . fig . add_subplot ( self . gs [ 1 ], sharey = sharey ) ax_apc . plot ( pdf , events , 'o' , c = pt_col , ms = 2 ) SubComponents ( ax_apc ) . quant_lines ( quant_list , quant_price_list , txt_shift_x , txt_shift_y ) ax_apc . set_xlim ([ - 0.005 , max ( pdf ) + np . std ( pdf ) / 4 ]) ax_apc . set_title ( title ) ax_apc . set_xlabel ( \"Probability\" ) ax_apc . invert_xaxis () ax_apc . grid () @property def add_volume_panel ( self ): return None plot_price ( x , y , events , pdf , quant_list , quant_price_list , direction = 'Neutral' , price_chart_title = 'Date' , events_lower_limit = 70 , events_upper_limit = 78 , open_hr = '0330' , close_hr = '1930' , xlabel = 'Time (minutes)' , x_format = '%H:%M' , bppt_x1 = [], bppt_y1 = [], bppt_x2 = [], bppt_y2 = [], bppt_x3 = [], bppt_y3 = [], date_interest = datetime . datetime . today ()) A function that plot the intraday minute pricing chart alongside the APC. Parameters: x ( list ) \u2013 The intraday minutes. y ( list ) \u2013 The price of intraday data. events ( list ) \u2013 The price of the APC. pdf ( list ) \u2013 The probability of the APC's pdf. quant_list ( list ) \u2013 A list of quantile name for text marking on the plot. quant_price_list ( list ) \u2013 The price of the horizontal lines corresponding to quant_list. direction ( str , default: 'Neutral' ) \u2013 Buy\", \"Sell\", or \"Neutral\" signal. price_chart_title ( str , default: 'Date' ) \u2013 The title of the plot. The default is \"Date\". open_hr ( str , default: '0330' ) \u2013 The opening hour of a trade day. The default is 0330 (03:30 at UK time). close_hr ( str , default: '1930' ) \u2013 The closing hour of a trade day. The default is 1900 (07:00 pm). events_lower_limit ( TYPE , default: 70 ) \u2013 The lower bound in y-axis of the plot. The default is 70. events_upper_limit ( TYPE , default: 78 ) \u2013 The upper bound in y-axis of the plot. The default is 78. Returns: fig ( <class 'matplotlib.figure.Figure'> ) \u2013 The figure. Source code in EC_tools/plot.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def plot_price ( self , x , y , events , pdf , quant_list , quant_price_list , direction = \"Neutral\" , price_chart_title = \"Date\" , events_lower_limit = 70 , events_upper_limit = 78 , open_hr = '0330' , close_hr = '1930' , xlabel = \"Time (minutes)\" , x_format = '%H:%M' , bppt_x1 = [], bppt_y1 = [], bppt_x2 = [], bppt_y2 = [], bppt_x3 = [], bppt_y3 = [], date_interest = datetime . datetime . today ()): \"\"\" A function that plot the intraday minute pricing chart alongside the APC. Parameters ---------- x : list The intraday minutes. y : list The price of intraday data. events : list The price of the APC. pdf : list The probability of the APC's pdf. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. direction : str Buy\", \"Sell\", or \"Neutral\" signal. price_chart_title : str, optional The title of the plot. The default is \"Date\". open_hr : str, optional The opening hour of a trade day. The default is 0330 (03:30 at UK time). close_hr : str, optional The closing hour of a trade day. The default is 1900 (07:00 pm). events_lower_limit : TYPE, optional The lower bound in y-axis of the plot. The default is 70. events_upper_limit : TYPE, optional The upper bound in y-axis of the plot. The default is 78. Returns ------- fig : <class 'matplotlib.figure.Figure'> The figure. \"\"\" x_o = XObject ( x ) x_o . x = 'datetime' x_datetime = x_o . x o_hr = XObject ( open_hr ) c_hr = XObject ( close_hr ) o_hr . x = 'datetime' c_hr . x = 'datetime' open_hr = o_hr . x [ 0 ] close_hr = c_hr . x [ 0 ] #buy_time = datetime.time(hour = int(buy_time[-4:-2]), minute = int(buy_time[-2:])) #sell_time = datetime.time(hour = int(sell_time[-4:-2]), minute = int(sell_time[-2:])) EES_txt_start_time = datetime . time ( hour = 20 , minute = 50 ) #buy_time = datetime.datetime.combine(datetime.date.today(), buy_time) #sell_time = datetime.datetime.combine(datetime.date.today(), sell_time) EES_txt_start_time = datetime . datetime . combine ( datetime . date . today (), EES_txt_start_time ) # choose the color mode plt . style . use ( 'dark_background' ) pt_col = self . _color_mode [ 'data_col' ] # plotting area #fig = plt.figure(figsize=(10,4)) #gs = fig.add_gridspec(nrows=1, ncols = 2, width_ratios = [4,1]) ax1 = self . fig . add_subplot ( self . gs [ 0 ]) ax1 . plot ( x_datetime , y , 'o--' , ms = 2 , c = pt_col ) # set plot limits ax1 . set_xlim ([ self . axis_limit . start_line , self . axis_limit . end_line ]) ax1 . set_ylim ([ self . axis_limit . price_lower_limit , self . axis_limit . price_upper_limit ]) ax1 . set_xlabel ( xlabel ) ax1 . set_ylabel ( \"Price (USD)\" ) ax1 . set_title ( price_chart_title ) fmt = mdates . DateFormatter ( x_format ) ax1 . xaxis . set_major_formatter ( fmt ) ax1 . grid () # define the pixels of shift for the texts in both x and y axis txt_shift_x , txt_shift_y = np . std ( pdf ) / 2 , np . std ( events ) / 20 #define the shift in dates txt_shift_x_date = datetime . timedelta ( hours = round ( np . std ( pdf ) / 2 )) # Add sub plots self . _add_pdf_panel = True # add other subplots if self . _add_pdf_panel == True : # add APC subplot self . add_pdf_panel ( ax1 , pdf , events , quant_list , quant_price_list ) # Add subcomponents subcomp = SubComponents ( ax1 ) subcomp . _quant_lines = True subcomp . _add_EES_region = False subcomp . _add_EES_range_region = True subcomp . _add_crossover_pts = True subcomp . _add_trade_region = True # add the EES regions if subcomp . _add_EES_region : if direction == \"Buy\" : entry_price = quant_price_list [ 1 ] exit_price = quant_price_list [ 3 ] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = quant_price_list [ 3 ] exit_price = quant_price_list [ 1 ] stop_loss = quant_price_list [ 4 ] elif direction == \"Neutral\" : entry_price = np . nan exit_price = np . nan stop_loss = np . nan subcomp . EES_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) if subcomp . _add_EES_range_region : if direction == \"Buy\" : entry_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] exit_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] exit_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] stop_loss = quant_price_list [ 6 ] elif direction == \"Neutral\" : entry_price = [ np . nan , np . nan ] exit_price = [ np . nan , np . nan ] stop_loss = np . nan subcomp . EES_range_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) # add quantile lines to the plot if subcomp . _quant_lines : subcomp . quant_lines ( quant_list , quant_price_list , txt_shift_x_date , txt_shift_y , start_x = self . axis_limit . start_line , end_x = self . axis_limit . end_line , alpha = 0.5 ) # add cross over points if subcomp . _add_crossover_pts : print ( \"Add crossover points\" ) bppt_x1 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x1 ] bppt_x2 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x2 ] bppt_x3 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x3 ] print ( \"subcomp._add_crossover_pts\" , subcomp . _add_crossover_pts , bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) subcomp . crossover_pts ( bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) if subcomp . _add_trade_region : subcomp . trade_region ( open_hr , close_hr ) # add the buying and selling points #add_buysell_points(ax1, buy_time, buy_price, sell_time, sell_price) plt . show () return self . fig SubComponents Bases: object Source code in EC_tools/plot.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 class SubComponents ( object ): # All subcomponents for Price plotting. This can be inheretance class def __init__ ( self , ax , axis_limit = AxisLimit ()): self . ax = ax # the location that these things should be added self . _quant_lines = False self . _add_EES_region = False self . _add_trade_region = False self . _add_crossover_pts = False self . _add_entry_exit_points = False self . _add_bol_band = False self . _add_fibo_retract_lines = False self . txt_shift_x = None self . txt_shift_y = None self . axis_limit = axis_limit # WIP # super().__init__() def quant_lines ( self , quant_list , quant_price_list , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 100 , alpha = 0.5 ): \"\"\" A function that add the quantile lines to a plot. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. start_x: float, or datetime.time The starting position for the text in x-axis end_x: float, or datetime.time The ending position for the text in x-axis alpha : float, optional The transparency of the quantile line. The default is 0.5. \"\"\" for quant , price in zip ( quant_list , quant_price_list ): self . ax . hlines ( float ( price . iloc [ 0 ]), start_x , end_x , color = '#C26F05' , alpha = alpha ) self . ax . text ( start_x + txt_shift_x , float ( price . iloc [ 0 ]) + txt_shift_y , quant , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#C26F05' )) def EES_region ( self , entry_price , exit_price , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price = float ( entry_price . iloc [ 0 ]) exit_price = float ( exit_price . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price , exit_price , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' )) def EES_range_region ( self , entry_price_range , exit_price_range , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price_lower = float ( entry_price_range [ 0 ] . iloc [ 0 ]) entry_price_upper = float ( entry_price_range [ 1 ] . iloc [ 0 ]) exit_price_lower = float ( exit_price_range [ 0 ] . iloc [ 0 ]) exit_price_upper = float ( exit_price_range [ 1 ] . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( entry_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( exit_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price_lower , entry_price_upper , color = 'green' , alpha = 0.3 ) self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], exit_price_lower , exit_price_upper , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price_upper + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price_upper + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' )) def trade_region ( self , open_hr , close_hr ): # fill the closed trading hours with shade # the vertical lines that self . ax . vlines ( open_hr , 0 , 2000 , 'w' ) self . ax . vlines ( close_hr , 0 , 2000 , 'w' ) self . ax . fill_between ([ self . axis_limit . start_line , open_hr ], 0 , 2000 , color = 'grey' , alpha = 0.3 ) self . ax . fill_between ([ close_hr , self . axis_limit . end_line ], 0 , 2000 , color = 'grey' , alpha = 0.3 ) # the vertical lines that self . ax . vlines ( open_hr , 0 , 2000 , 'k' ) self . ax . vlines ( close_hr , 0 , 2000 , 'k' ) def crossover_pts ( self , bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ): print ( \"crossover_pts\" ) print ( bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) # crossover points set 1 self . ax . plot ( bppt_x1 , bppt_y1 , 'o' , ms = 10 , c = 'blue' ) self . ax . plot ( bppt_x2 , bppt_y2 , 'o' , ms = 10 , c = 'green' ) self . ax . plot ( bppt_x3 , bppt_y3 , 'o' , ms = 26 , c = 'red' ) def buysellpoints ( self , buy_time = \"1201\" , buy_price = 86.05 , sell_time = \"1900\" , sell_price = 85.70 ): return None EES_range_region ( entry_price_range , exit_price_range , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = 'Neutral' ) A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters: ax ( <class 'matplotlib.axes._axes.Axes'> ) \u2013 The figure. entry_price ( float ) \u2013 entry_price. exit_price ( float ) \u2013 exit_price. stop_loss ( float ) \u2013 stop_loss. txt_shift_x ( float ) \u2013 The shift in x-axis for the text. txt_shift_y ( float ) \u2013 The shift in y-axis for the text. direction ( str , default: 'Neutral' ) \u2013 \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". Source code in EC_tools/plot.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 def EES_range_region ( self , entry_price_range , exit_price_range , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price_lower = float ( entry_price_range [ 0 ] . iloc [ 0 ]) entry_price_upper = float ( entry_price_range [ 1 ] . iloc [ 0 ]) exit_price_lower = float ( exit_price_range [ 0 ] . iloc [ 0 ]) exit_price_upper = float ( exit_price_range [ 1 ] . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( entry_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( exit_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price_lower , entry_price_upper , color = 'green' , alpha = 0.3 ) self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], exit_price_lower , exit_price_upper , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price_upper + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price_upper + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' )) EES_region ( entry_price , exit_price , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = 'Neutral' ) A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters: ax ( <class 'matplotlib.axes._axes.Axes'> ) \u2013 The figure. entry_price ( float ) \u2013 entry_price. exit_price ( float ) \u2013 exit_price. stop_loss ( float ) \u2013 stop_loss. txt_shift_x ( float ) \u2013 The shift in x-axis for the text. txt_shift_y ( float ) \u2013 The shift in y-axis for the text. direction ( str , default: 'Neutral' ) \u2013 \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". Source code in EC_tools/plot.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 def EES_region ( self , entry_price , exit_price , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price = float ( entry_price . iloc [ 0 ]) exit_price = float ( exit_price . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price , exit_price , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' )) quant_lines ( quant_list , quant_price_list , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 100 , alpha = 0.5 ) A function that add the quantile lines to a plot. Parameters: ax ( <class 'matplotlib.axes._axes.Axes'> ) \u2013 The figure. quant_list ( list ) \u2013 A list of quantile name for text marking on the plot. quant_price_list ( list ) \u2013 The price of the horizontal lines corresponding to quant_list. txt_shift_x ( float ) \u2013 The shift in x-axis for the text. txt_shift_y ( float ) \u2013 The shift in y-axis for the text. start_x \u2013 The starting position for the text in x-axis end_x \u2013 The ending position for the text in x-axis alpha ( float , default: 0.5 ) \u2013 The transparency of the quantile line. The default is 0.5. Source code in EC_tools/plot.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def quant_lines ( self , quant_list , quant_price_list , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 100 , alpha = 0.5 ): \"\"\" A function that add the quantile lines to a plot. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. start_x: float, or datetime.time The starting position for the text in x-axis end_x: float, or datetime.time The ending position for the text in x-axis alpha : float, optional The transparency of the quantile line. The default is 0.5. \"\"\" for quant , price in zip ( quant_list , quant_price_list ): self . ax . hlines ( float ( price . iloc [ 0 ]), start_x , end_x , color = '#C26F05' , alpha = alpha ) self . ax . text ( start_x + txt_shift_x , float ( price . iloc [ 0 ]) + txt_shift_y , quant , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#C26F05' ))","title":"plot"},{"location":"EC_tools/plot/#plot","text":"Created on Fri May 10 18:33:06 2024 @author: dexter Intraday price plotting functions","title":"plot"},{"location":"EC_tools/plot/#EC_tools.plot.PlotPricing","text":"Bases: object Source code in EC_tools/plot.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 class PlotPricing ( object ): # A clss that control the state of the pricing plots. # It can also create more subplot derived from the Pricing data def __init__ ( self , axis_limit = AxisLimit (), subcomp = None , nrows = 1 , ncols = 2 ): self . fig = plt . figure ( figsize = ( 10 , 4 )) # make a way to change the number of subplot based on nrows and ncols self . gs = self . fig . add_gridspec ( nrows = 1 , ncols = 2 , width_ratios = [ 4 , 1 ]) self . axis_limit = axis_limit self . subcomp = subcomp self . _add_pdf_panel = False self . _add_vol_panel = False self . add_subpot = False self . _color_mode = color_dict_dark_mode #super().__init__() def controller ( self , ax , * args , ** kwargs ): # A function that control which subcomponents and subplots are turned on # Add subcomponents return None def plot_price ( self , x , y , events , pdf , quant_list , quant_price_list , direction = \"Neutral\" , price_chart_title = \"Date\" , events_lower_limit = 70 , events_upper_limit = 78 , open_hr = '0330' , close_hr = '1930' , xlabel = \"Time (minutes)\" , x_format = '%H:%M' , bppt_x1 = [], bppt_y1 = [], bppt_x2 = [], bppt_y2 = [], bppt_x3 = [], bppt_y3 = [], date_interest = datetime . datetime . today ()): \"\"\" A function that plot the intraday minute pricing chart alongside the APC. Parameters ---------- x : list The intraday minutes. y : list The price of intraday data. events : list The price of the APC. pdf : list The probability of the APC's pdf. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. direction : str Buy\", \"Sell\", or \"Neutral\" signal. price_chart_title : str, optional The title of the plot. The default is \"Date\". open_hr : str, optional The opening hour of a trade day. The default is 0330 (03:30 at UK time). close_hr : str, optional The closing hour of a trade day. The default is 1900 (07:00 pm). events_lower_limit : TYPE, optional The lower bound in y-axis of the plot. The default is 70. events_upper_limit : TYPE, optional The upper bound in y-axis of the plot. The default is 78. Returns ------- fig : <class 'matplotlib.figure.Figure'> The figure. \"\"\" x_o = XObject ( x ) x_o . x = 'datetime' x_datetime = x_o . x o_hr = XObject ( open_hr ) c_hr = XObject ( close_hr ) o_hr . x = 'datetime' c_hr . x = 'datetime' open_hr = o_hr . x [ 0 ] close_hr = c_hr . x [ 0 ] #buy_time = datetime.time(hour = int(buy_time[-4:-2]), minute = int(buy_time[-2:])) #sell_time = datetime.time(hour = int(sell_time[-4:-2]), minute = int(sell_time[-2:])) EES_txt_start_time = datetime . time ( hour = 20 , minute = 50 ) #buy_time = datetime.datetime.combine(datetime.date.today(), buy_time) #sell_time = datetime.datetime.combine(datetime.date.today(), sell_time) EES_txt_start_time = datetime . datetime . combine ( datetime . date . today (), EES_txt_start_time ) # choose the color mode plt . style . use ( 'dark_background' ) pt_col = self . _color_mode [ 'data_col' ] # plotting area #fig = plt.figure(figsize=(10,4)) #gs = fig.add_gridspec(nrows=1, ncols = 2, width_ratios = [4,1]) ax1 = self . fig . add_subplot ( self . gs [ 0 ]) ax1 . plot ( x_datetime , y , 'o--' , ms = 2 , c = pt_col ) # set plot limits ax1 . set_xlim ([ self . axis_limit . start_line , self . axis_limit . end_line ]) ax1 . set_ylim ([ self . axis_limit . price_lower_limit , self . axis_limit . price_upper_limit ]) ax1 . set_xlabel ( xlabel ) ax1 . set_ylabel ( \"Price (USD)\" ) ax1 . set_title ( price_chart_title ) fmt = mdates . DateFormatter ( x_format ) ax1 . xaxis . set_major_formatter ( fmt ) ax1 . grid () # define the pixels of shift for the texts in both x and y axis txt_shift_x , txt_shift_y = np . std ( pdf ) / 2 , np . std ( events ) / 20 #define the shift in dates txt_shift_x_date = datetime . timedelta ( hours = round ( np . std ( pdf ) / 2 )) # Add sub plots self . _add_pdf_panel = True # add other subplots if self . _add_pdf_panel == True : # add APC subplot self . add_pdf_panel ( ax1 , pdf , events , quant_list , quant_price_list ) # Add subcomponents subcomp = SubComponents ( ax1 ) subcomp . _quant_lines = True subcomp . _add_EES_region = False subcomp . _add_EES_range_region = True subcomp . _add_crossover_pts = True subcomp . _add_trade_region = True # add the EES regions if subcomp . _add_EES_region : if direction == \"Buy\" : entry_price = quant_price_list [ 1 ] exit_price = quant_price_list [ 3 ] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = quant_price_list [ 3 ] exit_price = quant_price_list [ 1 ] stop_loss = quant_price_list [ 4 ] elif direction == \"Neutral\" : entry_price = np . nan exit_price = np . nan stop_loss = np . nan subcomp . EES_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) if subcomp . _add_EES_range_region : if direction == \"Buy\" : entry_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] exit_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] exit_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] stop_loss = quant_price_list [ 6 ] elif direction == \"Neutral\" : entry_price = [ np . nan , np . nan ] exit_price = [ np . nan , np . nan ] stop_loss = np . nan subcomp . EES_range_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) # add quantile lines to the plot if subcomp . _quant_lines : subcomp . quant_lines ( quant_list , quant_price_list , txt_shift_x_date , txt_shift_y , start_x = self . axis_limit . start_line , end_x = self . axis_limit . end_line , alpha = 0.5 ) # add cross over points if subcomp . _add_crossover_pts : print ( \"Add crossover points\" ) bppt_x1 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x1 ] bppt_x2 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x2 ] bppt_x3 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x3 ] print ( \"subcomp._add_crossover_pts\" , subcomp . _add_crossover_pts , bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) subcomp . crossover_pts ( bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) if subcomp . _add_trade_region : subcomp . trade_region ( open_hr , close_hr ) # add the buying and selling points #add_buysell_points(ax1, buy_time, buy_price, sell_time, sell_price) plt . show () return self . fig def add_pdf_panel ( self , sharey , pdf , events , quant_list , quant_price_list , title = 'APC' , pt_col = 'orange' ): # define the pixels of shift for the texts in both x and y axis txt_shift_x , txt_shift_y = np . std ( pdf ) / 2 , np . std ( events ) / 20 #define the shift in dates txt_shift_x_date = datetime . timedelta ( hours = round ( np . std ( pdf ) / 2 )) ax_apc = self . fig . add_subplot ( self . gs [ 1 ], sharey = sharey ) ax_apc . plot ( pdf , events , 'o' , c = pt_col , ms = 2 ) SubComponents ( ax_apc ) . quant_lines ( quant_list , quant_price_list , txt_shift_x , txt_shift_y ) ax_apc . set_xlim ([ - 0.005 , max ( pdf ) + np . std ( pdf ) / 4 ]) ax_apc . set_title ( title ) ax_apc . set_xlabel ( \"Probability\" ) ax_apc . invert_xaxis () ax_apc . grid () @property def add_volume_panel ( self ): return None","title":"PlotPricing"},{"location":"EC_tools/plot/#EC_tools.plot.PlotPricing.plot_price","text":"A function that plot the intraday minute pricing chart alongside the APC. Parameters: x ( list ) \u2013 The intraday minutes. y ( list ) \u2013 The price of intraday data. events ( list ) \u2013 The price of the APC. pdf ( list ) \u2013 The probability of the APC's pdf. quant_list ( list ) \u2013 A list of quantile name for text marking on the plot. quant_price_list ( list ) \u2013 The price of the horizontal lines corresponding to quant_list. direction ( str , default: 'Neutral' ) \u2013 Buy\", \"Sell\", or \"Neutral\" signal. price_chart_title ( str , default: 'Date' ) \u2013 The title of the plot. The default is \"Date\". open_hr ( str , default: '0330' ) \u2013 The opening hour of a trade day. The default is 0330 (03:30 at UK time). close_hr ( str , default: '1930' ) \u2013 The closing hour of a trade day. The default is 1900 (07:00 pm). events_lower_limit ( TYPE , default: 70 ) \u2013 The lower bound in y-axis of the plot. The default is 70. events_upper_limit ( TYPE , default: 78 ) \u2013 The upper bound in y-axis of the plot. The default is 78. Returns: fig ( <class 'matplotlib.figure.Figure'> ) \u2013 The figure. Source code in EC_tools/plot.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def plot_price ( self , x , y , events , pdf , quant_list , quant_price_list , direction = \"Neutral\" , price_chart_title = \"Date\" , events_lower_limit = 70 , events_upper_limit = 78 , open_hr = '0330' , close_hr = '1930' , xlabel = \"Time (minutes)\" , x_format = '%H:%M' , bppt_x1 = [], bppt_y1 = [], bppt_x2 = [], bppt_y2 = [], bppt_x3 = [], bppt_y3 = [], date_interest = datetime . datetime . today ()): \"\"\" A function that plot the intraday minute pricing chart alongside the APC. Parameters ---------- x : list The intraday minutes. y : list The price of intraday data. events : list The price of the APC. pdf : list The probability of the APC's pdf. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. direction : str Buy\", \"Sell\", or \"Neutral\" signal. price_chart_title : str, optional The title of the plot. The default is \"Date\". open_hr : str, optional The opening hour of a trade day. The default is 0330 (03:30 at UK time). close_hr : str, optional The closing hour of a trade day. The default is 1900 (07:00 pm). events_lower_limit : TYPE, optional The lower bound in y-axis of the plot. The default is 70. events_upper_limit : TYPE, optional The upper bound in y-axis of the plot. The default is 78. Returns ------- fig : <class 'matplotlib.figure.Figure'> The figure. \"\"\" x_o = XObject ( x ) x_o . x = 'datetime' x_datetime = x_o . x o_hr = XObject ( open_hr ) c_hr = XObject ( close_hr ) o_hr . x = 'datetime' c_hr . x = 'datetime' open_hr = o_hr . x [ 0 ] close_hr = c_hr . x [ 0 ] #buy_time = datetime.time(hour = int(buy_time[-4:-2]), minute = int(buy_time[-2:])) #sell_time = datetime.time(hour = int(sell_time[-4:-2]), minute = int(sell_time[-2:])) EES_txt_start_time = datetime . time ( hour = 20 , minute = 50 ) #buy_time = datetime.datetime.combine(datetime.date.today(), buy_time) #sell_time = datetime.datetime.combine(datetime.date.today(), sell_time) EES_txt_start_time = datetime . datetime . combine ( datetime . date . today (), EES_txt_start_time ) # choose the color mode plt . style . use ( 'dark_background' ) pt_col = self . _color_mode [ 'data_col' ] # plotting area #fig = plt.figure(figsize=(10,4)) #gs = fig.add_gridspec(nrows=1, ncols = 2, width_ratios = [4,1]) ax1 = self . fig . add_subplot ( self . gs [ 0 ]) ax1 . plot ( x_datetime , y , 'o--' , ms = 2 , c = pt_col ) # set plot limits ax1 . set_xlim ([ self . axis_limit . start_line , self . axis_limit . end_line ]) ax1 . set_ylim ([ self . axis_limit . price_lower_limit , self . axis_limit . price_upper_limit ]) ax1 . set_xlabel ( xlabel ) ax1 . set_ylabel ( \"Price (USD)\" ) ax1 . set_title ( price_chart_title ) fmt = mdates . DateFormatter ( x_format ) ax1 . xaxis . set_major_formatter ( fmt ) ax1 . grid () # define the pixels of shift for the texts in both x and y axis txt_shift_x , txt_shift_y = np . std ( pdf ) / 2 , np . std ( events ) / 20 #define the shift in dates txt_shift_x_date = datetime . timedelta ( hours = round ( np . std ( pdf ) / 2 )) # Add sub plots self . _add_pdf_panel = True # add other subplots if self . _add_pdf_panel == True : # add APC subplot self . add_pdf_panel ( ax1 , pdf , events , quant_list , quant_price_list ) # Add subcomponents subcomp = SubComponents ( ax1 ) subcomp . _quant_lines = True subcomp . _add_EES_region = False subcomp . _add_EES_range_region = True subcomp . _add_crossover_pts = True subcomp . _add_trade_region = True # add the EES regions if subcomp . _add_EES_region : if direction == \"Buy\" : entry_price = quant_price_list [ 1 ] exit_price = quant_price_list [ 3 ] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = quant_price_list [ 3 ] exit_price = quant_price_list [ 1 ] stop_loss = quant_price_list [ 4 ] elif direction == \"Neutral\" : entry_price = np . nan exit_price = np . nan stop_loss = np . nan subcomp . EES_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) if subcomp . _add_EES_range_region : if direction == \"Buy\" : entry_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] exit_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] stop_loss = quant_price_list [ 0 ] elif direction == \"Sell\" : entry_price = [ quant_price_list [ 4 ], quant_price_list [ 5 ]] exit_price = [ quant_price_list [ 1 ], quant_price_list [ 2 ]] stop_loss = quant_price_list [ 6 ] elif direction == \"Neutral\" : entry_price = [ np . nan , np . nan ] exit_price = [ np . nan , np . nan ] stop_loss = np . nan subcomp . EES_range_region ( entry_price , exit_price , stop_loss , txt_shift_x_date , txt_shift_y , start_x = EES_txt_start_time , end_x = self . axis_limit . end_line , direction = direction ) # add quantile lines to the plot if subcomp . _quant_lines : subcomp . quant_lines ( quant_list , quant_price_list , txt_shift_x_date , txt_shift_y , start_x = self . axis_limit . start_line , end_x = self . axis_limit . end_line , alpha = 0.5 ) # add cross over points if subcomp . _add_crossover_pts : print ( \"Add crossover points\" ) bppt_x1 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x1 ] bppt_x2 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x2 ] bppt_x3 = [ datetime . datetime . combine ( date_interest , t . time ()) for t in bppt_x3 ] print ( \"subcomp._add_crossover_pts\" , subcomp . _add_crossover_pts , bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) subcomp . crossover_pts ( bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) if subcomp . _add_trade_region : subcomp . trade_region ( open_hr , close_hr ) # add the buying and selling points #add_buysell_points(ax1, buy_time, buy_price, sell_time, sell_price) plt . show () return self . fig","title":"plot_price"},{"location":"EC_tools/plot/#EC_tools.plot.SubComponents","text":"Bases: object Source code in EC_tools/plot.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 class SubComponents ( object ): # All subcomponents for Price plotting. This can be inheretance class def __init__ ( self , ax , axis_limit = AxisLimit ()): self . ax = ax # the location that these things should be added self . _quant_lines = False self . _add_EES_region = False self . _add_trade_region = False self . _add_crossover_pts = False self . _add_entry_exit_points = False self . _add_bol_band = False self . _add_fibo_retract_lines = False self . txt_shift_x = None self . txt_shift_y = None self . axis_limit = axis_limit # WIP # super().__init__() def quant_lines ( self , quant_list , quant_price_list , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 100 , alpha = 0.5 ): \"\"\" A function that add the quantile lines to a plot. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. start_x: float, or datetime.time The starting position for the text in x-axis end_x: float, or datetime.time The ending position for the text in x-axis alpha : float, optional The transparency of the quantile line. The default is 0.5. \"\"\" for quant , price in zip ( quant_list , quant_price_list ): self . ax . hlines ( float ( price . iloc [ 0 ]), start_x , end_x , color = '#C26F05' , alpha = alpha ) self . ax . text ( start_x + txt_shift_x , float ( price . iloc [ 0 ]) + txt_shift_y , quant , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#C26F05' )) def EES_region ( self , entry_price , exit_price , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price = float ( entry_price . iloc [ 0 ]) exit_price = float ( exit_price . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price , exit_price , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' )) def EES_range_region ( self , entry_price_range , exit_price_range , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price_lower = float ( entry_price_range [ 0 ] . iloc [ 0 ]) entry_price_upper = float ( entry_price_range [ 1 ] . iloc [ 0 ]) exit_price_lower = float ( exit_price_range [ 0 ] . iloc [ 0 ]) exit_price_upper = float ( exit_price_range [ 1 ] . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( entry_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( exit_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price_lower , entry_price_upper , color = 'green' , alpha = 0.3 ) self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], exit_price_lower , exit_price_upper , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price_upper + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price_upper + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' )) def trade_region ( self , open_hr , close_hr ): # fill the closed trading hours with shade # the vertical lines that self . ax . vlines ( open_hr , 0 , 2000 , 'w' ) self . ax . vlines ( close_hr , 0 , 2000 , 'w' ) self . ax . fill_between ([ self . axis_limit . start_line , open_hr ], 0 , 2000 , color = 'grey' , alpha = 0.3 ) self . ax . fill_between ([ close_hr , self . axis_limit . end_line ], 0 , 2000 , color = 'grey' , alpha = 0.3 ) # the vertical lines that self . ax . vlines ( open_hr , 0 , 2000 , 'k' ) self . ax . vlines ( close_hr , 0 , 2000 , 'k' ) def crossover_pts ( self , bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ): print ( \"crossover_pts\" ) print ( bppt_x1 , bppt_y1 , bppt_x2 , bppt_y2 , bppt_x3 , bppt_y3 ) # crossover points set 1 self . ax . plot ( bppt_x1 , bppt_y1 , 'o' , ms = 10 , c = 'blue' ) self . ax . plot ( bppt_x2 , bppt_y2 , 'o' , ms = 10 , c = 'green' ) self . ax . plot ( bppt_x3 , bppt_y3 , 'o' , ms = 26 , c = 'red' ) def buysellpoints ( self , buy_time = \"1201\" , buy_price = 86.05 , sell_time = \"1900\" , sell_price = 85.70 ): return None","title":"SubComponents"},{"location":"EC_tools/plot/#EC_tools.plot.SubComponents.EES_range_region","text":"A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters: ax ( <class 'matplotlib.axes._axes.Axes'> ) \u2013 The figure. entry_price ( float ) \u2013 entry_price. exit_price ( float ) \u2013 exit_price. stop_loss ( float ) \u2013 stop_loss. txt_shift_x ( float ) \u2013 The shift in x-axis for the text. txt_shift_y ( float ) \u2013 The shift in y-axis for the text. direction ( str , default: 'Neutral' ) \u2013 \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". Source code in EC_tools/plot.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 def EES_range_region ( self , entry_price_range , exit_price_range , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price_lower = float ( entry_price_range [ 0 ] . iloc [ 0 ]) entry_price_upper = float ( entry_price_range [ 1 ] . iloc [ 0 ]) exit_price_lower = float ( exit_price_range [ 0 ] . iloc [ 0 ]) exit_price_upper = float ( exit_price_range [ 1 ] . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( entry_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price_lower , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( exit_price_upper , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price_lower , entry_price_upper , color = 'green' , alpha = 0.3 ) self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], exit_price_lower , exit_price_upper , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price_upper + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price_upper + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' ))","title":"EES_range_region"},{"location":"EC_tools/plot/#EC_tools.plot.SubComponents.EES_region","text":"A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters: ax ( <class 'matplotlib.axes._axes.Axes'> ) \u2013 The figure. entry_price ( float ) \u2013 entry_price. exit_price ( float ) \u2013 exit_price. stop_loss ( float ) \u2013 stop_loss. txt_shift_x ( float ) \u2013 The shift in x-axis for the text. txt_shift_y ( float ) \u2013 The shift in y-axis for the text. direction ( str , default: 'Neutral' ) \u2013 \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". Source code in EC_tools/plot.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 def EES_region ( self , entry_price , exit_price , stop_loss , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 2150 , direction = \"Neutral\" ): \"\"\" A function that add the Entry, Exit, and Stop Loss regions to a plot. It plot only in horizontal line. I will change this to np.arrage later. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. entry_price : float entry_price. exit_price : float exit_price. stop_loss : float stop_loss. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. direction : str, optional \"Buy\", \"Sell\", or \"Neutral\" signal. The default is \"Neutral\". \"\"\" # dashed line is the entry line, solid line is the exit line # dashed red line is the stop loss if direction == \"Buy\" : limit = - 10000 elif direction == \"Sell\" : limit = 10000 elif direction == \"Neutral\" : limit = np . nan entry_price = float ( entry_price . iloc [ 0 ]) exit_price = float ( exit_price . iloc [ 0 ]) stop_loss = float ( stop_loss . iloc [ 0 ]) # The EES lines self . ax . hlines ( entry_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"dashed\" , lw = 2 ) self . ax . hlines ( exit_price , self . axis_limit . start_line , self . axis_limit . end_line , color = '#18833D' , ls = \"solid\" , lw = 2 ) self . ax . hlines ( stop_loss , self . axis_limit . start_line , self . axis_limit . end_line , color = '#E5543D' , ls = \"dashed\" , lw = 2 ) # Green shade is the target region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], entry_price , exit_price , color = 'green' , alpha = 0.3 ) # Red shade is the stop loss region. self . ax . fill_between ([ self . axis_limit . start_line , self . axis_limit . end_line ], stop_loss , limit , color = 'red' , alpha = 0.3 ) # The texts that indicate the regions self . ax . text ( start_x + txt_shift_x , entry_price + txt_shift_y , \"Entry Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) # facecolor='#206829') self . ax . text ( start_x + txt_shift_x , exit_price + txt_shift_y , \"Exit Price\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#206829' )) self . ax . text ( start_x + txt_shift_x , stop_loss + txt_shift_y , \"Stop Loss\" , fontsize = 8 , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#80271B' ))","title":"EES_region"},{"location":"EC_tools/plot/#EC_tools.plot.SubComponents.quant_lines","text":"A function that add the quantile lines to a plot. Parameters: ax ( <class 'matplotlib.axes._axes.Axes'> ) \u2013 The figure. quant_list ( list ) \u2013 A list of quantile name for text marking on the plot. quant_price_list ( list ) \u2013 The price of the horizontal lines corresponding to quant_list. txt_shift_x ( float ) \u2013 The shift in x-axis for the text. txt_shift_y ( float ) \u2013 The shift in y-axis for the text. start_x \u2013 The starting position for the text in x-axis end_x \u2013 The ending position for the text in x-axis alpha ( float , default: 0.5 ) \u2013 The transparency of the quantile line. The default is 0.5. Source code in EC_tools/plot.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def quant_lines ( self , quant_list , quant_price_list , txt_shift_x , txt_shift_y , start_x = 0.0 , end_x = 100 , alpha = 0.5 ): \"\"\" A function that add the quantile lines to a plot. Parameters ---------- ax : <class 'matplotlib.axes._axes.Axes'> The figure. quant_list : list A list of quantile name for text marking on the plot. quant_price_list : list The price of the horizontal lines corresponding to quant_list. txt_shift_x : float The shift in x-axis for the text. txt_shift_y : float The shift in y-axis for the text. start_x: float, or datetime.time The starting position for the text in x-axis end_x: float, or datetime.time The ending position for the text in x-axis alpha : float, optional The transparency of the quantile line. The default is 0.5. \"\"\" for quant , price in zip ( quant_list , quant_price_list ): self . ax . hlines ( float ( price . iloc [ 0 ]), start_x , end_x , color = '#C26F05' , alpha = alpha ) self . ax . text ( start_x + txt_shift_x , float ( price . iloc [ 0 ]) + txt_shift_y , quant , color = pt_col , bbox = dict ( boxstyle = \"round\" , ec = pt_col , fc = '#C26F05' ))","title":"quant_lines"},{"location":"EC_tools/portfolio/","text":"Portfolio Created on Mon May 6 08:55:17 2024 @author: dexter Portfolio module contains the Portfolio class that manage your transaction record of your cash and asset. Portfolio Bases: object This class manage everything related to the Portfolio. It contains the pool list which contain every transaction operating on this Portfolio. Source code in EC_tools/portfolio.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 class Portfolio ( object ): \"\"\" This class manage everything related to the Portfolio. It contains the pool list which contain every transaction operating on this Portfolio. \"\"\" def __init__ ( self ): self . __pool_asset : list = [] # set pool to be a private attribute self . __pool_datetime : list = [] self . _pool : list = [] self . _pool_window : list = [] self . _position_pool : list = [] self . _position_pool_window : list = [] self . _table : pd . DataFrame = None self . _master_table : pd . DataFrame = None self . _zeropoint : float = 0.0 # The zero point value for the portfolio self . _remainder_limiter : bool = True # Controls the limitation # A dict that contains the remainder for each assets self . _remainder_dict : dict = dict () self . wipe_debt_or_not : bool = False @property def pool_asset ( self ) -> list [ dict ]: \"\"\" A list that contains the the added assets. \"\"\" return self . __pool_asset @property def pool_datetime ( self ) -> list [ datetime . datetime ]: \"\"\" A list that contains the corresponding datetime where asset is added \"\"\" return self . __pool_datetime @property def pool ( self ) -> list [ tuple ]: \"\"\" A pool that contains all the Asset objects. This is the unstructured data containers. Refined method should be operating on the attribute 'table'. This is to also avoid mixing fungible and non-fungible assets. It contains a sequential record of the adding and subtracting assets from the portfolio. It can be used to generate a log of asset movement and a table for viewing its overall values. Note that Asset can have a negative quantity. It means an exit of some asset from the portfolio. To add or subtract asset from the pool, you need to use the add and sub function. \"\"\" self . _pool = list ( zip ( self . __pool_datetime , self . __pool_asset )) return self . _pool @property def pool_df ( self ): \"\"\" A pool in dataframe format for easy query. \"\"\" pool_df = pd . DataFrame ( self . pool , columns = [ 'datetime' , 'asset' ]) return pool_df @property def pool_window ( self ): \"\"\" A pool window given by a specific time intervals. This function initialised the object. Use set_pool_window to set a particular time frame. \"\"\" # self._pool_window = self.pool return self . _pool_window def set_pool_window ( self , start_time : datetime . datetime = datetime . datetime ( 1900 , 1 , 1 ), end_time : datetime . datetime = datetime . datetime ( 2200 , 12 , 31 )) -> None : \"\"\" Setter method for the pool_window object. Parameters ---------- start_time : datetime object, optional The start time . The default is datetime.datetime(1900,1,1). end_time : datetime object, optional The end time. The default is datetime.datetime(2200,12,31). Returns ------- list pool_window list object. \"\"\" # make a list of start_time and end_time # subtract the original datetime with them start_time_delta_array = np . array ([ abs ( pool_dt - start_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) end_time_delta_array = np . array ([ abs ( pool_dt - end_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) # Find the index of the min() time delta # print(min(start_time_delta_list), min(end_time_delta_list)) # print(start_time_delta_list, end_time_delta_list) # define a window of interest amount the pool object start_time_index = np . where ( start_time_delta_array == min ( start_time_delta_array ))[ 0 ][ 0 ] end_time_index = np . where ( end_time_delta_array == min ( end_time_delta_array ))[ 0 ][ - 1 ] self . _pool_window = self . pool [ start_time_index : end_time_index + 1 ] # print(len(self._pool_window), len(self.pool[start_time_index:end_time_index+1])) return self . _pool_window def set_position_pool_window ( self , start_time : datetime . datetime = \\ datetime . datetime ( 1900 , 1 , 1 ), end_time : datetime . datetime = \\ datetime . datetime ( 2200 , 12 , 31 )): position_time_list = [ pos . open_time for pos in self . position_pool ] start_time_delta_list = [ abs ( pool_dt - start_time ) for pool_dt in position_time_list ] end_time_delta_list = [ abs ( pool_dt - end_time ) for pool_dt in position_time_list ] # define a window of interest amount the pool object start_time_index = start_time_delta_list . index ( min ( start_time_delta_list )) end_time_index = end_time_delta_list . index ( min ( end_time_delta_list )) self . _position_pool_window = self . position_pool [ start_time_index : \\ end_time_index + 1 ] return self . _position_pool_window def position_pool_window ( self ): \"\"\" A subset of position pool that is made by the set_position_pool_window method. \"\"\" return self . _position_pool_window @property def position_pool ( self ): \"\"\" The master position pool is a list that contains all the Position objects. This can be used to construct trading records using the PortfolioLog class and its method \"\"\" return self . _position_pool @staticmethod def _make_table ( pool_type : list ) -> pd . DataFrame : \"\"\" A static method that create a datafreame table using either pool_window or pool. This is an internal method to construct the table and master table attributes for the portfolio class. The reason I use the table method is that some obejct stored in the profolio list may contain non standard attributes, like contract expiration date. Parameters ---------- pool_type : pool object (list) The pool object type. It can be either pool_window or pool, corresponding to making table or master_table objects Returns ------- table : dataframe The resulting table. \"\"\" # Find the keys and values for asset within a particular time window # The function operate on the previously defined pool_window values = [ list ( pool_type [ i ][ 1 ] . values ()) for i in range ( len ( pool_type ))] keys = [ list ( pool_type [ i ][ 1 ] . keys ()) for i in range ( len ( pool_type ))][ 0 ] # Load the inforamtion to self._table table = pd . DataFrame . from_records ( data = values , columns = keys ) #print('tabletable', table) for index , ( val_name , misc ) in enumerate ( zip ( table [ 'name' ], table [ 'misc' ])): # add more conditions with unit and type temp_df = table [( table [ 'name' ] == val_name ) & ( table [ 'misc' ] == misc )] # If the asset is unique in the pool, pass. if len ( temp_df ) == 1 : pass # If the asset is not unique, perform the condesation action elif len ( temp_df ) > 1 : # print(list(temp_df['quantity']), sum(list(temp_df['quantity']))) # the summed quantity new_quantity = sum ( list ( temp_df [ 'quantity' ])) # make new entry_dictionary new_entry_dict = { 'name' : temp_df [ 'name' ] . iloc [ 0 ], 'quantity' : new_quantity , 'unit' : temp_df [ 'unit' ] . iloc [ 0 ], 'asset_type' : temp_df [ 'asset_type' ] . iloc [ 0 ], 'misc' : [ temp_df [ 'misc' ] . iloc [ 0 ]]} new_entry_dict = pd . DataFrame ( new_entry_dict , index = [ len ( table )]) # store them in the lowest row table = pd . concat ([ table , new_entry_dict ], ignore_index = False ) # delete the old entries table . drop ( list ( temp_df . index ), axis = 0 , inplace = True ) # sort the table by 'name' table . sort_values ( by = 'name' ) # reset the indices table . reset_index ( drop = True , inplace = True ) return table @staticmethod def _wipe_debt ( table_type ) -> None : \"\"\" An internal function to wipe the debt in tables if the debt asset has a quantity of 0. Parameters ---------- table_type : TYPE The type of tables, it can be either self.table or self.master_table. Returns ------- DataFrame new_table. \"\"\" index_list = [] # This assume misc contains a set. We may need to change this into dict later for i in range ( len ( table_type )): if table_type [ 'quantity' ] . iloc [ i ] == 0 and \\ 'debt' in table_type [ 'misc' ] . iloc [ i ]: index_list . append ( i ) new_table = table_type . drop ( index_list ) new_table . reset_index ( drop = True ) return new_table @property def table ( self ) -> pd . DataFrame : # tested \"\"\" An attribute that show a table of all the assets in the portfolio. The table operates on pool_window, meaning it obly shows the assets listed in the pool_window list. Please make sure you are setting the time window correctly. \"\"\" if self . _pool_window == None : raise Exception ( \"pool_window not found. Use either master_table or \\ define a pool_window for viewing first\" ) self . _table = self . _make_table ( self . pool_window ) if self . wipe_debt_or_not == True : self . _table = self . _wipe_debt ( self . _table ) self . _table . reset_index ( drop = True ) return self . _table @property def master_table ( self ) -> pd . DataFrame : # tested \"\"\" An attribute that show a table of all the assets in the portfolio. The table operates on pool, meaning it obly shows the assets listed in the pool list, i.e., it shows assets across all time. \"\"\" self . _master_table = self . _make_table ( self . pool ) if self . wipe_debt_or_not == True : self . _master_table = self . _wipe_debt ( self . _master_table ) self . _master_table . reset_index ( drop = True ) return self . _master_table def _add_to_remainder_dict ( self , asset_name : str , asset_quantity : int | float ) -> None : \"\"\" An internal method to add to the reaminder_dict every time there is a 'add' or 'sub' action operating on the pool attributes. Parameters ---------- asset_name : str The name of the asset. asset_quantity : int or float The quantity of the asset. Returns ------- None. \"\"\" # Add a new entry in the remainder_dict if the asset does not exist in # the Portfolio if asset_name not in self . _remainder_dict : self . _remainder_dict [ asset_name ] = asset_quantity # If it is already there, add the quantity. else : new_quantity = asset_quantity self . _remainder_dict [ asset_name ] = self . _remainder_dict [ asset_name ] + \\ new_quantity def check_remainder ( self , asset_name : str , quantity : int | float ) -> bool : \"\"\" A function that check the remainder if there are enough asset of a particular name in the portfolio. Parameters ---------- asset_name : str The name of the asset. asset_quantity : int or float The quantity of the asset. Returns ------- bool: whether it has more cash or asset than the zeropoint \"\"\" baseline = self . _remainder_dict [ asset_name ] - self . _zeropoint return baseline < quantity @property def remainder_dict ( self ) -> dict : \"\"\" It contains a dictionary of how much remainder of each asset is remained in the portfolio, essentially a counter for the ease of calculation. Returns ------- dict remainder_dict. \"\"\" return self . _remainder_dict def add ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . now (), quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that add a new asset to the pool. Parameters ---------- asset : str, Asset Object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # asset cannot be a list # check if it asset is an asset format if type ( asset ) == Asset : asset_name = asset . name elif type ( asset ) == str : # # search the dictionary to see what kind of asset is this # (potential improvement) # make a new asset # asset = Asset(asset, quantity, unit, asset_type) asset = { 'name' : asset , 'quantity' : quantity , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] elif type ( asset ) == dict : asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] # Add the asset into the pool self . __pool_asset . append ( asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity ) def sub ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . today (), asset_name : str = \"\" , quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that subtract an existing asset from the pool. Parameters ---------- asset : str, Asset object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # check if it asset is an asset format if type ( asset ) == dict : # call the quantity from table asset_name = asset [ 'name' ] # check if the total amount is higher than the subtraction amount if self . _remainder_limiter : if self . check_remainder ( asset_name , asset [ 'quantity' ]): raise Exception ( 'There is not enough {} to be subtracted \\ from the portfolio.' . format ( asset_name )) quantity = asset [ 'quantity' ] unit = asset [ 'unit' ] asset_type = asset [ 'asset_type' ] if type ( asset ) == str : # # search the dictionary to see what kind of asset is this # make a new asset asset_name = asset # make a new asset with a minus value for quantity new_asset = { 'name' : asset_name , 'quantity' : quantity *- 1 , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_quantity = new_asset [ 'quantity' ] #print('sub','new_asset', new_asset) self . __pool_asset . append ( new_asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity ) def value ( self , date_time : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' , price_proxy : str = \"Settle\" , time_proxy : str = 'Date' ): # WIP \"\"\" A function that return a dict with the price for each assets on a particular date and time. Parameters ---------- datetime: datetime object The datetime for query. price_dict: dict A dictionary that contains the pricing data filename for each assets. The default is PRICE_DICT. size_dict: dict A dictionary that contains the size (for example, number of barrels) contained in each assets. The default is SIZE_DICT. dntr: str The denomanator currency for calculating the value of each asset. The default is USD'. Returns ------_ value_dict: dict A dictionary for the value of each assets for that time. \"\"\" # Set a pool window for intrest self . set_pool_window ( self . __pool_datetime [ 0 ], date_time ) # Initialise dict, find unique asset_name unique_name_list = list ( set ([ asset [ 'name' ] for asset in self . __pool_asset ])) quantity_dict = { unique_name : 0 for unique_name in unique_name_list } # loop and get the quantity of each assets for i , ( _ , asset ) in enumerate ( self . pool_window ): quantity_dict [ asset [ 'name' ]] = quantity_dict [ asset [ 'name' ]] + \\ asset [ 'quantity' ] value_dict = dict () for i , ( dt , asset ) in enumerate ( self . pool_window ): if asset [ 'name' ] == dntr : value_dict [ dntr ] = quantity_dict [ dntr ] else : if size_dict == None : # manage the size of the asset size = 1 else : # Get the size of each asset size = size_dict [ asset [ 'name' ]] sub_price_table = price_dict [ asset [ 'name' ]] target_time = date_time . strftime ( \"%Y-%m- %d \" ) # print('price:', sub_price_table[price_proxy][sub_price_table[time_proxy] == \\ # target_time]) # query search for the price of an asset of the date of interest price = sub_price_table [ price_proxy ][ sub_price_table [ time_proxy ] == target_time ] . item () quantity = quantity_dict [ asset [ 'name' ]] value_dict [ asset [ 'name' ]] = float ( price ) * quantity * size return value_dict def asset_value ( self , asset_name : str , datetime : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' ) -> float : \"\"\" A function that return a dict with of a particular asset on a particular date and time. Parameters ---------- asset_name : str The name of the asset. datetime : datetime object The date and time of interest. Returns ------- asset_value : float the asset value. \"\"\" asset_value = self . value ( datetime , price_dict = price_dict , size_dict = size_dict , dntr = dntr )[ asset_name ] return asset_value def total_value ( self , datetime : datetime . datetime , dntr : str = 'USD' ) -> float : \"\"\" A function that return the total value of the entire portfolio on a particular date and time. Parameters ---------- datetime : datetime object The date and time of interest. Returns ------- total_value : float the total value. \"\"\" total_value = sum ( self . value ( datetime , dntr = dntr ) . values ()) return total_value master_table : pd . DataFrame property An attribute that show a table of all the assets in the portfolio. The table operates on pool, meaning it obly shows the assets listed in the pool list, i.e., it shows assets across all time. pool : list [ tuple ] property A pool that contains all the Asset objects. This is the unstructured data containers. Refined method should be operating on the attribute 'table'. This is to also avoid mixing fungible and non-fungible assets. It contains a sequential record of the adding and subtracting assets from the portfolio. It can be used to generate a log of asset movement and a table for viewing its overall values. Note that Asset can have a negative quantity. It means an exit of some asset from the portfolio. To add or subtract asset from the pool, you need to use the add and sub function. pool_asset : list [ dict ] property A list that contains the the added assets. pool_datetime : list [ datetime . datetime ] property A list that contains the corresponding datetime where asset is added pool_df property A pool in dataframe format for easy query. pool_window property A pool window given by a specific time intervals. This function initialised the object. Use set_pool_window to set a particular time frame. position_pool property The master position pool is a list that contains all the Position objects. This can be used to construct trading records using the PortfolioLog class and its method remainder_dict : dict property It contains a dictionary of how much remainder of each asset is remained in the portfolio, essentially a counter for the ease of calculation. Returns: dict \u2013 remainder_dict. table : pd . DataFrame property An attribute that show a table of all the assets in the portfolio. The table operates on pool_window, meaning it obly shows the assets listed in the pool_window list. Please make sure you are setting the time window correctly. add ( asset , datetime = datetime . datetime . now (), quantity = 0 , unit = 'contract' , asset_type = 'future' ) A function that add a new asset to the pool. Parameters: asset ( str, Asset Object, list ) \u2013 The asset to be added. datetime ( datetime , default: now () ) \u2013 The datetime that the asset is added quantity ( int | float , default: 0 ) \u2013 The number of the same asset added. The default is 0. unit ( str , default: 'contract' ) \u2013 The unit name of the asset. The default is 'contract'. asset_type ( str , default: 'future' ) \u2013 The type name of the asset. The default is 'future'. Returns: None. \u2013 Source code in EC_tools/portfolio.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def add ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . now (), quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that add a new asset to the pool. Parameters ---------- asset : str, Asset Object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # asset cannot be a list # check if it asset is an asset format if type ( asset ) == Asset : asset_name = asset . name elif type ( asset ) == str : # # search the dictionary to see what kind of asset is this # (potential improvement) # make a new asset # asset = Asset(asset, quantity, unit, asset_type) asset = { 'name' : asset , 'quantity' : quantity , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] elif type ( asset ) == dict : asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] # Add the asset into the pool self . __pool_asset . append ( asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity ) asset_value ( asset_name , datetime , price_dict = PRICE_DICT , size_dict = SIZE_DICT , dntr = 'USD' ) A function that return a dict with of a particular asset on a particular date and time. Parameters: asset_name ( str ) \u2013 The name of the asset. datetime ( datetime object ) \u2013 The date and time of interest. Returns: asset_value ( float ) \u2013 the asset value. Source code in EC_tools/portfolio.py 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def asset_value ( self , asset_name : str , datetime : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' ) -> float : \"\"\" A function that return a dict with of a particular asset on a particular date and time. Parameters ---------- asset_name : str The name of the asset. datetime : datetime object The date and time of interest. Returns ------- asset_value : float the asset value. \"\"\" asset_value = self . value ( datetime , price_dict = price_dict , size_dict = size_dict , dntr = dntr )[ asset_name ] return asset_value check_remainder ( asset_name , quantity ) A function that check the remainder if there are enough asset of a particular name in the portfolio. Parameters: asset_name ( str ) \u2013 The name of the asset. asset_quantity ( int or float ) \u2013 The quantity of the asset. Returns: bool ( whether it has more cash or asset than the zeropoint ) \u2013 Source code in EC_tools/portfolio.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def check_remainder ( self , asset_name : str , quantity : int | float ) -> bool : \"\"\" A function that check the remainder if there are enough asset of a particular name in the portfolio. Parameters ---------- asset_name : str The name of the asset. asset_quantity : int or float The quantity of the asset. Returns ------- bool: whether it has more cash or asset than the zeropoint \"\"\" baseline = self . _remainder_dict [ asset_name ] - self . _zeropoint return baseline < quantity position_pool_window () A subset of position pool that is made by the set_position_pool_window method. Source code in EC_tools/portfolio.py 191 192 193 194 195 196 197 def position_pool_window ( self ): \"\"\" A subset of position pool that is made by the set_position_pool_window method. \"\"\" return self . _position_pool_window set_pool_window ( start_time = datetime . datetime ( 1900 , 1 , 1 ), end_time = datetime . datetime ( 2200 , 12 , 31 )) Setter method for the pool_window object. Parameters: start_time ( datetime object , default: datetime (1900, 1, 1) ) \u2013 The start time . The default is datetime.datetime(1900,1,1). end_time ( datetime object , default: datetime (2200, 12, 31) ) \u2013 The end time. The default is datetime.datetime(2200,12,31). Returns: list \u2013 pool_window list object. Source code in EC_tools/portfolio.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def set_pool_window ( self , start_time : datetime . datetime = datetime . datetime ( 1900 , 1 , 1 ), end_time : datetime . datetime = datetime . datetime ( 2200 , 12 , 31 )) -> None : \"\"\" Setter method for the pool_window object. Parameters ---------- start_time : datetime object, optional The start time . The default is datetime.datetime(1900,1,1). end_time : datetime object, optional The end time. The default is datetime.datetime(2200,12,31). Returns ------- list pool_window list object. \"\"\" # make a list of start_time and end_time # subtract the original datetime with them start_time_delta_array = np . array ([ abs ( pool_dt - start_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) end_time_delta_array = np . array ([ abs ( pool_dt - end_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) # Find the index of the min() time delta # print(min(start_time_delta_list), min(end_time_delta_list)) # print(start_time_delta_list, end_time_delta_list) # define a window of interest amount the pool object start_time_index = np . where ( start_time_delta_array == min ( start_time_delta_array ))[ 0 ][ 0 ] end_time_index = np . where ( end_time_delta_array == min ( end_time_delta_array ))[ 0 ][ - 1 ] self . _pool_window = self . pool [ start_time_index : end_time_index + 1 ] # print(len(self._pool_window), len(self.pool[start_time_index:end_time_index+1])) return self . _pool_window sub ( asset , datetime = datetime . datetime . today (), asset_name = '' , quantity = 0 , unit = 'contract' , asset_type = 'future' ) A function that subtract an existing asset from the pool. Parameters: asset ( str, Asset object, list ) \u2013 The asset to be added. datetime ( datetime , default: today () ) \u2013 The datetime that the asset is added quantity ( int | float , default: 0 ) \u2013 The number of the same asset added. The default is 0. unit ( str , default: 'contract' ) \u2013 The unit name of the asset. The default is 'contract'. asset_type ( str , default: 'future' ) \u2013 The type name of the asset. The default is 'future'. Returns: None. \u2013 Source code in EC_tools/portfolio.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 def sub ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . today (), asset_name : str = \"\" , quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that subtract an existing asset from the pool. Parameters ---------- asset : str, Asset object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # check if it asset is an asset format if type ( asset ) == dict : # call the quantity from table asset_name = asset [ 'name' ] # check if the total amount is higher than the subtraction amount if self . _remainder_limiter : if self . check_remainder ( asset_name , asset [ 'quantity' ]): raise Exception ( 'There is not enough {} to be subtracted \\ from the portfolio.' . format ( asset_name )) quantity = asset [ 'quantity' ] unit = asset [ 'unit' ] asset_type = asset [ 'asset_type' ] if type ( asset ) == str : # # search the dictionary to see what kind of asset is this # make a new asset asset_name = asset # make a new asset with a minus value for quantity new_asset = { 'name' : asset_name , 'quantity' : quantity *- 1 , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_quantity = new_asset [ 'quantity' ] #print('sub','new_asset', new_asset) self . __pool_asset . append ( new_asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity ) total_value ( datetime , dntr = 'USD' ) A function that return the total value of the entire portfolio on a particular date and time. Parameters: datetime ( datetime object ) \u2013 The date and time of interest. Returns: total_value ( float ) \u2013 the total value. Source code in EC_tools/portfolio.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 def total_value ( self , datetime : datetime . datetime , dntr : str = 'USD' ) -> float : \"\"\" A function that return the total value of the entire portfolio on a particular date and time. Parameters ---------- datetime : datetime object The date and time of interest. Returns ------- total_value : float the total value. \"\"\" total_value = sum ( self . value ( datetime , dntr = dntr ) . values ()) return total_value value ( date_time , price_dict = PRICE_DICT , size_dict = SIZE_DICT , dntr = 'USD' , price_proxy = 'Settle' , time_proxy = 'Date' ) A function that return a dict with the price for each assets on a particular date and time. Parameters: datetime \u2013 The datetime for query. price_dict ( dict , default: PRICE_DICT ) \u2013 A dictionary that contains the pricing data filename for each assets. The default is PRICE_DICT. size_dict ( dict , default: SIZE_DICT ) \u2013 A dictionary that contains the size (for example, number of barrels) contained in each assets. The default is SIZE_DICT. dntr ( str , default: 'USD' ) \u2013 The denomanator currency for calculating the value of each asset. The default is USD'. Returns \u2013 value_dict \u2013 A dictionary for the value of each assets for that time. Source code in EC_tools/portfolio.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def value ( self , date_time : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' , price_proxy : str = \"Settle\" , time_proxy : str = 'Date' ): # WIP \"\"\" A function that return a dict with the price for each assets on a particular date and time. Parameters ---------- datetime: datetime object The datetime for query. price_dict: dict A dictionary that contains the pricing data filename for each assets. The default is PRICE_DICT. size_dict: dict A dictionary that contains the size (for example, number of barrels) contained in each assets. The default is SIZE_DICT. dntr: str The denomanator currency for calculating the value of each asset. The default is USD'. Returns ------_ value_dict: dict A dictionary for the value of each assets for that time. \"\"\" # Set a pool window for intrest self . set_pool_window ( self . __pool_datetime [ 0 ], date_time ) # Initialise dict, find unique asset_name unique_name_list = list ( set ([ asset [ 'name' ] for asset in self . __pool_asset ])) quantity_dict = { unique_name : 0 for unique_name in unique_name_list } # loop and get the quantity of each assets for i , ( _ , asset ) in enumerate ( self . pool_window ): quantity_dict [ asset [ 'name' ]] = quantity_dict [ asset [ 'name' ]] + \\ asset [ 'quantity' ] value_dict = dict () for i , ( dt , asset ) in enumerate ( self . pool_window ): if asset [ 'name' ] == dntr : value_dict [ dntr ] = quantity_dict [ dntr ] else : if size_dict == None : # manage the size of the asset size = 1 else : # Get the size of each asset size = size_dict [ asset [ 'name' ]] sub_price_table = price_dict [ asset [ 'name' ]] target_time = date_time . strftime ( \"%Y-%m- %d \" ) # print('price:', sub_price_table[price_proxy][sub_price_table[time_proxy] == \\ # target_time]) # query search for the price of an asset of the date of interest price = sub_price_table [ price_proxy ][ sub_price_table [ time_proxy ] == target_time ] . item () quantity = quantity_dict [ asset [ 'name' ]] value_dict [ asset [ 'name' ]] = float ( price ) * quantity * size return value_dict PortfolioLog dataclass Bases: Portfolio A class that produce A full transaction Log for the Portfolio. Note that this method generates a log that contains the changes in Portfolio values. The key differences between PortfolioLog and Portfolio is that the former handles the prices for assets at a given time and the trading records of the Porfolio while later only handles what is contained in the Portfolio. Source code in EC_tools/portfolio.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 @dataclass class PortfolioLog ( Portfolio ): \"\"\" A class that produce A full transaction Log for the Portfolio. Note that this method generates a log that contains the changes in Portfolio values. The key differences between PortfolioLog and Portfolio is that the former handles the prices for assets at a given time and the trading records of the Porfolio while later only handles what is contained in the Portfolio. \"\"\" portfolio : Portfolio = None _log : pd . DataFrame = None tradebook_filename = str = \"\" @util . time_it def _make_log ( self , simple_log = False ): # Decrepated time complexity too large \"\"\" An internal method to construct logs for the portfolio. \"\"\" log = list () print ( \"Generating Portfolio Log...\" ) if simple_log : # simple_log make a log with only the inforamtion at the start of the day temp = [ datetime . datetime . combine ( dt . date (), datetime . time ( 0 , 0 )) for dt in self . portfolio . pool_datetime ] # reorganised the time_list because set() function scramble the order # Use the set function to output a unique datetime list time_list = sorted ( list ( set ( temp ))) # Add an extra day to see what is the earning for the last day # time_list = time_list + \\ # [time_list[-1]+datetime.timedelta(days=1)] else : time_list = self . portfolio . pool_datetime # print(time_list) # Add an entry at the end of the day to see what is the earning for the last day last_dt = datetime . datetime . combine ( time_list [ - 1 ] . date (), datetime . time ( 23 , 59 )) time_list = time_list + [ last_dt ] # then loop through the pool history and store them in log list for item in time_list : #print('time', item) value_entry = self . portfolio . value ( item ) value_entry [ \"Total\" ] = sum ( list ( value_entry . values ())) value_entry [ 'Datetime' ] = item print ( 'VE' , item , value_entry ) log . append ( value_entry ) # return a log of the values of each asset by time self . _log = pd . DataFrame ( log ) # reorganise columns order asset_name_list = list ( self . portfolio . value ( self . portfolio . pool_datetime [ - 1 ]) . keys ()) self . _log = self . _log [[ 'Datetime' , 'Total' ] + asset_name_list ] print ( \"Log is avalibale.\" ) self . _log . sort_values ( by = \"Datetime\" , inplace = True , ignore_index = True ) return self . _log @property def log ( self ) -> pd . DataFrame : \"\"\" A simple log that only shows the Portfolio's value at 00:00:00 of the day. Returns ------- DataFrame Simple Log. \"\"\" return self . _make_log ( simple_log = True ) @property def full_log ( self ) -> pd . DataFrame : \"\"\" A full log that only shows every entry in the changes in the Portfolio's value. Returns ------- DataFrame Full Log. \"\"\" return self . _make_log ( simple_log = False ) def asset_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . log [ asset_name ] return asset_log def asset_full_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . full_log [ asset_name ] return asset_log def render_tradebook ( self , save_or_not : bool = True ): custom_list0 = [ 'Trade_ID' , 'Direction' , 'Commodity' , 'Price_Code' , 'Entry_Date' , 'Entry_Datetime' , 'Entry_Price' , 'Exit_Date' , 'Exit_Datetime' , 'Exit_Price' , 'Trade_Return' , 'Trade_Return_Fraction' ] position_pool = self . portfolio . position_pool book = Bookkeep ( bucket_type = 'backtest' , custom_keywords_list = custom_list0 ) #, 'Scaled_Return'] # , 'Risk_Reward_Ratio', 'strategy_name'] trade_PNL = book . make_bucket () def select_func_fill ( x ): return position_pool [ x ] . status . value == 'Filled' PP = read . group_trade ( position_pool , select_func = select_func_fill ) #print(PP[0:2]) for i , ele in enumerate ( PP ): #print(i) trade_id = ele [ 0 ] . pos_id direction = re . sub ( r '\\-(.*)' , '' , ele [ 0 ] . pos_type ) symbol = ele [ 0 ] . get_obj [ 'name' ] commodity_name = SYMBOL_KEYWORDS_DICT [ symbol ] entry_date = ele [ 0 ] . fill_time . date () entry_datetime = ele [ 0 ] . fill_time entry_price = ele [ 0 ] . price exit_date = ele [ 1 ] . fill_time . date () exit_datetime = ele [ 1 ] . fill_time exit_price = ele [ 1 ] . price if direction == \"Long\" : trade_return = exit_price - entry_price trade_return_fraction = ( exit_price - entry_price ) / entry_price #scaled_return = 000 elif direction == \"Short\" : trade_return = entry_price - exit_price trade_return_fraction = ( entry_price - exit_price ) / exit_price data = [ trade_id , direction , commodity_name , symbol , entry_date , entry_datetime , entry_price , exit_date , exit_datetime , exit_price , trade_return , trade_return_fraction ] trade_PNL = book . store_to_bucket_single ( data ) trade_PNL = pd . DataFrame ( trade_PNL ) trade_PNL = trade_PNL . sort_values ( by = 'Trade_ID' ) # sort by ID if save_or_not : trade_PNL . to_csv ( self . tradebook_filename , index = False ) return trade_PNL def render_tradebook_xlsx ( self ): tradebook_xlsx = read . render_PNL_xlsx ([ self . tradebook_filename ], return_proxy = 'Trade_Return' ) return tradebook_xlsx @property def tradebook ( self ) -> pd . DataFrame : \"\"\" The tradebook made using the position pool. Returns ------- DataFrame Tradebook. \"\"\" return self . render_tradebook ( save_or_not = False ) def full_tradebook ( self ) -> pd . DataFrame : return self . render_tradebook ( save_or_not = False ) def add_column ( self ): pass full_log : pd . DataFrame property A full log that only shows every entry in the changes in the Portfolio's value. Returns: DataFrame \u2013 Full Log. log : pd . DataFrame property A simple log that only shows the Portfolio's value at 00:00:00 of the day. Returns: DataFrame \u2013 Simple Log. tradebook : pd . DataFrame property The tradebook made using the position pool. Returns: DataFrame \u2013 Tradebook. asset_full_log ( asset_name ) The log of the changes in values for a particular assets across all time. Source code in EC_tools/portfolio.py 753 754 755 756 757 758 759 760 def asset_full_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . full_log [ asset_name ] return asset_log asset_log ( asset_name ) The log of the changes in values for a particular assets across all time. Source code in EC_tools/portfolio.py 744 745 746 747 748 749 750 751 def asset_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . log [ asset_name ] return asset_log PortfolioMetrics dataclass Bases: Portfolio A class that generate all Portfolio metrics. Generally, the Portfolio Metrics method returns a tuple of (value, unit, metric_name). Source code in EC_tools/portfolio.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 @dataclass class PortfolioMetrics ( Portfolio ): \"\"\" A class that generate all Portfolio metrics. Generally, the Portfolio Metrics method returns a tuple of (value, unit, metric_name). \"\"\" _portfolio : Portfolio def __post_init__ ( self ): self . portfolio_log = PortfolioLog ( self . _portfolio ) self . tradebook = self . portfolio_log . tradebook def _load_filled_position_pool ( self ) -> list : \"\"\" A function to load only the filled position to a list Returns ------- list Filled position list \"\"\" position_pool = self . _portfolio . position_pool def select_func_fill ( x ): return position_pool [ x ] . status . value == 'Filled' PP = read . group_trade ( position_pool , select_func = select_func_fill ) return PP def start_capital ( self , dntr : str = 'USD' , cash_only : bool = False ) -> tuple [ float , str , str ]: first_date = self . _portfolio . pool_datetime [ 0 ] if not cash_only : first_entry_total_value = self . _portfolio . total_value ( first_date , dntr = dntr ) return first_entry_total_value , dntr , 'Starting Capital' def end_capital ( self , dntr : str = 'USD' , cash_only : bool = False ) -> tuple [ float , str , str ]: last_date = self . _portfolio . pool_datetime [ - 1 ] if not cash_only : last_entry_total_value = self . _portfolio . total_value ( last_date , dntr = dntr ) return last_entry_total_value , dntr , \"Final Capital\" def period ( self , time_proxy : str = 'Exit_Date' , unit : str = \"Days\" ) -> tuple [ int , str , str ]: \"\"\" Total Days of trading Parameters ---------- time_proxy : str, optional Column name for the time. The default is 'Exit_Date'. unit : str, optional Unit. The default is \"Days\". \"\"\" period = self . tradebook [ time_proxy ] . iloc [ - 1 ] - self . tradebook [ time_proxy ] . iloc [ 0 ] return period , unit , \"Period\" def total_trades ( self ) -> tuple [ int , str , str ]: \"\"\" The total number of trades in the tradebook. \"\"\" return len ( self . tradebook ), '#' , \"Total Trades\" def total_fee_paid ( self ) -> float : # WIP position_pool = self . _portfolio . position_pool def select_func_fill ( x ): return position_pool [ x ] . status . value == 'Filled' PP = read . group_trade ( position_pool , select_func = select_func_fill ) total_fee_dict = dict () total_fee = 0 for ele in PP : # Assuming the second item in each element contains the fee total_fee = total_fee + ele [ 1 ] . fee [ 'quantity' ] return total_fee , '' , 'Total Fee Paid' def total_returns ( self , dntr = 'USD' ) -> tuple [ float , str ]: \"\"\" The total returns given a currency denomanator Parameters ---------- dntr : str, optional Currency denomanator. The default is 'USD'. Returns ------- tuple[float,str,str] total returns, unit, metric name. \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date , dntr = dntr ) last_entry_total_value = self . _portfolio . total_value ( last_date , dntr = dntr ) return ( last_entry_total_value - first_entry_total_value ), dntr , \\ \"Total Returns\" def total_returns_fraction ( self , unit : str = '%' ) -> tuple [ float , str , str ]: \"\"\" The total returns by fraction (percentage). Parameters ---------- unit : str, optional Percentage. The default is '%'. Returns ------- tuple[float,str] total return \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date ) last_entry_total_value = self . _portfolio . total_value ( last_date ) #print(first_entry_total_value, last_entry_total_value) return 100 * ( last_entry_total_value - first_entry_total_value ) / \\ first_entry_total_value , unit , \"Total Returns\" def win_rate ( self , return_proxy : str = \"Trade_Return\" , unit : str = \"%\" ) -> \\ tuple [ float , str , str ]: \"\"\" The win rate by percentage. Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". unit : str, optional The Unit percentage. The default is \"%\". Returns ------- tuple[float,str] Win Rate. \"\"\" win_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) return ( win_trades / ( win_trades + lose_trades )) * 100 , unit , \"Win Rate\" def profit_factor ( self , return_proxy : str = \"Trade_Return\" ) -> \\ tuple [ float , str , str ]: \"\"\" The Profit factor (Money Won /Money Lose) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". Returns ------- float The profit factor. \"\"\" win_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) # print(win_trades_val, lose_trades_val) return abs ( win_trades_val ) / abs ( lose_trades_val ), '' , 'Profit Factor' def total_open_positions ( self ) -> tuple [ int , str , str ]: #WIP position_pool = self . _portfolio . position_pool trade_pool = read . group_trade ( position_pool ) total_open_pos = sum ( 1 for pos in trade_pool if pos [ 0 ] . status . value == 'Filled' and pos [ 1 ] . status . value == 'Pending' and pos [ 2 ] . status . value == 'Pending' and pos [ 3 ] . status . value == 'Pending' ) return total_open_pos , '#' , 'Total Open Positions' def total_close_positions ( self ): position_pool = self . _portfolio . position_pool # Group the trades by ID and Filled status trade_pool = read . group_trade ( position_pool , select_func = lambda x : position_pool [ x ] . status . value == 'Filled' ) total_open_pos = sum ( 1 for pos in trade_pool if len ( pos ) == 2 ) return total_open_pos , '#' , 'Total Close Positions' def avg_trade_return ( self , return_proxy : str = \"Trade_Return\" , unit : str = 'USD' ) -> tuple [ str , str ]: \"\"\" A method that calculate average trade return Parameters ---------- return_proxy : str, optional DESCRIPTION. The default is \"Trade_Return\". unit : str, optional The unit relies on user-input. The default is 'USD'. Returns ------- tuple[str,str] The average trade return and the currency unit. \"\"\" filled_pos_list = self . _load_filled_position_pool () trade_return = np . array ([ trade for trade in self . tradebook [ return_proxy ] . to_list ()]) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity return np . average ( daily_return_amount ), unit , 'Average Trade Return' #def _daily_exposure(self): # return def sharpe_ratio ( self , return_proxy : str = \"Trade_Return\" , riskfree_rate : float | list = 0.05 ) -> float : \"\"\" The Sharpe Ratio (S). S = E(R_p - R_f)/std(S_p) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". riskfree_rate : float | list, optional The proxy for risk-free rate. The default is 0.05. Assuming 5 % yield in 5-years treasurey bond. Returns ------- float The Sharpe Ratio. \"\"\" #trade_return = self.tradebook[return_proxy].to_numpy() filled_pos_list = self . _load_filled_position_pool () direction = np . array ([ trade for trade in self . tradebook [ \"Direction\" ] . to_list ()]) entry_price = np . array ([ trade for trade in self . tradebook [ \"Entry_Price\" ] . to_list ()]) exit_price = np . array ([ trade for trade in self . tradebook [ \"Exit_Price\" ] . to_list ()]) #print(\"filled_pos_list\", filled_pos_list[0:2]) trade_return = np . array ([ trade for trade in self . tradebook [ \"Trade_Return\" ] . to_list ()]) trade_return_fraction = np . array ([ trade for trade in self . tradebook [ \"Trade_Return_Fraction\" ] . to_list ()]) # trade_open = np.array([trade[0].give_obj['quantity'] for trade in filled_pos_list]) # trade_close = np.array([trade[1].give_obj['quantity'] for trade in filled_pos_list]) # print('trade_open', trade_open, 'trade_close', trade_close) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity cumsum = np . cumsum ( daily_return_amount ) cumsum_growth = ( cumsum [ 1 : - 1 ] - cumsum [ 0 : - 2 ]) / cumsum [ 0 : - 2 ] # ============================================================================= # print('entry_price', entry_price) # print('exit_price', exit_price) # print('trade_return', trade_return) # print(\"trade_return_fraction\", trade_return_fraction) # print('max, min', max(trade_return_fraction), min(trade_return_fraction)) # print('daily_return_amount', daily_return_amount) # print('cumsum', cumsum, len(cumsum)) # print('cumsum_growth', cumsum_growth, len(cumsum_growth)) # print(\"self.total_returns_fraction()[0]*0.01\", self.total_returns_fraction()[0]*0.01) # print('std(cumsum_growth)', np.std(cumsum_growth)) # ============================================================================= # trade_return_fraction = (trade_close-trade_open)/trade_open #print('daily_return_amount', daily_return_amount, trade_close-trade_open) #print('trade_return_fraction', trade_return_fraction) #riskfree_rate = np.repeat(riskfree_rate, len(daily_return_amount)) #sharpe_ratio = (self.total_returns_fraction()[0]*0.01 - riskfree_rate) / \\ # np.std(daily_return_amount) sharpe_ratio = ( self . total_returns_fraction ()[ 0 ] * 0.01 - riskfree_rate ) / \\ np . std ( cumsum_growth ) ** 0.5 return sharpe_ratio , '' , 'Sharpe Ratio' # so far it is the wrong number because the growth of cumsum is corss-asset, # the return should be calculated using per day basis not per trade/ def calmar_ratio ( self ): return def omega_ratio ( self ): return def sortino_ratio ( self ): return @classmethod def make_full_data ( cls ): # Calculate all metrics related to thid portfolio full_data = dict () attr_name = [ value for value in dir ( cls ) if value not in dir ( Portfolio ) and value [ 0 ] != '_' and value [ 0 : 4 ] != 'make' ] attrs = ( getattr ( cls , name ) for name in attr_name ) #methods = filter(inspect.ismethod, attrs) for attr , name in zip ( attrs , attr_name ): print ( attr , name ) #df = method(cls) #full_data[name] = df print ( attr_name , attrs ) #full_data = {name: getattr(cls, name)() for name in attr_name} print ( full_data ) return full_data def make_full_report ( self ): print ( 'Period [ {} ]' . format ( self . period ()[ 1 ]), self . period ()[ 0 ]) print ( \"Initial Capital [ {} ]\" . format ( self . start_capital ()[ 1 ]), self . start_capital ()[ 0 ]) print ( \"Final Capital [ {} ]\" . format ( self . end_capital ()[ 1 ]), self . end_capital ()[ 0 ]) print ( 'Total Trades [ {} ]' . format ( self . total_trades ()[ 1 ]), self . total_trades ()[ 0 ]) print ( 'Total Fee []' , self . total_fee_paid ()) print ( 'Total Returns [ {} ]' . format ( self . total_returns ()[ 1 ]), self . total_returns ()[ 0 ]) print ( 'Total_returns [ {} ]' . format ( self . total_returns_fraction ()[ 1 ]), self . total_returns_fraction ()[ 0 ]) print ( 'win_rate [ {} ]' . format ( self . win_rate ()[ 1 ]), self . win_rate ()[ 0 ]) print ( 'Profit Factor' , self . profit_factor ()) print ( 'Total Open Positions [ {} ]' . format ( self . total_open_positions ()[ 1 ]), self . total_open_positions ()[ 0 ]) print ( 'total Close Positions [ {} ]' . format ( self . total_close_positions ()[ 1 ]), self . total_close_positions ()[ 0 ]) print ( 'Average Trade Return [ {} ]' . format ( self . avg_trade_return ()[ 1 ]), self . avg_trade_return ()[ 0 ]) print ( 'Sharpe Ratio (#sigma not stable)' , self . sharpe_ratio ()[ 0 ]) x = PrettyTable () avg_trade_return ( return_proxy = 'Trade_Return' , unit = 'USD' ) A method that calculate average trade return Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 DESCRIPTION. The default is \"Trade_Return\". unit ( str , default: 'USD' ) \u2013 The unit relies on user-input. The default is 'USD'. Returns: tuple [ str , str ] \u2013 The average trade return and the currency unit. Source code in EC_tools/portfolio.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 def avg_trade_return ( self , return_proxy : str = \"Trade_Return\" , unit : str = 'USD' ) -> tuple [ str , str ]: \"\"\" A method that calculate average trade return Parameters ---------- return_proxy : str, optional DESCRIPTION. The default is \"Trade_Return\". unit : str, optional The unit relies on user-input. The default is 'USD'. Returns ------- tuple[str,str] The average trade return and the currency unit. \"\"\" filled_pos_list = self . _load_filled_position_pool () trade_return = np . array ([ trade for trade in self . tradebook [ return_proxy ] . to_list ()]) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity return np . average ( daily_return_amount ), unit , 'Average Trade Return' period ( time_proxy = 'Exit_Date' , unit = 'Days' ) Total Days of trading Parameters: time_proxy ( str , default: 'Exit_Date' ) \u2013 Column name for the time. The default is 'Exit_Date'. unit ( str , default: 'Days' ) \u2013 Unit. The default is \"Days\". Source code in EC_tools/portfolio.py 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 def period ( self , time_proxy : str = 'Exit_Date' , unit : str = \"Days\" ) -> tuple [ int , str , str ]: \"\"\" Total Days of trading Parameters ---------- time_proxy : str, optional Column name for the time. The default is 'Exit_Date'. unit : str, optional Unit. The default is \"Days\". \"\"\" period = self . tradebook [ time_proxy ] . iloc [ - 1 ] - self . tradebook [ time_proxy ] . iloc [ 0 ] return period , unit , \"Period\" profit_factor ( return_proxy = 'Trade_Return' ) The Profit factor (Money Won /Money Lose) Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 The column name to query in the tradebook. The default is \"Trade_Return\". Returns: float \u2013 The profit factor. Source code in EC_tools/portfolio.py 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def profit_factor ( self , return_proxy : str = \"Trade_Return\" ) -> \\ tuple [ float , str , str ]: \"\"\" The Profit factor (Money Won /Money Lose) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". Returns ------- float The profit factor. \"\"\" win_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) # print(win_trades_val, lose_trades_val) return abs ( win_trades_val ) / abs ( lose_trades_val ), '' , 'Profit Factor' sharpe_ratio ( return_proxy = 'Trade_Return' , riskfree_rate = 0.05 ) The Sharpe Ratio (S). S = E(R_p - R_f)/std(S_p) Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 The column name to query in the tradebook. The default is \"Trade_Return\". riskfree_rate ( float | list , default: 0.05 ) \u2013 The proxy for risk-free rate. The default is 0.05. Assuming 5 % yield in 5-years treasurey bond. Returns: float \u2013 The Sharpe Ratio. Source code in EC_tools/portfolio.py 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 def sharpe_ratio ( self , return_proxy : str = \"Trade_Return\" , riskfree_rate : float | list = 0.05 ) -> float : \"\"\" The Sharpe Ratio (S). S = E(R_p - R_f)/std(S_p) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". riskfree_rate : float | list, optional The proxy for risk-free rate. The default is 0.05. Assuming 5 % yield in 5-years treasurey bond. Returns ------- float The Sharpe Ratio. \"\"\" #trade_return = self.tradebook[return_proxy].to_numpy() filled_pos_list = self . _load_filled_position_pool () direction = np . array ([ trade for trade in self . tradebook [ \"Direction\" ] . to_list ()]) entry_price = np . array ([ trade for trade in self . tradebook [ \"Entry_Price\" ] . to_list ()]) exit_price = np . array ([ trade for trade in self . tradebook [ \"Exit_Price\" ] . to_list ()]) #print(\"filled_pos_list\", filled_pos_list[0:2]) trade_return = np . array ([ trade for trade in self . tradebook [ \"Trade_Return\" ] . to_list ()]) trade_return_fraction = np . array ([ trade for trade in self . tradebook [ \"Trade_Return_Fraction\" ] . to_list ()]) # trade_open = np.array([trade[0].give_obj['quantity'] for trade in filled_pos_list]) # trade_close = np.array([trade[1].give_obj['quantity'] for trade in filled_pos_list]) # print('trade_open', trade_open, 'trade_close', trade_close) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity cumsum = np . cumsum ( daily_return_amount ) cumsum_growth = ( cumsum [ 1 : - 1 ] - cumsum [ 0 : - 2 ]) / cumsum [ 0 : - 2 ] # ============================================================================= # print('entry_price', entry_price) # print('exit_price', exit_price) # print('trade_return', trade_return) # print(\"trade_return_fraction\", trade_return_fraction) # print('max, min', max(trade_return_fraction), min(trade_return_fraction)) # print('daily_return_amount', daily_return_amount) # print('cumsum', cumsum, len(cumsum)) # print('cumsum_growth', cumsum_growth, len(cumsum_growth)) # print(\"self.total_returns_fraction()[0]*0.01\", self.total_returns_fraction()[0]*0.01) # print('std(cumsum_growth)', np.std(cumsum_growth)) # ============================================================================= # trade_return_fraction = (trade_close-trade_open)/trade_open #print('daily_return_amount', daily_return_amount, trade_close-trade_open) #print('trade_return_fraction', trade_return_fraction) #riskfree_rate = np.repeat(riskfree_rate, len(daily_return_amount)) #sharpe_ratio = (self.total_returns_fraction()[0]*0.01 - riskfree_rate) / \\ # np.std(daily_return_amount) sharpe_ratio = ( self . total_returns_fraction ()[ 0 ] * 0.01 - riskfree_rate ) / \\ np . std ( cumsum_growth ) ** 0.5 return sharpe_ratio , '' , 'Sharpe Ratio' total_returns ( dntr = 'USD' ) The total returns given a currency denomanator Parameters: dntr ( str , default: 'USD' ) \u2013 Currency denomanator. The default is 'USD'. Returns: tuple [ float , str , str ] \u2013 total returns, unit, metric name. Source code in EC_tools/portfolio.py 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def total_returns ( self , dntr = 'USD' ) -> tuple [ float , str ]: \"\"\" The total returns given a currency denomanator Parameters ---------- dntr : str, optional Currency denomanator. The default is 'USD'. Returns ------- tuple[float,str,str] total returns, unit, metric name. \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date , dntr = dntr ) last_entry_total_value = self . _portfolio . total_value ( last_date , dntr = dntr ) return ( last_entry_total_value - first_entry_total_value ), dntr , \\ \"Total Returns\" total_returns_fraction ( unit = '%' ) The total returns by fraction (percentage). Parameters: unit ( str , default: '%' ) \u2013 Percentage. The default is '%'. Returns: tuple [ float , str ] \u2013 total return Source code in EC_tools/portfolio.py 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 def total_returns_fraction ( self , unit : str = '%' ) -> tuple [ float , str , str ]: \"\"\" The total returns by fraction (percentage). Parameters ---------- unit : str, optional Percentage. The default is '%'. Returns ------- tuple[float,str] total return \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date ) last_entry_total_value = self . _portfolio . total_value ( last_date ) #print(first_entry_total_value, last_entry_total_value) return 100 * ( last_entry_total_value - first_entry_total_value ) / \\ first_entry_total_value , unit , \"Total Returns\" total_trades () The total number of trades in the tradebook. Source code in EC_tools/portfolio.py 923 924 925 926 927 928 def total_trades ( self ) -> tuple [ int , str , str ]: \"\"\" The total number of trades in the tradebook. \"\"\" return len ( self . tradebook ), '#' , \"Total Trades\" win_rate ( return_proxy = 'Trade_Return' , unit = '%' ) The win rate by percentage. Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 The column name to query in the tradebook. The default is \"Trade_Return\". unit ( str , default: '%' ) \u2013 The Unit percentage. The default is \"%\". Returns: tuple [ float , str ] \u2013 Win Rate. Source code in EC_tools/portfolio.py 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 def win_rate ( self , return_proxy : str = \"Trade_Return\" , unit : str = \"%\" ) -> \\ tuple [ float , str , str ]: \"\"\" The win rate by percentage. Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". unit : str, optional The Unit percentage. The default is \"%\". Returns ------- tuple[float,str] Win Rate. \"\"\" win_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) return ( win_trades / ( win_trades + lose_trades )) * 100 , unit , \"Win Rate\"","title":"portfolio"},{"location":"EC_tools/portfolio/#portfolio","text":"Created on Mon May 6 08:55:17 2024 @author: dexter Portfolio module contains the Portfolio class that manage your transaction record of your cash and asset.","title":"Portfolio"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio","text":"Bases: object This class manage everything related to the Portfolio. It contains the pool list which contain every transaction operating on this Portfolio. Source code in EC_tools/portfolio.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 class Portfolio ( object ): \"\"\" This class manage everything related to the Portfolio. It contains the pool list which contain every transaction operating on this Portfolio. \"\"\" def __init__ ( self ): self . __pool_asset : list = [] # set pool to be a private attribute self . __pool_datetime : list = [] self . _pool : list = [] self . _pool_window : list = [] self . _position_pool : list = [] self . _position_pool_window : list = [] self . _table : pd . DataFrame = None self . _master_table : pd . DataFrame = None self . _zeropoint : float = 0.0 # The zero point value for the portfolio self . _remainder_limiter : bool = True # Controls the limitation # A dict that contains the remainder for each assets self . _remainder_dict : dict = dict () self . wipe_debt_or_not : bool = False @property def pool_asset ( self ) -> list [ dict ]: \"\"\" A list that contains the the added assets. \"\"\" return self . __pool_asset @property def pool_datetime ( self ) -> list [ datetime . datetime ]: \"\"\" A list that contains the corresponding datetime where asset is added \"\"\" return self . __pool_datetime @property def pool ( self ) -> list [ tuple ]: \"\"\" A pool that contains all the Asset objects. This is the unstructured data containers. Refined method should be operating on the attribute 'table'. This is to also avoid mixing fungible and non-fungible assets. It contains a sequential record of the adding and subtracting assets from the portfolio. It can be used to generate a log of asset movement and a table for viewing its overall values. Note that Asset can have a negative quantity. It means an exit of some asset from the portfolio. To add or subtract asset from the pool, you need to use the add and sub function. \"\"\" self . _pool = list ( zip ( self . __pool_datetime , self . __pool_asset )) return self . _pool @property def pool_df ( self ): \"\"\" A pool in dataframe format for easy query. \"\"\" pool_df = pd . DataFrame ( self . pool , columns = [ 'datetime' , 'asset' ]) return pool_df @property def pool_window ( self ): \"\"\" A pool window given by a specific time intervals. This function initialised the object. Use set_pool_window to set a particular time frame. \"\"\" # self._pool_window = self.pool return self . _pool_window def set_pool_window ( self , start_time : datetime . datetime = datetime . datetime ( 1900 , 1 , 1 ), end_time : datetime . datetime = datetime . datetime ( 2200 , 12 , 31 )) -> None : \"\"\" Setter method for the pool_window object. Parameters ---------- start_time : datetime object, optional The start time . The default is datetime.datetime(1900,1,1). end_time : datetime object, optional The end time. The default is datetime.datetime(2200,12,31). Returns ------- list pool_window list object. \"\"\" # make a list of start_time and end_time # subtract the original datetime with them start_time_delta_array = np . array ([ abs ( pool_dt - start_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) end_time_delta_array = np . array ([ abs ( pool_dt - end_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) # Find the index of the min() time delta # print(min(start_time_delta_list), min(end_time_delta_list)) # print(start_time_delta_list, end_time_delta_list) # define a window of interest amount the pool object start_time_index = np . where ( start_time_delta_array == min ( start_time_delta_array ))[ 0 ][ 0 ] end_time_index = np . where ( end_time_delta_array == min ( end_time_delta_array ))[ 0 ][ - 1 ] self . _pool_window = self . pool [ start_time_index : end_time_index + 1 ] # print(len(self._pool_window), len(self.pool[start_time_index:end_time_index+1])) return self . _pool_window def set_position_pool_window ( self , start_time : datetime . datetime = \\ datetime . datetime ( 1900 , 1 , 1 ), end_time : datetime . datetime = \\ datetime . datetime ( 2200 , 12 , 31 )): position_time_list = [ pos . open_time for pos in self . position_pool ] start_time_delta_list = [ abs ( pool_dt - start_time ) for pool_dt in position_time_list ] end_time_delta_list = [ abs ( pool_dt - end_time ) for pool_dt in position_time_list ] # define a window of interest amount the pool object start_time_index = start_time_delta_list . index ( min ( start_time_delta_list )) end_time_index = end_time_delta_list . index ( min ( end_time_delta_list )) self . _position_pool_window = self . position_pool [ start_time_index : \\ end_time_index + 1 ] return self . _position_pool_window def position_pool_window ( self ): \"\"\" A subset of position pool that is made by the set_position_pool_window method. \"\"\" return self . _position_pool_window @property def position_pool ( self ): \"\"\" The master position pool is a list that contains all the Position objects. This can be used to construct trading records using the PortfolioLog class and its method \"\"\" return self . _position_pool @staticmethod def _make_table ( pool_type : list ) -> pd . DataFrame : \"\"\" A static method that create a datafreame table using either pool_window or pool. This is an internal method to construct the table and master table attributes for the portfolio class. The reason I use the table method is that some obejct stored in the profolio list may contain non standard attributes, like contract expiration date. Parameters ---------- pool_type : pool object (list) The pool object type. It can be either pool_window or pool, corresponding to making table or master_table objects Returns ------- table : dataframe The resulting table. \"\"\" # Find the keys and values for asset within a particular time window # The function operate on the previously defined pool_window values = [ list ( pool_type [ i ][ 1 ] . values ()) for i in range ( len ( pool_type ))] keys = [ list ( pool_type [ i ][ 1 ] . keys ()) for i in range ( len ( pool_type ))][ 0 ] # Load the inforamtion to self._table table = pd . DataFrame . from_records ( data = values , columns = keys ) #print('tabletable', table) for index , ( val_name , misc ) in enumerate ( zip ( table [ 'name' ], table [ 'misc' ])): # add more conditions with unit and type temp_df = table [( table [ 'name' ] == val_name ) & ( table [ 'misc' ] == misc )] # If the asset is unique in the pool, pass. if len ( temp_df ) == 1 : pass # If the asset is not unique, perform the condesation action elif len ( temp_df ) > 1 : # print(list(temp_df['quantity']), sum(list(temp_df['quantity']))) # the summed quantity new_quantity = sum ( list ( temp_df [ 'quantity' ])) # make new entry_dictionary new_entry_dict = { 'name' : temp_df [ 'name' ] . iloc [ 0 ], 'quantity' : new_quantity , 'unit' : temp_df [ 'unit' ] . iloc [ 0 ], 'asset_type' : temp_df [ 'asset_type' ] . iloc [ 0 ], 'misc' : [ temp_df [ 'misc' ] . iloc [ 0 ]]} new_entry_dict = pd . DataFrame ( new_entry_dict , index = [ len ( table )]) # store them in the lowest row table = pd . concat ([ table , new_entry_dict ], ignore_index = False ) # delete the old entries table . drop ( list ( temp_df . index ), axis = 0 , inplace = True ) # sort the table by 'name' table . sort_values ( by = 'name' ) # reset the indices table . reset_index ( drop = True , inplace = True ) return table @staticmethod def _wipe_debt ( table_type ) -> None : \"\"\" An internal function to wipe the debt in tables if the debt asset has a quantity of 0. Parameters ---------- table_type : TYPE The type of tables, it can be either self.table or self.master_table. Returns ------- DataFrame new_table. \"\"\" index_list = [] # This assume misc contains a set. We may need to change this into dict later for i in range ( len ( table_type )): if table_type [ 'quantity' ] . iloc [ i ] == 0 and \\ 'debt' in table_type [ 'misc' ] . iloc [ i ]: index_list . append ( i ) new_table = table_type . drop ( index_list ) new_table . reset_index ( drop = True ) return new_table @property def table ( self ) -> pd . DataFrame : # tested \"\"\" An attribute that show a table of all the assets in the portfolio. The table operates on pool_window, meaning it obly shows the assets listed in the pool_window list. Please make sure you are setting the time window correctly. \"\"\" if self . _pool_window == None : raise Exception ( \"pool_window not found. Use either master_table or \\ define a pool_window for viewing first\" ) self . _table = self . _make_table ( self . pool_window ) if self . wipe_debt_or_not == True : self . _table = self . _wipe_debt ( self . _table ) self . _table . reset_index ( drop = True ) return self . _table @property def master_table ( self ) -> pd . DataFrame : # tested \"\"\" An attribute that show a table of all the assets in the portfolio. The table operates on pool, meaning it obly shows the assets listed in the pool list, i.e., it shows assets across all time. \"\"\" self . _master_table = self . _make_table ( self . pool ) if self . wipe_debt_or_not == True : self . _master_table = self . _wipe_debt ( self . _master_table ) self . _master_table . reset_index ( drop = True ) return self . _master_table def _add_to_remainder_dict ( self , asset_name : str , asset_quantity : int | float ) -> None : \"\"\" An internal method to add to the reaminder_dict every time there is a 'add' or 'sub' action operating on the pool attributes. Parameters ---------- asset_name : str The name of the asset. asset_quantity : int or float The quantity of the asset. Returns ------- None. \"\"\" # Add a new entry in the remainder_dict if the asset does not exist in # the Portfolio if asset_name not in self . _remainder_dict : self . _remainder_dict [ asset_name ] = asset_quantity # If it is already there, add the quantity. else : new_quantity = asset_quantity self . _remainder_dict [ asset_name ] = self . _remainder_dict [ asset_name ] + \\ new_quantity def check_remainder ( self , asset_name : str , quantity : int | float ) -> bool : \"\"\" A function that check the remainder if there are enough asset of a particular name in the portfolio. Parameters ---------- asset_name : str The name of the asset. asset_quantity : int or float The quantity of the asset. Returns ------- bool: whether it has more cash or asset than the zeropoint \"\"\" baseline = self . _remainder_dict [ asset_name ] - self . _zeropoint return baseline < quantity @property def remainder_dict ( self ) -> dict : \"\"\" It contains a dictionary of how much remainder of each asset is remained in the portfolio, essentially a counter for the ease of calculation. Returns ------- dict remainder_dict. \"\"\" return self . _remainder_dict def add ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . now (), quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that add a new asset to the pool. Parameters ---------- asset : str, Asset Object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # asset cannot be a list # check if it asset is an asset format if type ( asset ) == Asset : asset_name = asset . name elif type ( asset ) == str : # # search the dictionary to see what kind of asset is this # (potential improvement) # make a new asset # asset = Asset(asset, quantity, unit, asset_type) asset = { 'name' : asset , 'quantity' : quantity , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] elif type ( asset ) == dict : asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] # Add the asset into the pool self . __pool_asset . append ( asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity ) def sub ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . today (), asset_name : str = \"\" , quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that subtract an existing asset from the pool. Parameters ---------- asset : str, Asset object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # check if it asset is an asset format if type ( asset ) == dict : # call the quantity from table asset_name = asset [ 'name' ] # check if the total amount is higher than the subtraction amount if self . _remainder_limiter : if self . check_remainder ( asset_name , asset [ 'quantity' ]): raise Exception ( 'There is not enough {} to be subtracted \\ from the portfolio.' . format ( asset_name )) quantity = asset [ 'quantity' ] unit = asset [ 'unit' ] asset_type = asset [ 'asset_type' ] if type ( asset ) == str : # # search the dictionary to see what kind of asset is this # make a new asset asset_name = asset # make a new asset with a minus value for quantity new_asset = { 'name' : asset_name , 'quantity' : quantity *- 1 , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_quantity = new_asset [ 'quantity' ] #print('sub','new_asset', new_asset) self . __pool_asset . append ( new_asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity ) def value ( self , date_time : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' , price_proxy : str = \"Settle\" , time_proxy : str = 'Date' ): # WIP \"\"\" A function that return a dict with the price for each assets on a particular date and time. Parameters ---------- datetime: datetime object The datetime for query. price_dict: dict A dictionary that contains the pricing data filename for each assets. The default is PRICE_DICT. size_dict: dict A dictionary that contains the size (for example, number of barrels) contained in each assets. The default is SIZE_DICT. dntr: str The denomanator currency for calculating the value of each asset. The default is USD'. Returns ------_ value_dict: dict A dictionary for the value of each assets for that time. \"\"\" # Set a pool window for intrest self . set_pool_window ( self . __pool_datetime [ 0 ], date_time ) # Initialise dict, find unique asset_name unique_name_list = list ( set ([ asset [ 'name' ] for asset in self . __pool_asset ])) quantity_dict = { unique_name : 0 for unique_name in unique_name_list } # loop and get the quantity of each assets for i , ( _ , asset ) in enumerate ( self . pool_window ): quantity_dict [ asset [ 'name' ]] = quantity_dict [ asset [ 'name' ]] + \\ asset [ 'quantity' ] value_dict = dict () for i , ( dt , asset ) in enumerate ( self . pool_window ): if asset [ 'name' ] == dntr : value_dict [ dntr ] = quantity_dict [ dntr ] else : if size_dict == None : # manage the size of the asset size = 1 else : # Get the size of each asset size = size_dict [ asset [ 'name' ]] sub_price_table = price_dict [ asset [ 'name' ]] target_time = date_time . strftime ( \"%Y-%m- %d \" ) # print('price:', sub_price_table[price_proxy][sub_price_table[time_proxy] == \\ # target_time]) # query search for the price of an asset of the date of interest price = sub_price_table [ price_proxy ][ sub_price_table [ time_proxy ] == target_time ] . item () quantity = quantity_dict [ asset [ 'name' ]] value_dict [ asset [ 'name' ]] = float ( price ) * quantity * size return value_dict def asset_value ( self , asset_name : str , datetime : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' ) -> float : \"\"\" A function that return a dict with of a particular asset on a particular date and time. Parameters ---------- asset_name : str The name of the asset. datetime : datetime object The date and time of interest. Returns ------- asset_value : float the asset value. \"\"\" asset_value = self . value ( datetime , price_dict = price_dict , size_dict = size_dict , dntr = dntr )[ asset_name ] return asset_value def total_value ( self , datetime : datetime . datetime , dntr : str = 'USD' ) -> float : \"\"\" A function that return the total value of the entire portfolio on a particular date and time. Parameters ---------- datetime : datetime object The date and time of interest. Returns ------- total_value : float the total value. \"\"\" total_value = sum ( self . value ( datetime , dntr = dntr ) . values ()) return total_value","title":"Portfolio"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.master_table","text":"An attribute that show a table of all the assets in the portfolio. The table operates on pool, meaning it obly shows the assets listed in the pool list, i.e., it shows assets across all time.","title":"master_table"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.pool","text":"A pool that contains all the Asset objects. This is the unstructured data containers. Refined method should be operating on the attribute 'table'. This is to also avoid mixing fungible and non-fungible assets. It contains a sequential record of the adding and subtracting assets from the portfolio. It can be used to generate a log of asset movement and a table for viewing its overall values. Note that Asset can have a negative quantity. It means an exit of some asset from the portfolio. To add or subtract asset from the pool, you need to use the add and sub function.","title":"pool"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.pool_asset","text":"A list that contains the the added assets.","title":"pool_asset"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.pool_datetime","text":"A list that contains the corresponding datetime where asset is added","title":"pool_datetime"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.pool_df","text":"A pool in dataframe format for easy query.","title":"pool_df"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.pool_window","text":"A pool window given by a specific time intervals. This function initialised the object. Use set_pool_window to set a particular time frame.","title":"pool_window"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.position_pool","text":"The master position pool is a list that contains all the Position objects. This can be used to construct trading records using the PortfolioLog class and its method","title":"position_pool"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.remainder_dict","text":"It contains a dictionary of how much remainder of each asset is remained in the portfolio, essentially a counter for the ease of calculation. Returns: dict \u2013 remainder_dict.","title":"remainder_dict"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.table","text":"An attribute that show a table of all the assets in the portfolio. The table operates on pool_window, meaning it obly shows the assets listed in the pool_window list. Please make sure you are setting the time window correctly.","title":"table"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.add","text":"A function that add a new asset to the pool. Parameters: asset ( str, Asset Object, list ) \u2013 The asset to be added. datetime ( datetime , default: now () ) \u2013 The datetime that the asset is added quantity ( int | float , default: 0 ) \u2013 The number of the same asset added. The default is 0. unit ( str , default: 'contract' ) \u2013 The unit name of the asset. The default is 'contract'. asset_type ( str , default: 'future' ) \u2013 The type name of the asset. The default is 'future'. Returns: None. \u2013 Source code in EC_tools/portfolio.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def add ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . now (), quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that add a new asset to the pool. Parameters ---------- asset : str, Asset Object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # asset cannot be a list # check if it asset is an asset format if type ( asset ) == Asset : asset_name = asset . name elif type ( asset ) == str : # # search the dictionary to see what kind of asset is this # (potential improvement) # make a new asset # asset = Asset(asset, quantity, unit, asset_type) asset = { 'name' : asset , 'quantity' : quantity , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] elif type ( asset ) == dict : asset_name = asset [ 'name' ] asset_quantity = asset [ 'quantity' ] # Add the asset into the pool self . __pool_asset . append ( asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity )","title":"add"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.asset_value","text":"A function that return a dict with of a particular asset on a particular date and time. Parameters: asset_name ( str ) \u2013 The name of the asset. datetime ( datetime object ) \u2013 The date and time of interest. Returns: asset_value ( float ) \u2013 the asset value. Source code in EC_tools/portfolio.py 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def asset_value ( self , asset_name : str , datetime : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' ) -> float : \"\"\" A function that return a dict with of a particular asset on a particular date and time. Parameters ---------- asset_name : str The name of the asset. datetime : datetime object The date and time of interest. Returns ------- asset_value : float the asset value. \"\"\" asset_value = self . value ( datetime , price_dict = price_dict , size_dict = size_dict , dntr = dntr )[ asset_name ] return asset_value","title":"asset_value"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.check_remainder","text":"A function that check the remainder if there are enough asset of a particular name in the portfolio. Parameters: asset_name ( str ) \u2013 The name of the asset. asset_quantity ( int or float ) \u2013 The quantity of the asset. Returns: bool ( whether it has more cash or asset than the zeropoint ) \u2013 Source code in EC_tools/portfolio.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def check_remainder ( self , asset_name : str , quantity : int | float ) -> bool : \"\"\" A function that check the remainder if there are enough asset of a particular name in the portfolio. Parameters ---------- asset_name : str The name of the asset. asset_quantity : int or float The quantity of the asset. Returns ------- bool: whether it has more cash or asset than the zeropoint \"\"\" baseline = self . _remainder_dict [ asset_name ] - self . _zeropoint return baseline < quantity","title":"check_remainder"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.position_pool_window","text":"A subset of position pool that is made by the set_position_pool_window method. Source code in EC_tools/portfolio.py 191 192 193 194 195 196 197 def position_pool_window ( self ): \"\"\" A subset of position pool that is made by the set_position_pool_window method. \"\"\" return self . _position_pool_window","title":"position_pool_window"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.set_pool_window","text":"Setter method for the pool_window object. Parameters: start_time ( datetime object , default: datetime (1900, 1, 1) ) \u2013 The start time . The default is datetime.datetime(1900,1,1). end_time ( datetime object , default: datetime (2200, 12, 31) ) \u2013 The end time. The default is datetime.datetime(2200,12,31). Returns: list \u2013 pool_window list object. Source code in EC_tools/portfolio.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def set_pool_window ( self , start_time : datetime . datetime = datetime . datetime ( 1900 , 1 , 1 ), end_time : datetime . datetime = datetime . datetime ( 2200 , 12 , 31 )) -> None : \"\"\" Setter method for the pool_window object. Parameters ---------- start_time : datetime object, optional The start time . The default is datetime.datetime(1900,1,1). end_time : datetime object, optional The end time. The default is datetime.datetime(2200,12,31). Returns ------- list pool_window list object. \"\"\" # make a list of start_time and end_time # subtract the original datetime with them start_time_delta_array = np . array ([ abs ( pool_dt - start_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) end_time_delta_array = np . array ([ abs ( pool_dt - end_time ) for i , pool_dt in enumerate ( self . __pool_datetime )]) # Find the index of the min() time delta # print(min(start_time_delta_list), min(end_time_delta_list)) # print(start_time_delta_list, end_time_delta_list) # define a window of interest amount the pool object start_time_index = np . where ( start_time_delta_array == min ( start_time_delta_array ))[ 0 ][ 0 ] end_time_index = np . where ( end_time_delta_array == min ( end_time_delta_array ))[ 0 ][ - 1 ] self . _pool_window = self . pool [ start_time_index : end_time_index + 1 ] # print(len(self._pool_window), len(self.pool[start_time_index:end_time_index+1])) return self . _pool_window","title":"set_pool_window"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.sub","text":"A function that subtract an existing asset from the pool. Parameters: asset ( str, Asset object, list ) \u2013 The asset to be added. datetime ( datetime , default: today () ) \u2013 The datetime that the asset is added quantity ( int | float , default: 0 ) \u2013 The number of the same asset added. The default is 0. unit ( str , default: 'contract' ) \u2013 The unit name of the asset. The default is 'contract'. asset_type ( str , default: 'future' ) \u2013 The type name of the asset. The default is 'future'. Returns: None. \u2013 Source code in EC_tools/portfolio.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 def sub ( self , asset : Asset | str | dict , datetime : datetime . datetime = datetime . datetime . today (), asset_name : str = \"\" , quantity : int | float = 0 , unit : str = 'contract' , asset_type : str = 'future' ) -> None : # tested \"\"\" A function that subtract an existing asset from the pool. Parameters ---------- asset : str, Asset object, list The asset to be added. datetime: datetime The datetime that the asset is added quantity: float, int The number of the same asset added. The default is 0. unit: str The unit name of the asset. The default is 'contract'. asset_type: str The type name of the asset. The default is 'future'. Returns ------- None. \"\"\" # check if it asset is an asset format if type ( asset ) == dict : # call the quantity from table asset_name = asset [ 'name' ] # check if the total amount is higher than the subtraction amount if self . _remainder_limiter : if self . check_remainder ( asset_name , asset [ 'quantity' ]): raise Exception ( 'There is not enough {} to be subtracted \\ from the portfolio.' . format ( asset_name )) quantity = asset [ 'quantity' ] unit = asset [ 'unit' ] asset_type = asset [ 'asset_type' ] if type ( asset ) == str : # # search the dictionary to see what kind of asset is this # make a new asset asset_name = asset # make a new asset with a minus value for quantity new_asset = { 'name' : asset_name , 'quantity' : quantity *- 1 , 'unit' : unit , 'asset_type' : asset_type , 'misc' : {}} asset_quantity = new_asset [ 'quantity' ] #print('sub','new_asset', new_asset) self . __pool_asset . append ( new_asset ) # save new asset self . __pool_datetime . append ( datetime ) # record datetime # Add the latest quantity to the remainder_dict for remainder check self . _add_to_remainder_dict ( asset_name , asset_quantity )","title":"sub"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.total_value","text":"A function that return the total value of the entire portfolio on a particular date and time. Parameters: datetime ( datetime object ) \u2013 The date and time of interest. Returns: total_value ( float ) \u2013 the total value. Source code in EC_tools/portfolio.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 def total_value ( self , datetime : datetime . datetime , dntr : str = 'USD' ) -> float : \"\"\" A function that return the total value of the entire portfolio on a particular date and time. Parameters ---------- datetime : datetime object The date and time of interest. Returns ------- total_value : float the total value. \"\"\" total_value = sum ( self . value ( datetime , dntr = dntr ) . values ()) return total_value","title":"total_value"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.Portfolio.value","text":"A function that return a dict with the price for each assets on a particular date and time. Parameters: datetime \u2013 The datetime for query. price_dict ( dict , default: PRICE_DICT ) \u2013 A dictionary that contains the pricing data filename for each assets. The default is PRICE_DICT. size_dict ( dict , default: SIZE_DICT ) \u2013 A dictionary that contains the size (for example, number of barrels) contained in each assets. The default is SIZE_DICT. dntr ( str , default: 'USD' ) \u2013 The denomanator currency for calculating the value of each asset. The default is USD'. Returns \u2013 value_dict \u2013 A dictionary for the value of each assets for that time. Source code in EC_tools/portfolio.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def value ( self , date_time : datetime . datetime , price_dict : dict = PRICE_DICT , size_dict : dict = SIZE_DICT , dntr : str = 'USD' , price_proxy : str = \"Settle\" , time_proxy : str = 'Date' ): # WIP \"\"\" A function that return a dict with the price for each assets on a particular date and time. Parameters ---------- datetime: datetime object The datetime for query. price_dict: dict A dictionary that contains the pricing data filename for each assets. The default is PRICE_DICT. size_dict: dict A dictionary that contains the size (for example, number of barrels) contained in each assets. The default is SIZE_DICT. dntr: str The denomanator currency for calculating the value of each asset. The default is USD'. Returns ------_ value_dict: dict A dictionary for the value of each assets for that time. \"\"\" # Set a pool window for intrest self . set_pool_window ( self . __pool_datetime [ 0 ], date_time ) # Initialise dict, find unique asset_name unique_name_list = list ( set ([ asset [ 'name' ] for asset in self . __pool_asset ])) quantity_dict = { unique_name : 0 for unique_name in unique_name_list } # loop and get the quantity of each assets for i , ( _ , asset ) in enumerate ( self . pool_window ): quantity_dict [ asset [ 'name' ]] = quantity_dict [ asset [ 'name' ]] + \\ asset [ 'quantity' ] value_dict = dict () for i , ( dt , asset ) in enumerate ( self . pool_window ): if asset [ 'name' ] == dntr : value_dict [ dntr ] = quantity_dict [ dntr ] else : if size_dict == None : # manage the size of the asset size = 1 else : # Get the size of each asset size = size_dict [ asset [ 'name' ]] sub_price_table = price_dict [ asset [ 'name' ]] target_time = date_time . strftime ( \"%Y-%m- %d \" ) # print('price:', sub_price_table[price_proxy][sub_price_table[time_proxy] == \\ # target_time]) # query search for the price of an asset of the date of interest price = sub_price_table [ price_proxy ][ sub_price_table [ time_proxy ] == target_time ] . item () quantity = quantity_dict [ asset [ 'name' ]] value_dict [ asset [ 'name' ]] = float ( price ) * quantity * size return value_dict","title":"value"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioLog","text":"Bases: Portfolio A class that produce A full transaction Log for the Portfolio. Note that this method generates a log that contains the changes in Portfolio values. The key differences between PortfolioLog and Portfolio is that the former handles the prices for assets at a given time and the trading records of the Porfolio while later only handles what is contained in the Portfolio. Source code in EC_tools/portfolio.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 @dataclass class PortfolioLog ( Portfolio ): \"\"\" A class that produce A full transaction Log for the Portfolio. Note that this method generates a log that contains the changes in Portfolio values. The key differences between PortfolioLog and Portfolio is that the former handles the prices for assets at a given time and the trading records of the Porfolio while later only handles what is contained in the Portfolio. \"\"\" portfolio : Portfolio = None _log : pd . DataFrame = None tradebook_filename = str = \"\" @util . time_it def _make_log ( self , simple_log = False ): # Decrepated time complexity too large \"\"\" An internal method to construct logs for the portfolio. \"\"\" log = list () print ( \"Generating Portfolio Log...\" ) if simple_log : # simple_log make a log with only the inforamtion at the start of the day temp = [ datetime . datetime . combine ( dt . date (), datetime . time ( 0 , 0 )) for dt in self . portfolio . pool_datetime ] # reorganised the time_list because set() function scramble the order # Use the set function to output a unique datetime list time_list = sorted ( list ( set ( temp ))) # Add an extra day to see what is the earning for the last day # time_list = time_list + \\ # [time_list[-1]+datetime.timedelta(days=1)] else : time_list = self . portfolio . pool_datetime # print(time_list) # Add an entry at the end of the day to see what is the earning for the last day last_dt = datetime . datetime . combine ( time_list [ - 1 ] . date (), datetime . time ( 23 , 59 )) time_list = time_list + [ last_dt ] # then loop through the pool history and store them in log list for item in time_list : #print('time', item) value_entry = self . portfolio . value ( item ) value_entry [ \"Total\" ] = sum ( list ( value_entry . values ())) value_entry [ 'Datetime' ] = item print ( 'VE' , item , value_entry ) log . append ( value_entry ) # return a log of the values of each asset by time self . _log = pd . DataFrame ( log ) # reorganise columns order asset_name_list = list ( self . portfolio . value ( self . portfolio . pool_datetime [ - 1 ]) . keys ()) self . _log = self . _log [[ 'Datetime' , 'Total' ] + asset_name_list ] print ( \"Log is avalibale.\" ) self . _log . sort_values ( by = \"Datetime\" , inplace = True , ignore_index = True ) return self . _log @property def log ( self ) -> pd . DataFrame : \"\"\" A simple log that only shows the Portfolio's value at 00:00:00 of the day. Returns ------- DataFrame Simple Log. \"\"\" return self . _make_log ( simple_log = True ) @property def full_log ( self ) -> pd . DataFrame : \"\"\" A full log that only shows every entry in the changes in the Portfolio's value. Returns ------- DataFrame Full Log. \"\"\" return self . _make_log ( simple_log = False ) def asset_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . log [ asset_name ] return asset_log def asset_full_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . full_log [ asset_name ] return asset_log def render_tradebook ( self , save_or_not : bool = True ): custom_list0 = [ 'Trade_ID' , 'Direction' , 'Commodity' , 'Price_Code' , 'Entry_Date' , 'Entry_Datetime' , 'Entry_Price' , 'Exit_Date' , 'Exit_Datetime' , 'Exit_Price' , 'Trade_Return' , 'Trade_Return_Fraction' ] position_pool = self . portfolio . position_pool book = Bookkeep ( bucket_type = 'backtest' , custom_keywords_list = custom_list0 ) #, 'Scaled_Return'] # , 'Risk_Reward_Ratio', 'strategy_name'] trade_PNL = book . make_bucket () def select_func_fill ( x ): return position_pool [ x ] . status . value == 'Filled' PP = read . group_trade ( position_pool , select_func = select_func_fill ) #print(PP[0:2]) for i , ele in enumerate ( PP ): #print(i) trade_id = ele [ 0 ] . pos_id direction = re . sub ( r '\\-(.*)' , '' , ele [ 0 ] . pos_type ) symbol = ele [ 0 ] . get_obj [ 'name' ] commodity_name = SYMBOL_KEYWORDS_DICT [ symbol ] entry_date = ele [ 0 ] . fill_time . date () entry_datetime = ele [ 0 ] . fill_time entry_price = ele [ 0 ] . price exit_date = ele [ 1 ] . fill_time . date () exit_datetime = ele [ 1 ] . fill_time exit_price = ele [ 1 ] . price if direction == \"Long\" : trade_return = exit_price - entry_price trade_return_fraction = ( exit_price - entry_price ) / entry_price #scaled_return = 000 elif direction == \"Short\" : trade_return = entry_price - exit_price trade_return_fraction = ( entry_price - exit_price ) / exit_price data = [ trade_id , direction , commodity_name , symbol , entry_date , entry_datetime , entry_price , exit_date , exit_datetime , exit_price , trade_return , trade_return_fraction ] trade_PNL = book . store_to_bucket_single ( data ) trade_PNL = pd . DataFrame ( trade_PNL ) trade_PNL = trade_PNL . sort_values ( by = 'Trade_ID' ) # sort by ID if save_or_not : trade_PNL . to_csv ( self . tradebook_filename , index = False ) return trade_PNL def render_tradebook_xlsx ( self ): tradebook_xlsx = read . render_PNL_xlsx ([ self . tradebook_filename ], return_proxy = 'Trade_Return' ) return tradebook_xlsx @property def tradebook ( self ) -> pd . DataFrame : \"\"\" The tradebook made using the position pool. Returns ------- DataFrame Tradebook. \"\"\" return self . render_tradebook ( save_or_not = False ) def full_tradebook ( self ) -> pd . DataFrame : return self . render_tradebook ( save_or_not = False ) def add_column ( self ): pass","title":"PortfolioLog"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioLog.full_log","text":"A full log that only shows every entry in the changes in the Portfolio's value. Returns: DataFrame \u2013 Full Log.","title":"full_log"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioLog.log","text":"A simple log that only shows the Portfolio's value at 00:00:00 of the day. Returns: DataFrame \u2013 Simple Log.","title":"log"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioLog.tradebook","text":"The tradebook made using the position pool. Returns: DataFrame \u2013 Tradebook.","title":"tradebook"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioLog.asset_full_log","text":"The log of the changes in values for a particular assets across all time. Source code in EC_tools/portfolio.py 753 754 755 756 757 758 759 760 def asset_full_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . full_log [ asset_name ] return asset_log","title":"asset_full_log"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioLog.asset_log","text":"The log of the changes in values for a particular assets across all time. Source code in EC_tools/portfolio.py 744 745 746 747 748 749 750 751 def asset_log ( self , asset_name ) -> pd . DataFrame : # tested \"\"\" The log of the changes in values for a particular assets across all time. \"\"\" asset_log = self . log [ asset_name ] return asset_log","title":"asset_log"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics","text":"Bases: Portfolio A class that generate all Portfolio metrics. Generally, the Portfolio Metrics method returns a tuple of (value, unit, metric_name). Source code in EC_tools/portfolio.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 @dataclass class PortfolioMetrics ( Portfolio ): \"\"\" A class that generate all Portfolio metrics. Generally, the Portfolio Metrics method returns a tuple of (value, unit, metric_name). \"\"\" _portfolio : Portfolio def __post_init__ ( self ): self . portfolio_log = PortfolioLog ( self . _portfolio ) self . tradebook = self . portfolio_log . tradebook def _load_filled_position_pool ( self ) -> list : \"\"\" A function to load only the filled position to a list Returns ------- list Filled position list \"\"\" position_pool = self . _portfolio . position_pool def select_func_fill ( x ): return position_pool [ x ] . status . value == 'Filled' PP = read . group_trade ( position_pool , select_func = select_func_fill ) return PP def start_capital ( self , dntr : str = 'USD' , cash_only : bool = False ) -> tuple [ float , str , str ]: first_date = self . _portfolio . pool_datetime [ 0 ] if not cash_only : first_entry_total_value = self . _portfolio . total_value ( first_date , dntr = dntr ) return first_entry_total_value , dntr , 'Starting Capital' def end_capital ( self , dntr : str = 'USD' , cash_only : bool = False ) -> tuple [ float , str , str ]: last_date = self . _portfolio . pool_datetime [ - 1 ] if not cash_only : last_entry_total_value = self . _portfolio . total_value ( last_date , dntr = dntr ) return last_entry_total_value , dntr , \"Final Capital\" def period ( self , time_proxy : str = 'Exit_Date' , unit : str = \"Days\" ) -> tuple [ int , str , str ]: \"\"\" Total Days of trading Parameters ---------- time_proxy : str, optional Column name for the time. The default is 'Exit_Date'. unit : str, optional Unit. The default is \"Days\". \"\"\" period = self . tradebook [ time_proxy ] . iloc [ - 1 ] - self . tradebook [ time_proxy ] . iloc [ 0 ] return period , unit , \"Period\" def total_trades ( self ) -> tuple [ int , str , str ]: \"\"\" The total number of trades in the tradebook. \"\"\" return len ( self . tradebook ), '#' , \"Total Trades\" def total_fee_paid ( self ) -> float : # WIP position_pool = self . _portfolio . position_pool def select_func_fill ( x ): return position_pool [ x ] . status . value == 'Filled' PP = read . group_trade ( position_pool , select_func = select_func_fill ) total_fee_dict = dict () total_fee = 0 for ele in PP : # Assuming the second item in each element contains the fee total_fee = total_fee + ele [ 1 ] . fee [ 'quantity' ] return total_fee , '' , 'Total Fee Paid' def total_returns ( self , dntr = 'USD' ) -> tuple [ float , str ]: \"\"\" The total returns given a currency denomanator Parameters ---------- dntr : str, optional Currency denomanator. The default is 'USD'. Returns ------- tuple[float,str,str] total returns, unit, metric name. \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date , dntr = dntr ) last_entry_total_value = self . _portfolio . total_value ( last_date , dntr = dntr ) return ( last_entry_total_value - first_entry_total_value ), dntr , \\ \"Total Returns\" def total_returns_fraction ( self , unit : str = '%' ) -> tuple [ float , str , str ]: \"\"\" The total returns by fraction (percentage). Parameters ---------- unit : str, optional Percentage. The default is '%'. Returns ------- tuple[float,str] total return \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date ) last_entry_total_value = self . _portfolio . total_value ( last_date ) #print(first_entry_total_value, last_entry_total_value) return 100 * ( last_entry_total_value - first_entry_total_value ) / \\ first_entry_total_value , unit , \"Total Returns\" def win_rate ( self , return_proxy : str = \"Trade_Return\" , unit : str = \"%\" ) -> \\ tuple [ float , str , str ]: \"\"\" The win rate by percentage. Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". unit : str, optional The Unit percentage. The default is \"%\". Returns ------- tuple[float,str] Win Rate. \"\"\" win_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) return ( win_trades / ( win_trades + lose_trades )) * 100 , unit , \"Win Rate\" def profit_factor ( self , return_proxy : str = \"Trade_Return\" ) -> \\ tuple [ float , str , str ]: \"\"\" The Profit factor (Money Won /Money Lose) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". Returns ------- float The profit factor. \"\"\" win_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) # print(win_trades_val, lose_trades_val) return abs ( win_trades_val ) / abs ( lose_trades_val ), '' , 'Profit Factor' def total_open_positions ( self ) -> tuple [ int , str , str ]: #WIP position_pool = self . _portfolio . position_pool trade_pool = read . group_trade ( position_pool ) total_open_pos = sum ( 1 for pos in trade_pool if pos [ 0 ] . status . value == 'Filled' and pos [ 1 ] . status . value == 'Pending' and pos [ 2 ] . status . value == 'Pending' and pos [ 3 ] . status . value == 'Pending' ) return total_open_pos , '#' , 'Total Open Positions' def total_close_positions ( self ): position_pool = self . _portfolio . position_pool # Group the trades by ID and Filled status trade_pool = read . group_trade ( position_pool , select_func = lambda x : position_pool [ x ] . status . value == 'Filled' ) total_open_pos = sum ( 1 for pos in trade_pool if len ( pos ) == 2 ) return total_open_pos , '#' , 'Total Close Positions' def avg_trade_return ( self , return_proxy : str = \"Trade_Return\" , unit : str = 'USD' ) -> tuple [ str , str ]: \"\"\" A method that calculate average trade return Parameters ---------- return_proxy : str, optional DESCRIPTION. The default is \"Trade_Return\". unit : str, optional The unit relies on user-input. The default is 'USD'. Returns ------- tuple[str,str] The average trade return and the currency unit. \"\"\" filled_pos_list = self . _load_filled_position_pool () trade_return = np . array ([ trade for trade in self . tradebook [ return_proxy ] . to_list ()]) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity return np . average ( daily_return_amount ), unit , 'Average Trade Return' #def _daily_exposure(self): # return def sharpe_ratio ( self , return_proxy : str = \"Trade_Return\" , riskfree_rate : float | list = 0.05 ) -> float : \"\"\" The Sharpe Ratio (S). S = E(R_p - R_f)/std(S_p) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". riskfree_rate : float | list, optional The proxy for risk-free rate. The default is 0.05. Assuming 5 % yield in 5-years treasurey bond. Returns ------- float The Sharpe Ratio. \"\"\" #trade_return = self.tradebook[return_proxy].to_numpy() filled_pos_list = self . _load_filled_position_pool () direction = np . array ([ trade for trade in self . tradebook [ \"Direction\" ] . to_list ()]) entry_price = np . array ([ trade for trade in self . tradebook [ \"Entry_Price\" ] . to_list ()]) exit_price = np . array ([ trade for trade in self . tradebook [ \"Exit_Price\" ] . to_list ()]) #print(\"filled_pos_list\", filled_pos_list[0:2]) trade_return = np . array ([ trade for trade in self . tradebook [ \"Trade_Return\" ] . to_list ()]) trade_return_fraction = np . array ([ trade for trade in self . tradebook [ \"Trade_Return_Fraction\" ] . to_list ()]) # trade_open = np.array([trade[0].give_obj['quantity'] for trade in filled_pos_list]) # trade_close = np.array([trade[1].give_obj['quantity'] for trade in filled_pos_list]) # print('trade_open', trade_open, 'trade_close', trade_close) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity cumsum = np . cumsum ( daily_return_amount ) cumsum_growth = ( cumsum [ 1 : - 1 ] - cumsum [ 0 : - 2 ]) / cumsum [ 0 : - 2 ] # ============================================================================= # print('entry_price', entry_price) # print('exit_price', exit_price) # print('trade_return', trade_return) # print(\"trade_return_fraction\", trade_return_fraction) # print('max, min', max(trade_return_fraction), min(trade_return_fraction)) # print('daily_return_amount', daily_return_amount) # print('cumsum', cumsum, len(cumsum)) # print('cumsum_growth', cumsum_growth, len(cumsum_growth)) # print(\"self.total_returns_fraction()[0]*0.01\", self.total_returns_fraction()[0]*0.01) # print('std(cumsum_growth)', np.std(cumsum_growth)) # ============================================================================= # trade_return_fraction = (trade_close-trade_open)/trade_open #print('daily_return_amount', daily_return_amount, trade_close-trade_open) #print('trade_return_fraction', trade_return_fraction) #riskfree_rate = np.repeat(riskfree_rate, len(daily_return_amount)) #sharpe_ratio = (self.total_returns_fraction()[0]*0.01 - riskfree_rate) / \\ # np.std(daily_return_amount) sharpe_ratio = ( self . total_returns_fraction ()[ 0 ] * 0.01 - riskfree_rate ) / \\ np . std ( cumsum_growth ) ** 0.5 return sharpe_ratio , '' , 'Sharpe Ratio' # so far it is the wrong number because the growth of cumsum is corss-asset, # the return should be calculated using per day basis not per trade/ def calmar_ratio ( self ): return def omega_ratio ( self ): return def sortino_ratio ( self ): return @classmethod def make_full_data ( cls ): # Calculate all metrics related to thid portfolio full_data = dict () attr_name = [ value for value in dir ( cls ) if value not in dir ( Portfolio ) and value [ 0 ] != '_' and value [ 0 : 4 ] != 'make' ] attrs = ( getattr ( cls , name ) for name in attr_name ) #methods = filter(inspect.ismethod, attrs) for attr , name in zip ( attrs , attr_name ): print ( attr , name ) #df = method(cls) #full_data[name] = df print ( attr_name , attrs ) #full_data = {name: getattr(cls, name)() for name in attr_name} print ( full_data ) return full_data def make_full_report ( self ): print ( 'Period [ {} ]' . format ( self . period ()[ 1 ]), self . period ()[ 0 ]) print ( \"Initial Capital [ {} ]\" . format ( self . start_capital ()[ 1 ]), self . start_capital ()[ 0 ]) print ( \"Final Capital [ {} ]\" . format ( self . end_capital ()[ 1 ]), self . end_capital ()[ 0 ]) print ( 'Total Trades [ {} ]' . format ( self . total_trades ()[ 1 ]), self . total_trades ()[ 0 ]) print ( 'Total Fee []' , self . total_fee_paid ()) print ( 'Total Returns [ {} ]' . format ( self . total_returns ()[ 1 ]), self . total_returns ()[ 0 ]) print ( 'Total_returns [ {} ]' . format ( self . total_returns_fraction ()[ 1 ]), self . total_returns_fraction ()[ 0 ]) print ( 'win_rate [ {} ]' . format ( self . win_rate ()[ 1 ]), self . win_rate ()[ 0 ]) print ( 'Profit Factor' , self . profit_factor ()) print ( 'Total Open Positions [ {} ]' . format ( self . total_open_positions ()[ 1 ]), self . total_open_positions ()[ 0 ]) print ( 'total Close Positions [ {} ]' . format ( self . total_close_positions ()[ 1 ]), self . total_close_positions ()[ 0 ]) print ( 'Average Trade Return [ {} ]' . format ( self . avg_trade_return ()[ 1 ]), self . avg_trade_return ()[ 0 ]) print ( 'Sharpe Ratio (#sigma not stable)' , self . sharpe_ratio ()[ 0 ]) x = PrettyTable ()","title":"PortfolioMetrics"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.avg_trade_return","text":"A method that calculate average trade return Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 DESCRIPTION. The default is \"Trade_Return\". unit ( str , default: 'USD' ) \u2013 The unit relies on user-input. The default is 'USD'. Returns: tuple [ str , str ] \u2013 The average trade return and the currency unit. Source code in EC_tools/portfolio.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 def avg_trade_return ( self , return_proxy : str = \"Trade_Return\" , unit : str = 'USD' ) -> tuple [ str , str ]: \"\"\" A method that calculate average trade return Parameters ---------- return_proxy : str, optional DESCRIPTION. The default is \"Trade_Return\". unit : str, optional The unit relies on user-input. The default is 'USD'. Returns ------- tuple[str,str] The average trade return and the currency unit. \"\"\" filled_pos_list = self . _load_filled_position_pool () trade_return = np . array ([ trade for trade in self . tradebook [ return_proxy ] . to_list ()]) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity return np . average ( daily_return_amount ), unit , 'Average Trade Return'","title":"avg_trade_return"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.period","text":"Total Days of trading Parameters: time_proxy ( str , default: 'Exit_Date' ) \u2013 Column name for the time. The default is 'Exit_Date'. unit ( str , default: 'Days' ) \u2013 Unit. The default is \"Days\". Source code in EC_tools/portfolio.py 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 def period ( self , time_proxy : str = 'Exit_Date' , unit : str = \"Days\" ) -> tuple [ int , str , str ]: \"\"\" Total Days of trading Parameters ---------- time_proxy : str, optional Column name for the time. The default is 'Exit_Date'. unit : str, optional Unit. The default is \"Days\". \"\"\" period = self . tradebook [ time_proxy ] . iloc [ - 1 ] - self . tradebook [ time_proxy ] . iloc [ 0 ] return period , unit , \"Period\"","title":"period"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.profit_factor","text":"The Profit factor (Money Won /Money Lose) Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 The column name to query in the tradebook. The default is \"Trade_Return\". Returns: float \u2013 The profit factor. Source code in EC_tools/portfolio.py 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def profit_factor ( self , return_proxy : str = \"Trade_Return\" ) -> \\ tuple [ float , str , str ]: \"\"\" The Profit factor (Money Won /Money Lose) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". Returns ------- float The profit factor. \"\"\" win_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades_val = sum ( i for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) # print(win_trades_val, lose_trades_val) return abs ( win_trades_val ) / abs ( lose_trades_val ), '' , 'Profit Factor'","title":"profit_factor"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.sharpe_ratio","text":"The Sharpe Ratio (S). S = E(R_p - R_f)/std(S_p) Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 The column name to query in the tradebook. The default is \"Trade_Return\". riskfree_rate ( float | list , default: 0.05 ) \u2013 The proxy for risk-free rate. The default is 0.05. Assuming 5 % yield in 5-years treasurey bond. Returns: float \u2013 The Sharpe Ratio. Source code in EC_tools/portfolio.py 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 def sharpe_ratio ( self , return_proxy : str = \"Trade_Return\" , riskfree_rate : float | list = 0.05 ) -> float : \"\"\" The Sharpe Ratio (S). S = E(R_p - R_f)/std(S_p) Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". riskfree_rate : float | list, optional The proxy for risk-free rate. The default is 0.05. Assuming 5 % yield in 5-years treasurey bond. Returns ------- float The Sharpe Ratio. \"\"\" #trade_return = self.tradebook[return_proxy].to_numpy() filled_pos_list = self . _load_filled_position_pool () direction = np . array ([ trade for trade in self . tradebook [ \"Direction\" ] . to_list ()]) entry_price = np . array ([ trade for trade in self . tradebook [ \"Entry_Price\" ] . to_list ()]) exit_price = np . array ([ trade for trade in self . tradebook [ \"Exit_Price\" ] . to_list ()]) #print(\"filled_pos_list\", filled_pos_list[0:2]) trade_return = np . array ([ trade for trade in self . tradebook [ \"Trade_Return\" ] . to_list ()]) trade_return_fraction = np . array ([ trade for trade in self . tradebook [ \"Trade_Return_Fraction\" ] . to_list ()]) # trade_open = np.array([trade[0].give_obj['quantity'] for trade in filled_pos_list]) # trade_close = np.array([trade[1].give_obj['quantity'] for trade in filled_pos_list]) # print('trade_open', trade_open, 'trade_close', trade_close) trade_size = np . array ([ trade [ 1 ] . size for trade in filled_pos_list ]) trade_quantity = np . array ([ trade [ 1 ] . get_obj [ 'quantity' ] for trade in filled_pos_list ]) daily_return_amount = trade_return * trade_size * trade_quantity cumsum = np . cumsum ( daily_return_amount ) cumsum_growth = ( cumsum [ 1 : - 1 ] - cumsum [ 0 : - 2 ]) / cumsum [ 0 : - 2 ] # ============================================================================= # print('entry_price', entry_price) # print('exit_price', exit_price) # print('trade_return', trade_return) # print(\"trade_return_fraction\", trade_return_fraction) # print('max, min', max(trade_return_fraction), min(trade_return_fraction)) # print('daily_return_amount', daily_return_amount) # print('cumsum', cumsum, len(cumsum)) # print('cumsum_growth', cumsum_growth, len(cumsum_growth)) # print(\"self.total_returns_fraction()[0]*0.01\", self.total_returns_fraction()[0]*0.01) # print('std(cumsum_growth)', np.std(cumsum_growth)) # ============================================================================= # trade_return_fraction = (trade_close-trade_open)/trade_open #print('daily_return_amount', daily_return_amount, trade_close-trade_open) #print('trade_return_fraction', trade_return_fraction) #riskfree_rate = np.repeat(riskfree_rate, len(daily_return_amount)) #sharpe_ratio = (self.total_returns_fraction()[0]*0.01 - riskfree_rate) / \\ # np.std(daily_return_amount) sharpe_ratio = ( self . total_returns_fraction ()[ 0 ] * 0.01 - riskfree_rate ) / \\ np . std ( cumsum_growth ) ** 0.5 return sharpe_ratio , '' , 'Sharpe Ratio'","title":"sharpe_ratio"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.total_returns","text":"The total returns given a currency denomanator Parameters: dntr ( str , default: 'USD' ) \u2013 Currency denomanator. The default is 'USD'. Returns: tuple [ float , str , str ] \u2013 total returns, unit, metric name. Source code in EC_tools/portfolio.py 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def total_returns ( self , dntr = 'USD' ) -> tuple [ float , str ]: \"\"\" The total returns given a currency denomanator Parameters ---------- dntr : str, optional Currency denomanator. The default is 'USD'. Returns ------- tuple[float,str,str] total returns, unit, metric name. \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date , dntr = dntr ) last_entry_total_value = self . _portfolio . total_value ( last_date , dntr = dntr ) return ( last_entry_total_value - first_entry_total_value ), dntr , \\ \"Total Returns\"","title":"total_returns"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.total_returns_fraction","text":"The total returns by fraction (percentage). Parameters: unit ( str , default: '%' ) \u2013 Percentage. The default is '%'. Returns: tuple [ float , str ] \u2013 total return Source code in EC_tools/portfolio.py 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 def total_returns_fraction ( self , unit : str = '%' ) -> tuple [ float , str , str ]: \"\"\" The total returns by fraction (percentage). Parameters ---------- unit : str, optional Percentage. The default is '%'. Returns ------- tuple[float,str] total return \"\"\" first_date = self . _portfolio . pool_datetime [ 0 ] last_date = self . _portfolio . pool_datetime [ - 1 ] first_entry_total_value = self . _portfolio . total_value ( first_date ) last_entry_total_value = self . _portfolio . total_value ( last_date ) #print(first_entry_total_value, last_entry_total_value) return 100 * ( last_entry_total_value - first_entry_total_value ) / \\ first_entry_total_value , unit , \"Total Returns\"","title":"total_returns_fraction"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.total_trades","text":"The total number of trades in the tradebook. Source code in EC_tools/portfolio.py 923 924 925 926 927 928 def total_trades ( self ) -> tuple [ int , str , str ]: \"\"\" The total number of trades in the tradebook. \"\"\" return len ( self . tradebook ), '#' , \"Total Trades\"","title":"total_trades"},{"location":"EC_tools/portfolio/#EC_tools.portfolio.PortfolioMetrics.win_rate","text":"The win rate by percentage. Parameters: return_proxy ( str , default: 'Trade_Return' ) \u2013 The column name to query in the tradebook. The default is \"Trade_Return\". unit ( str , default: '%' ) \u2013 The Unit percentage. The default is \"%\". Returns: tuple [ float , str ] \u2013 Win Rate. Source code in EC_tools/portfolio.py 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 def win_rate ( self , return_proxy : str = \"Trade_Return\" , unit : str = \"%\" ) -> \\ tuple [ float , str , str ]: \"\"\" The win rate by percentage. Parameters ---------- return_proxy : str, optional The column name to query in the tradebook. The default is \"Trade_Return\". unit : str, optional The Unit percentage. The default is \"%\". Returns ------- tuple[float,str] Win Rate. \"\"\" win_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i >= 0 ) lose_trades = sum ( 1 for i in self . tradebook [ return_proxy ] . to_list () if i < 0 ) return ( win_trades / ( win_trades + lose_trades )) * 100 , unit , \"Win Rate\"","title":"win_rate"},{"location":"EC_tools/position/","text":"Position Created on Wed May 29 23:49:08 2024 @author: dexter Position Module. ExecutePosition Bases: object A class that execute the position. Source code in EC_tools/position.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class ExecutePosition ( object ): \"\"\" A class that execute the position. \"\"\" def __init__ ( self , Position : Position ): self . position = Position #check if there is a Portfolio attached to the position. if not isinstance ( self . position . portfolio , Portfolio ): raise Exception ( \"The position does not belong to a valid \\ Portfolio.\" ) def fill_pos ( self , fill_time : datetime = datetime . datetime . now (), pos_type : str = 'Long-Buy' ) -> None : \"\"\" Fill position method. Parameters ---------- fill_time : datetime, optional The filling time. The default is datetime.datetime.now(). Raises ------ Exception If the position status is not pending or there are not enough give_obj in the portfolio. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position must be in Pending state to be filled.\" ) # define a delay time so that each entry would not be simultaneous. # simultaneous entry results in fault calculation in the Portfolio method delay_time = datetime . timedelta ( seconds = 0.1 ) if pos_type == 'Long-Buy' : #print('Execute Long-buy position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) #print(self.position.give_obj) # Get the desired asset self . position . portfolio . add ( self . position . get_obj , datetime = fill_time + delay_time ) #print(self.position.get_obj) elif pos_type == 'Long-Sell' : #print('Execute Long-sell position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time ) #print(self.position.get_obj) # Get the desired asset self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time ) #print(self.position.give_obj) elif pos_type == 'Short-Borrow' : #print('Execute Short-Borrow position.') # The sub method does not allow overwithdraw. # Thus assume the give_obj is a {debt} object # Here, assume give_obj = cash, get_obj = asset # Set up the debt object debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) debt_obj [ 'quantity' ] = debt_obj [ 'quantity' ] *- 1 debt_obj [ 'misc' ] = { 'debt' } # The \"Borrow\" action self . position . portfolio . add ( self . position . get_obj , datetime = fill_time ) #actual asset # sell the asset here self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time + delay_time ) # earn the cash here self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time * 2 ) # Issue a debt object for recording the borrowingaction self . position . portfolio . add ( debt_obj , datetime = fill_time + delay_time * 3 ) # debt object elif pos_type == 'Short-Buyback' : #print('Execute Short-Buyback position.') payback_debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) payback_debt_obj [ 'misc' ] = { 'debt' } # normal long # subtract the cash here to buy back the asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) # Get the desired asset the set balance out the debt object # Buyback the debt object to settle the debt automatically self . position . portfolio . add ( payback_debt_obj , datetime = fill_time + delay_time ) # charge a fee if it exits if self . position . fee != None : #or self.position.fee > 0: payment_time = fill_time + delay_time * 10 # Fees are calculated per contracts self . position . portfolio . sub ( self . position . fee , datetime = payment_time ) # change the position status and fill time self . position . status = PositionStatus . FILLED self . position . fill_time = fill_time def cancel_pos ( self , void_time : datetime = datetime . datetime . now ()) -> None : \"\"\" Cancel position method. Parameters ---------- void_time : datetime, optional The cancelling time. The default is datetime.datetime.now(). Raises ------ Exception If the position is not yet added. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position can only be cancelled when it is in \\ the Pending state.\" ) self . position . status = PositionStatus . VOID self . position . void_time = void_time cancel_pos ( void_time = datetime . datetime . now ()) Cancel position method. Parameters: void_time ( datetime , default: now () ) \u2013 The cancelling time. The default is datetime.datetime.now(). Raises: Exception \u2013 If the position is not yet added. Returns: position object \u2013 Source code in EC_tools/position.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def cancel_pos ( self , void_time : datetime = datetime . datetime . now ()) -> None : \"\"\" Cancel position method. Parameters ---------- void_time : datetime, optional The cancelling time. The default is datetime.datetime.now(). Raises ------ Exception If the position is not yet added. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position can only be cancelled when it is in \\ the Pending state.\" ) self . position . status = PositionStatus . VOID self . position . void_time = void_time fill_pos ( fill_time = datetime . datetime . now (), pos_type = 'Long-Buy' ) Fill position method. Parameters: fill_time ( datetime , default: now () ) \u2013 The filling time. The default is datetime.datetime.now(). Raises: Exception \u2013 If the position status is not pending or there are not enough give_obj in the portfolio. Returns: position object \u2013 Source code in EC_tools/position.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def fill_pos ( self , fill_time : datetime = datetime . datetime . now (), pos_type : str = 'Long-Buy' ) -> None : \"\"\" Fill position method. Parameters ---------- fill_time : datetime, optional The filling time. The default is datetime.datetime.now(). Raises ------ Exception If the position status is not pending or there are not enough give_obj in the portfolio. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position must be in Pending state to be filled.\" ) # define a delay time so that each entry would not be simultaneous. # simultaneous entry results in fault calculation in the Portfolio method delay_time = datetime . timedelta ( seconds = 0.1 ) if pos_type == 'Long-Buy' : #print('Execute Long-buy position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) #print(self.position.give_obj) # Get the desired asset self . position . portfolio . add ( self . position . get_obj , datetime = fill_time + delay_time ) #print(self.position.get_obj) elif pos_type == 'Long-Sell' : #print('Execute Long-sell position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time ) #print(self.position.get_obj) # Get the desired asset self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time ) #print(self.position.give_obj) elif pos_type == 'Short-Borrow' : #print('Execute Short-Borrow position.') # The sub method does not allow overwithdraw. # Thus assume the give_obj is a {debt} object # Here, assume give_obj = cash, get_obj = asset # Set up the debt object debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) debt_obj [ 'quantity' ] = debt_obj [ 'quantity' ] *- 1 debt_obj [ 'misc' ] = { 'debt' } # The \"Borrow\" action self . position . portfolio . add ( self . position . get_obj , datetime = fill_time ) #actual asset # sell the asset here self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time + delay_time ) # earn the cash here self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time * 2 ) # Issue a debt object for recording the borrowingaction self . position . portfolio . add ( debt_obj , datetime = fill_time + delay_time * 3 ) # debt object elif pos_type == 'Short-Buyback' : #print('Execute Short-Buyback position.') payback_debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) payback_debt_obj [ 'misc' ] = { 'debt' } # normal long # subtract the cash here to buy back the asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) # Get the desired asset the set balance out the debt object # Buyback the debt object to settle the debt automatically self . position . portfolio . add ( payback_debt_obj , datetime = fill_time + delay_time ) # charge a fee if it exits if self . position . fee != None : #or self.position.fee > 0: payment_time = fill_time + delay_time * 10 # Fees are calculated per contracts self . position . portfolio . sub ( self . position . fee , datetime = payment_time ) # change the position status and fill time self . position . status = PositionStatus . FILLED self . position . fill_time = fill_time Position dataclass Bases: object Position class that create and manage position objects. The position objects tracks the give and get objects and the Source code in EC_tools/position.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 @dataclass class Position ( object ): \"\"\" Position class that create and manage position objects. The position objects tracks the give and get objects and the \"\"\" # key attributes give_obj : dict # Asset get_obj : dict # Asset _price : float status : PositionStatus = PositionStatus . PENDING portfolio : Portfolio = None # optional asset control size : float = 1 fee : dict = None pos_type : str = 'Long-Buy' # position attribute adjustable open_time : datetime = datetime . datetime . now () fill_time : datetime = None void_time : datetime = None auto_adjust : bool = True pos_id : str = util . random_string () #misc: dict = field(default_factory={'None'}) def __post_init__ ( self , void_time : datetime = datetime . datetime . now (), epi : float = 1e-8 ): \"\"\" The post init function that checks if the input price is correct. If it is not. the position is voided. \"\"\" # check if the quantity of both assets are #correct_ratio = self.give_obj.quantity / (self.get_obj.quantity*self.size) # reminder: give is cash, get is asset (usually) correct_ratio = self . give_obj [ 'quantity' ] / ( self . get_obj [ 'quantity' ] * self . size ) #print('correction_ratio', correct_ratio, self.price) # If the price is within the interval of (-epi, +epi) upon the correct ratio # We consider it is equal to the correct ratio self . _check = ( self . _price < correct_ratio + epi ) and \\ ( self . _price > correct_ratio - epi ) #print('Position created. Check:', self._check) #If this value is false, the position is automatically voided. if self . _check == False : self . status = PositionStatus . VOID self . void_time = void_time print ( \"Position voided due to invalid price entry.\" ) # define fix quantity self . _fix_quantity = self . get_obj [ 'quantity' ] @property def fix_quantity ( self ) -> None : \"\"\" This is a speical attribute for each position object. It defines which quantity to be fixed for an exchange to be executed when the price is not exactly as stated in the position object. It can either be self.give_obj.quantity or self.get_obj.quantity. \"\"\" return self . _fix_quantity @fix_quantity . setter def fix_quantity ( self , value : Union [ int , float ]) -> int | float : \"\"\" Setter method to change the value of fix_quantity. Parameters ---------- value : int or float The new fix value. Returns ------- int or float DESCRIPTION. \"\"\" self . _fix_quantity = value return self . _fix_quantity @property def price ( self ) -> float : \"\"\" Getter method for calling position's price. Returns ------- float The price of this exchanges. \"\"\" return self . _price @price . setter def price ( self , value : Union [ int , float ]) -> None : \"\"\" Setter method for calling position's price. \"\"\" # check if the new price is the same if value != self . give_obj [ 'quantity' ] / ( self . get_obj [ 'quantity' ] * self . size ): if self . auto_adjust == True : pass elif self . auto_adjust == False : raise Exception ( \"The new price value does not align with the \\ asset quantities in the position.\" ) # set a new price in the position. self . _price = value # Assuming the give_obj is the one in the portfolio, we anchor the # exchange rate using what we have. So we only changes the quantity in # the get_obj atrribute if self . fix_quantity == self . give_obj [ 'quantity' ]: self . get_obj [ 'quantity' ] = self . give_obj [ 'quantity' ] / ( self . _price * self . size ) elif self . fix_quantity == self . get_obj [ 'quantity' ]: self . give_obj [ 'quantity' ] = self . get_obj [ 'quantity' ] * ( self . _price * self . size ) fix_quantity : None property writable This is a speical attribute for each position object. It defines which quantity to be fixed for an exchange to be executed when the price is not exactly as stated in the position object. It can either be self.give_obj.quantity or self.get_obj.quantity. price : float property writable Getter method for calling position's price. Returns: float \u2013 The price of this exchanges. __post_init__ ( void_time = datetime . datetime . now (), epi = 1e-08 ) The post init function that checks if the input price is correct. If it is not. the position is voided. Source code in EC_tools/position.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __post_init__ ( self , void_time : datetime = datetime . datetime . now (), epi : float = 1e-8 ): \"\"\" The post init function that checks if the input price is correct. If it is not. the position is voided. \"\"\" # check if the quantity of both assets are #correct_ratio = self.give_obj.quantity / (self.get_obj.quantity*self.size) # reminder: give is cash, get is asset (usually) correct_ratio = self . give_obj [ 'quantity' ] / ( self . get_obj [ 'quantity' ] * self . size ) #print('correction_ratio', correct_ratio, self.price) # If the price is within the interval of (-epi, +epi) upon the correct ratio # We consider it is equal to the correct ratio self . _check = ( self . _price < correct_ratio + epi ) and \\ ( self . _price > correct_ratio - epi ) #print('Position created. Check:', self._check) #If this value is false, the position is automatically voided. if self . _check == False : self . status = PositionStatus . VOID self . void_time = void_time print ( \"Position voided due to invalid price entry.\" ) # define fix quantity self . _fix_quantity = self . get_obj [ 'quantity' ] PositionStatus Bases: Enum A set of possible status for positions. Source code in EC_tools/position.py 25 26 27 28 29 30 31 32 class PositionStatus ( Enum ): \"\"\" A set of possible status for positions. \"\"\" PENDING = \"Pending\" # When the position is added but not filled FILLED = \"Filled\" # When the position is executed VOID = \"Cancelled\" # When the position is cancelled PositionType Bases: Enum A set of possible types of positions Source code in EC_tools/position.py 35 36 37 38 39 40 41 42 43 44 45 46 class PositionType ( Enum ): \"\"\" A set of possible types of positions \"\"\" LONG_BUY = 'Long-Buy' LONG_SELL = 'Long-Sell' SHORT_BORROW = 'Short-Borrow' SHORT_BUYBACK = 'Short-Buyback' CALL_BUY = 'Call-Buy' CALL_SELL = 'Call-Sell' PUT_BUY = 'Put-Buy' PUT_SELL = 'Put-Sell'","title":"position"},{"location":"EC_tools/position/#position","text":"Created on Wed May 29 23:49:08 2024 @author: dexter Position Module.","title":"Position"},{"location":"EC_tools/position/#EC_tools.position.ExecutePosition","text":"Bases: object A class that execute the position. Source code in EC_tools/position.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class ExecutePosition ( object ): \"\"\" A class that execute the position. \"\"\" def __init__ ( self , Position : Position ): self . position = Position #check if there is a Portfolio attached to the position. if not isinstance ( self . position . portfolio , Portfolio ): raise Exception ( \"The position does not belong to a valid \\ Portfolio.\" ) def fill_pos ( self , fill_time : datetime = datetime . datetime . now (), pos_type : str = 'Long-Buy' ) -> None : \"\"\" Fill position method. Parameters ---------- fill_time : datetime, optional The filling time. The default is datetime.datetime.now(). Raises ------ Exception If the position status is not pending or there are not enough give_obj in the portfolio. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position must be in Pending state to be filled.\" ) # define a delay time so that each entry would not be simultaneous. # simultaneous entry results in fault calculation in the Portfolio method delay_time = datetime . timedelta ( seconds = 0.1 ) if pos_type == 'Long-Buy' : #print('Execute Long-buy position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) #print(self.position.give_obj) # Get the desired asset self . position . portfolio . add ( self . position . get_obj , datetime = fill_time + delay_time ) #print(self.position.get_obj) elif pos_type == 'Long-Sell' : #print('Execute Long-sell position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time ) #print(self.position.get_obj) # Get the desired asset self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time ) #print(self.position.give_obj) elif pos_type == 'Short-Borrow' : #print('Execute Short-Borrow position.') # The sub method does not allow overwithdraw. # Thus assume the give_obj is a {debt} object # Here, assume give_obj = cash, get_obj = asset # Set up the debt object debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) debt_obj [ 'quantity' ] = debt_obj [ 'quantity' ] *- 1 debt_obj [ 'misc' ] = { 'debt' } # The \"Borrow\" action self . position . portfolio . add ( self . position . get_obj , datetime = fill_time ) #actual asset # sell the asset here self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time + delay_time ) # earn the cash here self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time * 2 ) # Issue a debt object for recording the borrowingaction self . position . portfolio . add ( debt_obj , datetime = fill_time + delay_time * 3 ) # debt object elif pos_type == 'Short-Buyback' : #print('Execute Short-Buyback position.') payback_debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) payback_debt_obj [ 'misc' ] = { 'debt' } # normal long # subtract the cash here to buy back the asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) # Get the desired asset the set balance out the debt object # Buyback the debt object to settle the debt automatically self . position . portfolio . add ( payback_debt_obj , datetime = fill_time + delay_time ) # charge a fee if it exits if self . position . fee != None : #or self.position.fee > 0: payment_time = fill_time + delay_time * 10 # Fees are calculated per contracts self . position . portfolio . sub ( self . position . fee , datetime = payment_time ) # change the position status and fill time self . position . status = PositionStatus . FILLED self . position . fill_time = fill_time def cancel_pos ( self , void_time : datetime = datetime . datetime . now ()) -> None : \"\"\" Cancel position method. Parameters ---------- void_time : datetime, optional The cancelling time. The default is datetime.datetime.now(). Raises ------ Exception If the position is not yet added. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position can only be cancelled when it is in \\ the Pending state.\" ) self . position . status = PositionStatus . VOID self . position . void_time = void_time","title":"ExecutePosition"},{"location":"EC_tools/position/#EC_tools.position.ExecutePosition.cancel_pos","text":"Cancel position method. Parameters: void_time ( datetime , default: now () ) \u2013 The cancelling time. The default is datetime.datetime.now(). Raises: Exception \u2013 If the position is not yet added. Returns: position object \u2013 Source code in EC_tools/position.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def cancel_pos ( self , void_time : datetime = datetime . datetime . now ()) -> None : \"\"\" Cancel position method. Parameters ---------- void_time : datetime, optional The cancelling time. The default is datetime.datetime.now(). Raises ------ Exception If the position is not yet added. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position can only be cancelled when it is in \\ the Pending state.\" ) self . position . status = PositionStatus . VOID self . position . void_time = void_time","title":"cancel_pos"},{"location":"EC_tools/position/#EC_tools.position.ExecutePosition.fill_pos","text":"Fill position method. Parameters: fill_time ( datetime , default: now () ) \u2013 The filling time. The default is datetime.datetime.now(). Raises: Exception \u2013 If the position status is not pending or there are not enough give_obj in the portfolio. Returns: position object \u2013 Source code in EC_tools/position.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def fill_pos ( self , fill_time : datetime = datetime . datetime . now (), pos_type : str = 'Long-Buy' ) -> None : \"\"\" Fill position method. Parameters ---------- fill_time : datetime, optional The filling time. The default is datetime.datetime.now(). Raises ------ Exception If the position status is not pending or there are not enough give_obj in the portfolio. Returns ------- position object \"\"\" # check if the position is Pending if self . position . status == PositionStatus . PENDING : pass else : raise Exception ( \"The position must be in Pending state to be filled.\" ) # define a delay time so that each entry would not be simultaneous. # simultaneous entry results in fault calculation in the Portfolio method delay_time = datetime . timedelta ( seconds = 0.1 ) if pos_type == 'Long-Buy' : #print('Execute Long-buy position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) #print(self.position.give_obj) # Get the desired asset self . position . portfolio . add ( self . position . get_obj , datetime = fill_time + delay_time ) #print(self.position.get_obj) elif pos_type == 'Long-Sell' : #print('Execute Long-sell position.') # Pay pre-existing asset self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time ) #print(self.position.get_obj) # Get the desired asset self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time ) #print(self.position.give_obj) elif pos_type == 'Short-Borrow' : #print('Execute Short-Borrow position.') # The sub method does not allow overwithdraw. # Thus assume the give_obj is a {debt} object # Here, assume give_obj = cash, get_obj = asset # Set up the debt object debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) debt_obj [ 'quantity' ] = debt_obj [ 'quantity' ] *- 1 debt_obj [ 'misc' ] = { 'debt' } # The \"Borrow\" action self . position . portfolio . add ( self . position . get_obj , datetime = fill_time ) #actual asset # sell the asset here self . position . portfolio . sub ( self . position . get_obj , datetime = fill_time + delay_time ) # earn the cash here self . position . portfolio . add ( self . position . give_obj , datetime = fill_time + delay_time * 2 ) # Issue a debt object for recording the borrowingaction self . position . portfolio . add ( debt_obj , datetime = fill_time + delay_time * 3 ) # debt object elif pos_type == 'Short-Buyback' : #print('Execute Short-Buyback position.') payback_debt_obj = self . position . get_obj . copy () #replace(self.position.get_obj) payback_debt_obj [ 'misc' ] = { 'debt' } # normal long # subtract the cash here to buy back the asset self . position . portfolio . sub ( self . position . give_obj , datetime = fill_time ) # Get the desired asset the set balance out the debt object # Buyback the debt object to settle the debt automatically self . position . portfolio . add ( payback_debt_obj , datetime = fill_time + delay_time ) # charge a fee if it exits if self . position . fee != None : #or self.position.fee > 0: payment_time = fill_time + delay_time * 10 # Fees are calculated per contracts self . position . portfolio . sub ( self . position . fee , datetime = payment_time ) # change the position status and fill time self . position . status = PositionStatus . FILLED self . position . fill_time = fill_time","title":"fill_pos"},{"location":"EC_tools/position/#EC_tools.position.Position","text":"Bases: object Position class that create and manage position objects. The position objects tracks the give and get objects and the Source code in EC_tools/position.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 @dataclass class Position ( object ): \"\"\" Position class that create and manage position objects. The position objects tracks the give and get objects and the \"\"\" # key attributes give_obj : dict # Asset get_obj : dict # Asset _price : float status : PositionStatus = PositionStatus . PENDING portfolio : Portfolio = None # optional asset control size : float = 1 fee : dict = None pos_type : str = 'Long-Buy' # position attribute adjustable open_time : datetime = datetime . datetime . now () fill_time : datetime = None void_time : datetime = None auto_adjust : bool = True pos_id : str = util . random_string () #misc: dict = field(default_factory={'None'}) def __post_init__ ( self , void_time : datetime = datetime . datetime . now (), epi : float = 1e-8 ): \"\"\" The post init function that checks if the input price is correct. If it is not. the position is voided. \"\"\" # check if the quantity of both assets are #correct_ratio = self.give_obj.quantity / (self.get_obj.quantity*self.size) # reminder: give is cash, get is asset (usually) correct_ratio = self . give_obj [ 'quantity' ] / ( self . get_obj [ 'quantity' ] * self . size ) #print('correction_ratio', correct_ratio, self.price) # If the price is within the interval of (-epi, +epi) upon the correct ratio # We consider it is equal to the correct ratio self . _check = ( self . _price < correct_ratio + epi ) and \\ ( self . _price > correct_ratio - epi ) #print('Position created. Check:', self._check) #If this value is false, the position is automatically voided. if self . _check == False : self . status = PositionStatus . VOID self . void_time = void_time print ( \"Position voided due to invalid price entry.\" ) # define fix quantity self . _fix_quantity = self . get_obj [ 'quantity' ] @property def fix_quantity ( self ) -> None : \"\"\" This is a speical attribute for each position object. It defines which quantity to be fixed for an exchange to be executed when the price is not exactly as stated in the position object. It can either be self.give_obj.quantity or self.get_obj.quantity. \"\"\" return self . _fix_quantity @fix_quantity . setter def fix_quantity ( self , value : Union [ int , float ]) -> int | float : \"\"\" Setter method to change the value of fix_quantity. Parameters ---------- value : int or float The new fix value. Returns ------- int or float DESCRIPTION. \"\"\" self . _fix_quantity = value return self . _fix_quantity @property def price ( self ) -> float : \"\"\" Getter method for calling position's price. Returns ------- float The price of this exchanges. \"\"\" return self . _price @price . setter def price ( self , value : Union [ int , float ]) -> None : \"\"\" Setter method for calling position's price. \"\"\" # check if the new price is the same if value != self . give_obj [ 'quantity' ] / ( self . get_obj [ 'quantity' ] * self . size ): if self . auto_adjust == True : pass elif self . auto_adjust == False : raise Exception ( \"The new price value does not align with the \\ asset quantities in the position.\" ) # set a new price in the position. self . _price = value # Assuming the give_obj is the one in the portfolio, we anchor the # exchange rate using what we have. So we only changes the quantity in # the get_obj atrribute if self . fix_quantity == self . give_obj [ 'quantity' ]: self . get_obj [ 'quantity' ] = self . give_obj [ 'quantity' ] / ( self . _price * self . size ) elif self . fix_quantity == self . get_obj [ 'quantity' ]: self . give_obj [ 'quantity' ] = self . get_obj [ 'quantity' ] * ( self . _price * self . size )","title":"Position"},{"location":"EC_tools/position/#EC_tools.position.Position.fix_quantity","text":"This is a speical attribute for each position object. It defines which quantity to be fixed for an exchange to be executed when the price is not exactly as stated in the position object. It can either be self.give_obj.quantity or self.get_obj.quantity.","title":"fix_quantity"},{"location":"EC_tools/position/#EC_tools.position.Position.price","text":"Getter method for calling position's price. Returns: float \u2013 The price of this exchanges.","title":"price"},{"location":"EC_tools/position/#EC_tools.position.Position.__post_init__","text":"The post init function that checks if the input price is correct. If it is not. the position is voided. Source code in EC_tools/position.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __post_init__ ( self , void_time : datetime = datetime . datetime . now (), epi : float = 1e-8 ): \"\"\" The post init function that checks if the input price is correct. If it is not. the position is voided. \"\"\" # check if the quantity of both assets are #correct_ratio = self.give_obj.quantity / (self.get_obj.quantity*self.size) # reminder: give is cash, get is asset (usually) correct_ratio = self . give_obj [ 'quantity' ] / ( self . get_obj [ 'quantity' ] * self . size ) #print('correction_ratio', correct_ratio, self.price) # If the price is within the interval of (-epi, +epi) upon the correct ratio # We consider it is equal to the correct ratio self . _check = ( self . _price < correct_ratio + epi ) and \\ ( self . _price > correct_ratio - epi ) #print('Position created. Check:', self._check) #If this value is false, the position is automatically voided. if self . _check == False : self . status = PositionStatus . VOID self . void_time = void_time print ( \"Position voided due to invalid price entry.\" ) # define fix quantity self . _fix_quantity = self . get_obj [ 'quantity' ]","title":"__post_init__"},{"location":"EC_tools/position/#EC_tools.position.PositionStatus","text":"Bases: Enum A set of possible status for positions. Source code in EC_tools/position.py 25 26 27 28 29 30 31 32 class PositionStatus ( Enum ): \"\"\" A set of possible status for positions. \"\"\" PENDING = \"Pending\" # When the position is added but not filled FILLED = \"Filled\" # When the position is executed VOID = \"Cancelled\" # When the position is cancelled","title":"PositionStatus"},{"location":"EC_tools/position/#EC_tools.position.PositionType","text":"Bases: Enum A set of possible types of positions Source code in EC_tools/position.py 35 36 37 38 39 40 41 42 43 44 45 46 class PositionType ( Enum ): \"\"\" A set of possible types of positions \"\"\" LONG_BUY = 'Long-Buy' LONG_SELL = 'Long-Sell' SHORT_BORROW = 'Short-Borrow' SHORT_BUYBACK = 'Short-Buyback' CALL_BUY = 'Call-Buy' CALL_SELL = 'Call-Sell' PUT_BUY = 'Put-Buy' PUT_SELL = 'Put-Sell'","title":"PositionType"},{"location":"EC_tools/read/","text":"read Created on Tue Apr 2 14:09:54 2024 @author: dexter The read module contains handy functions related reading and reformating raw data. It also contains some relevant function in mainpulating data or deriving new information from the raw data. concat_CSVtable ( filename_list , sort_by = 'Date' ) Concatenate CSV tables. Parameters: filename_list ( list ) \u2013 A list of CSV filename. sort_by ( str , default: 'Date' ) \u2013 The column name in which the dataframe is sorted. The default is 'Date'. Returns: master_table ( dataframe ) \u2013 The resulting table. Source code in EC_tools/read.py 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 def concat_CSVtable ( filename_list : list [ str ], sort_by : str = 'Date' ) -> pd . DataFrame : \"\"\" Concatenate CSV tables. Parameters ---------- filename_list : list A list of CSV filename. sort_by : str, optional The column name in which the dataframe is sorted. The default is 'Date'. Returns ------- master_table : dataframe The resulting table. \"\"\" master_table = pd . DataFrame () for filename in filename_list : temp = pd . read_csv ( filename ) master_table = pd . concat ([ master_table , temp ]) master_table . sort_values ( by = sort_by , inplace = True ) return master_table extract_lag_data ( signal_data , history_data , date , lag_size = 5 , time_proxy = 'PERIOD' ) Extract the Lag data based on a given date. Parameters: signal_data ( pandas dataframe ) \u2013 The signal data. history_data ( pandas dataframe ) \u2013 The historical data. date ( str ) \u2013 The date of interest, format like this \"2024-01-10\". lag_size ( int , default: 5 ) \u2013 The size of the lag window. The default is 5 (days). Returns: signal_data_lag ( pandas data frame ) \u2013 The signal data five (lag_size) days prior to the given date. history_data_lag ( pandas data frame ) \u2013 The historical data five (lag_size) days prior to the given date. Source code in EC_tools/read.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 def extract_lag_data ( signal_data : pd . DataFrame , history_data : pd . DataFrame , date : str , lag_size : int = 5 , time_proxy = \"PERIOD\" ) -> \\ tuple [ pd . DataFrame , pd . DataFrame ]: \"\"\" Extract the Lag data based on a given date. Parameters ---------- signal_data : pandas dataframe The signal data. history_data : pandas dataframe The historical data. date : str The date of interest, format like this \"2024-01-10\". lag_size : int, optional The size of the lag window. The default is 5 (days). Returns ------- signal_data_lag : pandas data frame The signal data five (lag_size) days prior to the given date. history_data_lag : pandas data frame The historical data five (lag_size) days prior to the given date. \"\"\" # Find the row index of the history data first #row_index = history_data.index[history_data['Date'] == date].tolist()[0] row_index = history_data . index [ history_data [ 'Date' ] == date ] . item () #lag_days = datetime.timedelta(days=lag_size) #lag5days = row_index-lag_days #lag1day = row_index - datetime.timedelta(days=1) # extract exactly 5 (default) lag days array history_data_lag = history_data . loc [ row_index - lag_size : row_index - 1 ] # history_data_lag = history_data.loc[lag5days:lag1day] # use the relevant date from history data to get signal data to ensure matching date window = history_data_lag [ 'Date' ] . tolist () # turn Timstamp into string #window = [str(window[i])[0:10] for i in range(lag_size)] #Store the lag signal data in a list #signal_data_lag = signal_data[signal_data['Forecast Period'] == window[0]] signal_data_lag = signal_data [ signal_data [ time_proxy ] == window [ 0 ]] for i in range ( lag_size - 1 ): curve = signal_data [ signal_data [ time_proxy ] == window [ i + 1 ]] signal_data_lag = pd . concat ([ signal_data_lag , curve ]) return signal_data_lag , history_data_lag find_closest_price ( day_minute_data , target_hr = '0330' , direction = 'forward' , price_proxy = 'Open' , time_proxy = 'Time' , step = 1 , search_time = 1000 ) A method to find the closest price next to a traget hour Parameters: day_minute_data ( DataFrame ) \u2013 The minute pricing data. target_hr ( str , default: '0330' ) \u2013 The target hour for the search. The default is '0330'. direction ( dtr , default: 'forward' ) \u2013 To search the list either 'backward' or 'forward'. The default is 'forward'. step ( int , default: 1 ) \u2013 The step size of the search. The default is 1. search_time ( int , default: 1000 ) \u2013 The total minutes (steps) of the search. The default is 1000. Returns: target_hr_dt ( datetime ) \u2013 The datetime of the closest hour to the target. float \u2013 The target price. Source code in EC_tools/read.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 def find_closest_price ( day_minute_data : pd . DataFrame , target_hr : str = '0330' , direction : str = 'forward' , price_proxy : str = 'Open' , time_proxy : str = 'Time' , step : int = 1 , search_time : int = 1000 ) -> \\ tuple [ datetime . datetime , float ]: \"\"\" A method to find the closest price next to a traget hour Parameters ---------- day_minute_data : DataFrame The minute pricing data. target_hr : str, optional The target hour for the search. The default is '0330'. direction : dtr, optional To search the list either 'backward' or 'forward'. The default is 'forward'. step : int, optional The step size of the search. The default is 1. search_time : int, optional The total minutes (steps) of the search. The default is 1000. Returns ------- target_hr_dt : datetime.datetime The datetime of the closest hour to the target. float The target price. \"\"\" # If the input is forward, the loop search forward a unit of minute (step) if direction == 'forward' : step = 1. * step # If the input is backward, the loop search back a unit of minute (step) elif direction == 'backward' : step = - 1 * step target_hr_dt = datetime . time ( hour = int ( target_hr [ 0 : 2 ]), minute = int ( target_hr [ 2 : 4 ])) #initial estimation of the target price target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] #loop through the next 30 minutes to find the opening price for i in range ( search_time ): if len ( target_price ) == 0 : delta = datetime . timedelta ( minutes = step ) # Note that the datetime.datetime.today() is a place holder, it does # not affect the target_hr_dt vatriables. target_hr_dt = ( datetime . datetime . combine ( datetime . datetime . today (), target_hr_dt ) + delta ) . time () #print(i, target_hr_dt) target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] target_price = [ float ( target_price . iloc [ 0 ])] # make sure that this is float return target_hr_dt , target_price [ 0 ] find_closest_price_datetime ( day_minute_data , target_date , target_hr = '0330' , direction = 'forward' , price_proxy = 'Open' , time_proxy = 'Time' , date_proxy = 'Date' , step = 1 , search_time = 1000 ) A method to find the closest price next to a traget date and hour Parameters: day_minute_data ( DataFrame ) \u2013 The minute pricing data. target_hr ( str , default: '0330' ) \u2013 The target hour for the search. The default is '0330'. direction ( dtr , default: 'forward' ) \u2013 To search the list either 'backward' or 'forward'. The default is 'forward'. step ( int , default: 1 ) \u2013 The step size of the search. The default is 1. search_time ( int , default: 1000 ) \u2013 The total minutes (steps) of the search. The default is 1000. Returns: target_hr_dt ( datetime ) \u2013 The datetime of the closest hour to the target. float \u2013 The target price. Source code in EC_tools/read.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 @util . time_it def find_closest_price_datetime ( day_minute_data : pd . DataFrame , target_date : datetime . datetime , target_hr : str = '0330' , direction : str = 'forward' , price_proxy : str = 'Open' , time_proxy : str = 'Time' , date_proxy : str = 'Date' , step : int = 1 , search_time : int = 1000 ) -> \\ tuple [ datetime . datetime , float ]: \"\"\" A method to find the closest price next to a traget date and hour Parameters ---------- day_minute_data : DataFrame The minute pricing data. target_hr : str, optional The target hour for the search. The default is '0330'. direction : dtr, optional To search the list either 'backward' or 'forward'. The default is 'forward'. step : int, optional The step size of the search. The default is 1. search_time : int, optional The total minutes (steps) of the search. The default is 1000. Returns ------- target_hr_dt : datetime.datetime The datetime of the closest hour to the target. float The target price. \"\"\" # If the input is forward, the loop search forward a unit of minute (step) if direction == 'forward' : step = 1. * step # If the input is backward, the loop search back a unit of minute (step) elif direction == 'backward' : step = - 1 * step target_hr_dt = datetime . time ( hour = int ( target_hr [ 0 : 2 ]), minute = int ( target_hr [ 2 : 4 ])) day_minute_data = day_minute_data [ day_minute_data [ date_proxy ] == target_date ] print ( target_date , day_minute_data ) #initial estimation of the target price target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] #loop through the next 30 minutes to find the opening price for i in range ( search_time ): if len ( target_price ) == 0 : delta = datetime . timedelta ( minutes = step ) # Note that the datetime.datetime.today() is a place holder, it does # not affect the target_hr_dt vatriables. target_hr_dt = ( datetime . datetime . combine ( datetime . datetime . today (), target_hr_dt ) + delta ) . time () #print(i, target_hr_dt) target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] print ( target_price ) target_price = [ float ( target_price . iloc [ 0 ])] # make sure that this is float return target_hr_dt , target_price [ 0 ] find_crossover ( input_array , threshold ) A function that find the crossover points' indicies. It finds the points right after either rise above, or drop below the threshold value. Parameters: input_array ( numpy array ) \u2013 A 1D numpy array with only numbers. threshold ( float, list, numpy array ) \u2013 the threshold value. Returns: dict \u2013 The 'rise' value contains a numpy array containing the indicies of points that rise above the the threshold. The 'drop' value contains a numpy array containing the indicies of points that drop below the the threshold. Source code in EC_tools/read.py 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 def find_crossover ( input_array : np . ndarray , threshold : float | list [ float | int ] | np . ndarray ) -> dict : \"\"\" A function that find the crossover points' indicies. It finds the points right after either rise above, or drop below the threshold value. Parameters ---------- input_array : numpy array A 1D numpy array with only numbers. threshold : float, list, numpy array the threshold value. Returns ------- dict The 'rise' value contains a numpy array containing the indicies of points that rise above the the threshold. The 'drop' value contains a numpy array containing the indicies of points that drop below the the threshold. \"\"\" if type ( threshold ) == float : # make a numpy array of the threshold value threshold = np . repeat ( threshold , len ( input_array )) elif ( type ( threshold ) == list or type ( threshold ) == np . ndarray ) and \\ len ( threshold ) != len ( input_array ): raise Exception ( \"Mismatch input and threshold arraty length.\" ) elif type ( threshold ) == list and len ( threshold ) == len ( input_array ): # make a numpy array of the threshold value threshold = np . array ( threshold ) elif type ( threshold ) == np . ndarray and len ( threshold ) == len ( input_array ): pass # The difference between the input value and the threshold number # Positive values mean the input is higher than threshold # Negative values mean the input is lower than threshold delta = input_array - threshold # This is an array 1 unit in the past delta_lag = np . concatenate ([ np . array ([ np . nan ]), delta ])[: - 1 ] # IF delta[i] > delta_lag[i], then the price rise above threshold # Because all elements are either +1, -1 or 0, the larger value has to be +1. # np.sign(delta) = +1, while np.sign(delta_lag) = -1 means yesterday the value # is lower than threshold and today's value is higher than the threshold-> rise above indices_rise_above = np . where ( np . sign ( delta ) > np . sign ( delta_lag )) # IF delta[i] < delta_lag[i], then the price drop below threshold indices_drop_below = np . where ( np . sign ( delta ) < np . sign ( delta_lag )) # Produce a dic of indicies for below and above return { 'rise' : indices_rise_above , 'drop' : indices_drop_below } find_minute_EES ( histroy_data_intraday , target_entry , target_exit , stop_exit , open_hr = '0330' , close_hr = '1930' , price_proxy = 'Open' , time_proxy = 'Time' , date_proxy = 'Date' , direction = 'Neutral' , close_trade_hr = '1925' , dt_scale = 'datetime' ) Find the points of crossover given a set of EES value in a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters: histroy_data_intraday ( dataframe ) \u2013 The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry ( float ) \u2013 target entry price. target_exit ( float ) \u2013 target exit price. stop_exit ( float ) \u2013 target stop loss price. open_hr ( str , default: '0330' ) \u2013 The opening hour of trade in military time format. The default is \"0330\". close_hr ( str , default: '1930' ) \u2013 The closing hour of trade in military time format. The default is \"1930\". price_proxy ( str , default: 'Open' ) \u2013 The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox \u2013 The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction ( str , default: 'Neutral' ) \u2013 Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr ( str , default: '1925' ) \u2013 The final minute to finish off the trade in military time format. The default is '1925'. dt_scale ( str , default: 'datetime' ) \u2013 Raises: ValueError \u2013 Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns: EES_dict ( dict ) \u2013 A dictionary that cantains the possible EES points and time. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} Source code in EC_tools/read.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 def find_minute_EES ( histroy_data_intraday : pd . DataFrame , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0330\" , close_hr : str = \"1930\" , price_proxy : str = 'Open' , time_proxy : str = 'Time' , date_proxy : str = 'Date' , direction : str = 'Neutral' , close_trade_hr : str = '1925' , dt_scale : str = 'datetime' ) -> dict : \"\"\" Find the points of crossover given a set of EES value in a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters ---------- histroy_data_intraday : dataframe The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry : float target entry price. target_exit : float target exit price. stop_exit : float target stop loss price. open_hr : str, optional The opening hour of trade in military time format. The default is \"0330\". close_hr : str, optional The closing hour of trade in military time format. The default is \"1930\". price_proxy : str, optional The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox: The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction : str, optional Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr : str, optional The final minute to finish off the trade in military time format. The default is '1925'. dt_scale : Raises ------ ValueError Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns ------- EES_dict : dict A dictionary that cantains the possible EES points and time. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} \"\"\" # (This function can be made in one more layer of abstraction. Work on this later) # define subsample. turn the pandas series into a numpy array price_list = histroy_data_intraday [ price_proxy ] . to_numpy () time_list = histroy_data_intraday [ time_proxy ] . to_numpy () #print(\"time_list\", time_list[0], type(time_list[0])) # read in date list date_list = histroy_data_intraday [ date_proxy ] . to_numpy () # Temporary solution. Can be made using two to three time layer # make datetime list datetime_list = np . array ([ datetime . datetime . combine ( pd . to_datetime ( d ) . date (), t ) \\ for d , t in zip ( date_list , time_list )]) if dt_scale == \"time\" : time_proxy_list = time_list elif dt_scale == 'date' : time_proxy_list = date_list elif dt_scale == 'datetime' : time_proxy_list = datetime_list # Find the crossover indices entry_pt_dict = find_crossover ( price_list , target_entry ) exit_pt_dict = find_crossover ( price_list , target_exit ) stop_pt_dict = find_crossover ( price_list , stop_exit ) if direction == \"Neitral\" : #print(\"Neutral day\") # for 'Neutral' action, all info are empty entry_pts , entry_times = [], [] exit_pts , exit_times = [], [] stop_pts , stop_times = [], [] elif direction == \"Buy\" : #print(\"Finding Buy points.\") # for 'Buy' action EES sequence is drop,rise,drop entry_pts = price_list [ entry_pt_dict [ 'drop' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'drop' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'rise' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'rise' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'drop' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'drop' ][ 0 ]] elif direction == \"Sell\" : #print(\"Finding Sell points.\") # for 'Sell' action EES sequence is rise,drop,rise entry_pts = price_list [ entry_pt_dict [ 'rise' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'rise' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'drop' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'drop' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'rise' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'rise' ][ 0 ]] else : raise ValueError ( 'Direction has to be either Buy, Sell, or Neutral.' ) # Define the opening/closing time and closing price. # Here we choose 19:25 for final trade open_hr_str = open_hr . strftime ( \"%H%M\" ) close_hr_str = close_hr . strftime ( \"%H%M\" ) ## Find the closest price and datettime instead of having it at exactly the open time open_date_new , open_pt = find_closest_price ( histroy_data_intraday , target_hr = open_hr_str , direction = 'forward' , price_proxy = price_proxy , time_proxy = time_proxy ) open_date = date_list [ np . where ( time_list == open_date_new )[ 0 ]][ 0 ] open_datetime = datetime . datetime . combine ( pd . to_datetime ( open_date ) . date (), open_date_new ) # Find the closest price and datettime instead of having it at exactly the close time close_date_new , close_pt = find_closest_price ( histroy_data_intraday , target_hr = close_hr_str , direction = 'backward' , price_proxy = price_proxy , time_proxy = time_proxy ) close_date = date_list [ np . where ( time_list == close_date_new )[ 0 ]][ 0 ] close_datetime = datetime . datetime . combine ( pd . to_datetime ( close_date ) . date (), close_date_new ) # storage EES_dict = { 'entry' : list ( zip ( entry_times , entry_pts )), 'exit' : list ( zip ( exit_times , exit_pts )), 'stop' : list ( zip ( stop_times , stop_pts )), 'open' : tuple (( open_datetime , open_pt )), 'close' : tuple (( close_datetime , close_pt ))} #print('EES_dict', EES_dict['close']) return EES_dict find_minute_EES_long ( histroy_data , target_entry , target_exit , stop_exit , open_hr = '0330' , close_hr = '1930' , price_proxy = 'Open' , time_proxy = 'Time' , date_proxy = 'Date' , direction = 'Neutral' , close_trade_hr = '1925' , dt_scale = 'datetime' , first_date = None , last_date = None ) Set the EES value given a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters: histroy_data_intraday ( dataframe ) \u2013 The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry ( float ) \u2013 target entry price. target_exit ( float ) \u2013 target exit price. stop_exit ( float ) \u2013 target stop loss price. open_hr ( str , default: '0330' ) \u2013 The opening hour of trade in military time format. The default is \"0330\". close_hr ( str , default: '1930' ) \u2013 The closing hour of trade in military time format. The default is \"1930\". price_approx ( str ) \u2013 The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox \u2013 The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction ( str , default: 'Neutral' ) \u2013 Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr ( str , default: '1925' ) \u2013 The final minute to finish off the trade in military time format. The default is '1925'. dt_scale ( str , default: 'datetime' ) \u2013 Raises: ValueError \u2013 Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns: EES_dict ( dict ) \u2013 A dictionary that cantains the possible EES points and time. Source code in EC_tools/read.py 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 def find_minute_EES_long ( histroy_data : pd . DataFrame , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0330\" , close_hr : str = \"1930\" , price_proxy : str = 'Open' , time_proxy : str = 'Time' , date_proxy : str = 'Date' , direction : str = 'Neutral' , close_trade_hr : str = '1925' , dt_scale : str = 'datetime' , first_date = None , last_date = None ) -> dict : \"\"\" Set the EES value given a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters ---------- histroy_data_intraday : dataframe The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry : float target entry price. target_exit : float target exit price. stop_exit : float target stop loss price. open_hr : str, optional The opening hour of trade in military time format. The default is \"0330\". close_hr : str, optional The closing hour of trade in military time format. The default is \"1930\". price_approx : str, optional The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox: The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction : str, optional Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr : str, optional The final minute to finish off the trade in military time format. The default is '1925'. dt_scale : Raises ------ ValueError Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns ------- EES_dict : dict A dictionary that cantains the possible EES points and time. \"\"\" # (This function can be made in one more layer of abstraction. Work on this later) if first_date == None : first_date = histroy_data [ date_proxy ] . iloc [ 0 ] if last_date == None : last_date = histroy_data [ date_proxy ] . iloc [ - 1 ] print ( 'first_date, last_date' , first_date , last_date ) # define subsample. turn the pandas series into a numpy array price_list = histroy_data [ price_proxy ] . to_numpy () time_list = histroy_data [ time_proxy ] . to_numpy () # read in date list date_list = histroy_data [ date_proxy ] . to_numpy () # Temporary solution. Can be made using two to three time layer # make datetime list datetime_list = np . array ([ datetime . datetime . combine ( pd . to_datetime ( d ) . date (), t ) \\ for d , t in zip ( date_list , time_list )]) if dt_scale == \"time\" : time_proxy_list = time_list elif dt_scale == 'date' : time_proxy_list = date_list elif dt_scale == 'datetime' : time_proxy_list = datetime_list # Find the crossover indices entry_pt_dict = find_crossover ( price_list , target_entry ) exit_pt_dict = find_crossover ( price_list , target_exit ) stop_pt_dict = find_crossover ( price_list , stop_exit ) if direction == \"Neitral\" : #print(\"Neutral day\") # for 'Neutral' action, all info are empty entry_pts , entry_times = [], [] exit_pts , exit_times = [], [] stop_pts , stop_times = [], [] elif direction == \"Buy\" : #print(\"Finding Buy points.\") # for 'Buy' action EES sequence is drop,rise,drop entry_pts = price_list [ entry_pt_dict [ 'drop' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'drop' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'rise' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'rise' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'drop' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'drop' ][ 0 ]] elif direction == \"Sell\" : #print(\"Finding Sell points.\") # for 'Sell' action EES sequence is rise,drop,rise entry_pts = price_list [ entry_pt_dict [ 'rise' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'rise' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'drop' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'drop' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'rise' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'rise' ][ 0 ]] else : raise ValueError ( 'Direction has to be either Buy, Sell, or Neutral.' ) # Define the opening/closing time and closing price. first_date_str = first_date . strftime ( \"%y-%m- %d \" ) last_date_str = last_date . strftime ( \"%y-%m- %d \" ) # Here we choose 19:25 for final trade open_hr_str = open_hr . strftime ( \"%H%M\" ) close_hr_str = close_hr . strftime ( \"%H%M\" ) ## Find the closest price and datettime instead of having it at exactly the open time open_date_new , open_pt = find_closest_price_datetime ( histroy_data , target_date = first_date , target_hr = open_hr_str , price_proxy = price_proxy , direction = 'forward' ) #open_date = date_list[np.where(time_list==open_date_new)[0]][0] open_date = datetime_list [ 0 ] open_datetime = datetime . datetime . combine ( open_date . date (), open_date_new ) # Find the closest price and datettime instead of having it at exactly the close time close_date_new , close_pt = find_closest_price_datetime ( histroy_data , target_date = last_date , target_hr = close_hr_str , price_proxy = price_proxy , direction = 'backward' ) #close_date = date_list[np.where(time_list==close_date_new)[0]][0] close_date = datetime_list [ - 1 ] close_datetime = datetime . datetime . combine ( close_date . date (), close_date_new ) # storage EES_dict = { 'entry' : list ( zip ( entry_times , entry_pts )), 'exit' : list ( zip ( exit_times , exit_pts )), 'stop' : list ( zip ( stop_times , stop_pts )), 'open' : tuple (( open_datetime , open_pt )), 'close' : tuple (( close_datetime , close_pt ))} print ( 'EES_dict' , EES_dict ) return EES_dict find_minute_EES_range ( histroy_data_intraday , target_entry_range , target_exit_range , stop_exit , open_hr = '0330' , close_hr = '1930' , price_proxy = 'Open' , date_proxy = 'Date' , time_proxy = 'Time' , direction = 'Neutral' , dt_scale = 'datetime' ) Find the points within a range of EES value in a time-series of minute intrday data. This function is the key for range loop in backtesting. Parameters: histroy_data_intraday ( DataFrame ) \u2013 The historical data. target_entry_range ( list [ float | int ] | tuple [ float | int ] ) \u2013 A range of entry price in the format of [lower_bound_price, upper_bound_price]. target_exit_range ( list [ float | int ] | tuple [ float | int ] ) \u2013 A range of exit price in the format of [lower_bound_price, upper_bound_price]. stop_exit ( float | int ) \u2013 The stop loss value. open_hr ( str , default: '0330' ) \u2013 The opening hour. The default is \"0330\". close_hr ( str , default: '1930' ) \u2013 The closing hour. The default is \"1930\". price_proxy ( str , default: 'Open' ) \u2013 The column name for the price. The default is 'Open'. time_proxy ( str , default: 'Time' ) \u2013 The column name for the time. The default is 'Time'. direction ( str , default: 'Neutral' ) \u2013 The direction of the trade. The default is 'Neutral'. dt_scale ( str , default: 'datetime' ) \u2013 datetime scale. It could be either 'time', 'date', or 'datetime'. It choose from either the time or date columns, or combine the two into datetime. The default is 'datetime'. Returns: range_dict ( TYPE ) \u2013 A dictionary contianing the points in a day that falls within the entry and exit range, as well as points that crossover to the stoploss, along with the open and close points of the day. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} Source code in EC_tools/read.py 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 def find_minute_EES_range ( histroy_data_intraday : pd . DataFrame , target_entry_range : list [ float | int ] | tuple [ float | int ], target_exit_range : list [ float | int ] | tuple [ float | int ], stop_exit : float | int , open_hr : str = \"0330\" , close_hr : str = \"1930\" , price_proxy : str = 'Open' , date_proxy : str = 'Date' , time_proxy : str = 'Time' , direction : str = 'Neutral' , dt_scale : str = 'datetime' ) -> dict [ str , list | tuple ]: \"\"\" Find the points within a range of EES value in a time-series of minute intrday data. This function is the key for range loop in backtesting. Parameters ---------- histroy_data_intraday : pd.DataFrame The historical data. target_entry_range : list[float|int] | tuple[float|int] A range of entry price in the format of [lower_bound_price, upper_bound_price]. target_exit_range : list[float|int] | tuple[float|int] A range of exit price in the format of [lower_bound_price, upper_bound_price]. stop_exit : float | int The stop loss value. open_hr : str, optional The opening hour. The default is \"0330\". close_hr : str, optional The closing hour. The default is \"1930\". price_proxy : str, optional The column name for the price. The default is 'Open'. time_proxy : str, optional The column name for the time. The default is 'Time'. direction : str, optional The direction of the trade. The default is 'Neutral'. dt_scale : str, optional datetime scale. It could be either 'time', 'date', or 'datetime'. It choose from either the time or date columns, or combine the two into datetime. The default is 'datetime'. Returns ------- range_dict : TYPE A dictionary contianing the points in a day that falls within the entry and exit range, as well as points that crossover to the stoploss, along with the open and close points of the day. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} \"\"\" # define subsample. turn the pandas series into a numpy array price_array = histroy_data_intraday [ price_proxy ] . to_numpy () time_array = histroy_data_intraday [ time_proxy ] . to_numpy () # read in date list date_array = histroy_data_intraday [ date_proxy ] . to_numpy () # Temporary solution. Can be made using two to three time layer # make datetime list datetime_array = np . array ([ datetime . datetime . combine ( pd . to_datetime ( d ) . date (), t ) \\ for d , t in zip ( date_array , time_array )]) if dt_scale == \"time\" : time_proxy_array = time_array elif dt_scale == 'date' : time_proxy_array = date_array elif dt_scale == 'datetime' : time_proxy_array = datetime_array # Find the crossover indices entry_region_dict = find_range ( price_array , target_entry_range ) exit_region_dict = find_range ( price_array , target_exit_range ) # Stop loss find crossover stop_pt_dict = find_crossover ( price_array , stop_exit ) if direction == \"Neitral\" : # for 'Neutral' action, all info are empty entry_pts , entry_times = [], [] exit_pts , exit_times = [], [] stop_pts , stop_times = [], [] elif direction == \"Buy\" : #print(\"Finding Buy points.\") # for 'Buy' action EES sequence is drop,rise,drop entry_pts = price_array [ entry_region_dict [ 'range_indices' ][ 0 ]] entry_times = time_proxy_array [ entry_region_dict [ 'range_indices' ][ 0 ]] exit_pts = price_array [ exit_region_dict [ 'range_indices' ][ 0 ]] exit_times = time_proxy_array [ exit_region_dict [ 'range_indices' ][ 0 ]] stop_pts = price_array [ stop_pt_dict [ 'drop' ][ 0 ]] stop_times = time_proxy_array [ stop_pt_dict [ 'drop' ][ 0 ]] elif direction == \"Sell\" : #print(\"Finding Sell points.\") # for 'Sell' action EES sequence is rise,drop,rise entry_pts = price_array [ entry_region_dict [ 'range_indices' ][ 0 ]] entry_times = time_proxy_array [ entry_region_dict [ 'range_indices' ][ 0 ]] exit_pts = price_array [ exit_region_dict [ 'range_indices' ][ 0 ]] exit_times = time_proxy_array [ exit_region_dict [ 'range_indices' ][ 0 ]] stop_pts = price_array [ stop_pt_dict [ 'rise' ][ 0 ]] stop_times = time_proxy_array [ stop_pt_dict [ 'rise' ][ 0 ]] # Define the closing time and closing price. Here we choose 19:25 for final trade open_hr_str = open_hr . strftime ( \"%H%M\" ) close_hr_str = close_hr . strftime ( \"%H%M\" ) ## Find the closest price and datettime instead of having it at exactly the open time open_date_new , open_pt = find_closest_price ( histroy_data_intraday , target_hr = open_hr_str , direction = 'forward' ) open_date = date_array [ np . where ( time_array == open_date_new )[ 0 ]][ 0 ] open_datetime = datetime . datetime . combine ( pd . to_datetime ( open_date ) . date (), open_date_new ) ## Find the closest price and datettime instead of having it at exactly the close time close_date_new , close_pt = find_closest_price ( histroy_data_intraday , target_hr = close_hr_str , direction = 'backward' ) close_date = date_array [ np . where ( time_array == close_date_new )[ 0 ]][ 0 ] close_datetime = datetime . datetime . combine ( pd . to_datetime ( close_date ) . date (), close_date_new ) range_dict = { 'entry' : list ( zip ( entry_times , entry_pts )), 'exit' : list ( zip ( exit_times , exit_pts )), 'stop' : list ( zip ( stop_times , stop_pts )), 'open' : tuple (( open_datetime , open_pt )), 'close' : tuple (( close_datetime , close_pt ))} #print(range_dict) return range_dict find_price_by_time ( history_data_daily , history_data_minute , open_hr = '0330' ) A function to search for the opening price of the day. If at the opening hour, there are no bid or price information, the script loop through the next 30 minutes to find the opening price. Parameters: history_data_daily ( dataframe ) \u2013 The historical daily data. history_data_minute ( dataframe ) \u2013 The historical minute data. open_hr ( str , default: '0330' ) \u2013 Defining the opening hour. The default is '0330'. Returns: open_price_data ( dataframe ) \u2013 A table consist of three columns: 'Date', 'Time', and 'Open Price'. Source code in EC_tools/read.py 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 def find_price_by_time ( history_data_daily : pd . DataFrame , history_data_minute : pd . DataFrame , open_hr : str = '0330' ) -> pd . DataFrame : #tested \"\"\" A function to search for the opening price of the day. If at the opening hour, there are no bid or price information, the script loop through the next 30 minutes to find the opening price. Parameters ---------- history_data_daily : dataframe The historical daily data. history_data_minute : dataframe The historical minute data. open_hr : str, optional Defining the opening hour. The default is '0330'. Returns ------- open_price_data: dataframe A table consist of three columns: 'Date', 'Time', and 'Open Price'. \"\"\" date_list = history_data_daily [ 'Date' ] . to_list () open_price_data = [] #loop through daily data to get the date for date in date_list : day_data = history_data_minute [ history_data_minute [ 'Date' ] == date ] # Find the closest hour and price open_hr_dt , open_price = find_closest_price ( day_data , target_hr = '0330' ) #print('open_price',open_price) if type ( open_price ) == float : pass elif len ( open_price ) != 1 : print ( open_price ) #storage #open_price_data.append((date.to_pydatetime(), open_hr_dt , # open_price.item())) open_price_data . append (( date . to_pydatetime (), open_hr_dt , open_price )) open_price_data = pd . DataFrame ( open_price_data , columns = [ 'Date' , 'Time' , 'Open Price' ]) return open_price_data find_range ( input_array , target_range ) A function that find the points' indicies given a target range. It finds the points within that range . Parameters: input_array ( ndarray ) \u2013 A 1D numpy array with only numbers. target_range ( tuple [ float | int ] | list [ float | int ] | ndarray ) \u2013 A tuple, list, or array of target range. e.g. [0,1], (0,1),... The first element is the lower bound and the second the upper bound. Raises: Exception \u2013 When the target_range input does not contain exactly two values. Returns: dict \u2013 range_dict contains the indices of the element of the input_array that is within the target_range, outside the target_range, and the boundaries of the range. Source code in EC_tools/read.py 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 def find_range ( input_array : np . ndarray , target_range : tuple [ float | int ] | list [ float | int ] | np . ndarray ) \\ -> dict : \"\"\" A function that find the points' indicies given a target range. It finds the points within that range . Parameters ---------- input_array : np.ndarray A 1D numpy array with only numbers. target_range : tuple[float|int] | list[float|int] | np.ndarray A tuple, list, or array of target range. e.g. [0,1], (0,1),... The first element is the lower bound and the second the upper bound. Raises ------ Exception When the target_range input does not contain exactly two values. Returns ------- dict range_dict contains the indices of the element of the input_array that is within the target_range, outside the target_range, and the boundaries of the range. \"\"\" if len ( target_range ) != 2 : raise Exception ( \"Target Range input must contains exactly two values.\" ) if not target_range [ 1 ] > target_range [ 0 ]: raise Exception ( \"Second element is not larger than the first. \\ Target Range input must in the form of [lower_bound, \\ upper_bound].\" ) lower_bound = np . repeat ( target_range [ 0 ], len ( input_array )) upper_bound = np . repeat ( target_range [ 1 ], len ( input_array )) delta_lower = input_array - lower_bound delta_upper = upper_bound - input_array delta = np . sign ( delta_upper ) * np . sign ( delta_lower ) #print(np.sign(delta_lower), np.sign(delta_upper), delta) #print(delta_lower, delta_upper, delta) range_indices = np . where ( delta > 0 ) bound_indices = np . where ( delta == 0 ) outbound_indices = np . where ( delta < 0 ) return { 'range_indices' : range_indices , 'outbound_indices' : outbound_indices , 'bound_indices' : bound_indices } get_apc_from_server ( username , password , start_date , end_date , categories , keywords = None , symbol = None ) Use the ArgusPossibilityCurve.py script to extract the APCin the wide format from the server. Note that the latest version is 1.1.0 (21 March 2024). Parameters: username ( str ) \u2013 The username of your argus account. password ( srt ) \u2013 The password of your argus account. start_date ( str ) \u2013 The desired start date of the apc, it should be in tcategorieshe format of this: \"2020-01-20\" end_date ( str ) \u2013 The end date of the apc. Similar to the above. categories ( str or list ) \u2013 The asset name. It could be either 1) A string such as \"Argus Nymex WTI month 1, Daily\", or 2) A list that contain the list of asset names, like this: ['Argus Nymex WTI month 1, Daily', 'Argus Nymex Heating oil month 1, Daily', ...] keywords ( Union [ str , list ] , default: None ) \u2013 Keywords in the categories to look for. Same dimension as the categories input. symbol ( Union [ str , list ] , default: None ) \u2013 Symbols to write in the new column. Same dimension as the categories input. Returns: apc_data ( list ) \u2013 A list that contain the spread of APC with the following collumns: Index(['Forecast Period', 'CATEGORY', '0.0025', '0.005', '0.0075', '0.01', '0.0125', '0.015', '0.0175', '0.02', ... '0.9775', '0.98', '0.9825', '0.985', '0.9875', '0.99', '0.9925', '0.995', '0.9975', 'symbol'], dtype='object', length=402) Source code in EC_tools/read.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get_apc_from_server ( username : str , password : str , start_date : str , end_date : str , categories : Union [ str , list ], keywords : Union [ str , list ] = None , symbol : Union [ str , list ] = None ) -> pd . DataFrame : \"\"\" Use the ArgusPossibilityCurve.py script to extract the APCin the wide format from the server. Note that the latest version is 1.1.0 (21 March 2024). Parameters ---------- username : str The username of your argus account. password : srt The password of your argus account. start_date : str The desired start date of the apc, it should be in tcategorieshe format of this: \"2020-01-20\" end_date : str The end date of the apc. Similar to the above. categories : str or list The asset name. It could be either 1) A string such as \"Argus Nymex WTI month 1, Daily\", or 2) A list that contain the list of asset names, like this: ['Argus Nymex WTI month 1, Daily', 'Argus Nymex Heating oil month 1, Daily', ...] keywords: str or list Keywords in the categories to look for. Same dimension as the categories input. symbol: str or list Symbols to write in the new column. Same dimension as the categories input. Returns ------- apc_data : list A list that contain the spread of APC with the following collumns: Index(['Forecast Period', 'CATEGORY', '0.0025', '0.005', '0.0075', '0.01', '0.0125', '0.015', '0.0175', '0.02', ... '0.9775', '0.98', '0.9825', '0.985', '0.9875', '0.99', '0.9925', '0.995', '0.9975', 'symbol'], dtype='object', length=402) \"\"\" print ( 'symbol' , symbol ) # Check if categories and keywords varaible matches in dimension # Login and Authentication apc = ArgusPossibilityCurves ( username = username , password = password ) apc . authenticate () apc . getMetadataCSV ( filepath = \"argus_latest_meta.csv\" ) # Make the start and end date in the datetime.date format start_date = datetime . date ( int ( start_date [: 4 ]), int ( start_date [ 5 : 7 ]), int ( start_date [ 8 : 10 ])) end_date = datetime . date ( int ( end_date [: 4 ]), int ( end_date [ 5 : 7 ]), int ( end_date [ 8 : 10 ])) if type ( categories ) is str : # if the asset name input is a string, pull only one # This retrieve the apc from the server apc_data = apc . getPossibilityCurves ( start_date = start_date , end_date = end_date , categories = [ categories ]) # Delete irrelavant columns #apc_data = apc_data.drop(columns=['PUBLICATION_DATE', # 'CONTINUOUS_FORWARD', # 'PRICE_UNIT', 'TIMESTAMP']) #apc_data.columns = ['Forecast_Period'] + [i for i in apc_data.columns[1:]] # Add the term \"APC\" in each column # If no specific symbol input, use the name of the categories if symbol == None : symbol = categories else : pass # make a new column with nothing in it. Then write the short symbol apc_data [ 'symbol' ] = None apc_data [ 'symbol' ] = np . where ( apc_data [ 'CATEGORY' ] . apply ( lambda x : keywords in x ), symbol , apc_data [ 'symbol' ]) elif type ( categories ) is list : # if the asset name input is a list, pull a list of APC apc_data = apc . getPossibilityCurves ( start_date = start_date , end_date = end_date , categories = categories ) #apc_data = apc_data.drop(columns=['PUBLICATION_DATE', # 'CONTINUOUS_FORWARD', # 'PRICE_UNIT', 'TIMESTAMP']) #apc_data.columns = ['Forecast_Period'] + [i for i in apc_data.columns[1:]] apc_data [ 'symbol' ] = None # add new column with symbols corresponding to the keywords. for i , c in zip ( keywords , symbol ): apc_data [ 'symbol' ] = np . where ( apc_data [ 'CATEGORY' ] . apply ( lambda x : i in x ), c , apc_data [ 'symbol' ]) # Drop the Category column #apc_data = apc_data.drop(columns=['CATEGORY']) return apc_data group_trade ( position_pool , select_func = lambda x : True ) A function to group positions by trade id along with some given conditions. Parameters: position_pool ( list ) \u2013 The position_pool list inside a portfolio object. select_func ( Callable function , default: lambda x: True ) \u2013 Additional functions for unique condition for grouping trade. The default is a lambda function that return True (It will return true no matter what). Returns: list \u2013 A new list with each traded grouped as a list element in a bucket Source code in EC_tools/read.py 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 def group_trade ( position_pool : list , select_func : Callable [[ int ], bool ] = lambda x : True ) -> list : # \"\"\" A function to group positions by trade id along with some given conditions. Parameters ---------- position_pool : list The position_pool list inside a portfolio object. select_func : Callable function, optional Additional functions for unique condition for grouping trade. The default is a lambda function that return True (It will return true no matter what). Returns ------- list A new list with each traded grouped as a list element in a bucket \"\"\" # A function that matches the trade_id and group them in a list # First sort the pool by trade_id. pos_pool = position_pool . copy () pos_pool . sort ( key = lambda x : x . pos_id ) bucket , temp = [], [] trade_id_now = pos_pool [ 0 ] . pos_id i = 0 while i < len ( pos_pool ): # loop through each position, if the pos_id == trade_id_now, save in # a temp list if pos_pool [ i ] . pos_id == trade_id_now : if select_func ( i ): temp . append ( pos_pool [ i ]) i = i + 1 elif pos_pool [ i ] . pos_id != trade_id_now : # Otherwise, put the temp list into the overall bucket, restart # the counter and make a new temp list to repeat the process #print('switch') #print(i, pos_pool[i].pos_id) bucket . append ( temp ) trade_id_now = pos_pool [ i ] . pos_id temp = [] temp . append ( pos_pool [ i ]) i = i + 1 return bucket merge_portara_data ( table1 , table2 ) Merging the Portara Daily and Minute table. The merger is operated on the two columns: 'Date only' and 'Price Code'. LEGACY function from Abbe. Not in use at the moment. Parameters: table1 ( dataframe ) \u2013 The pandas dataframe Daily pricing data. table2 ( dataframe ) \u2013 The Portara Minute pricing data. Returns: new_table ( pandas dataframe ) \u2013 The new merged table. Source code in EC_tools/read.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def merge_portara_data ( table1 : pd . DataFrame , table2 : pd . DataFrame ) -> pd . DataFrame : \"\"\" Merging the Portara Daily and Minute table. The merger is operated on the two columns: 'Date only' and 'Price Code'. LEGACY function from Abbe. Not in use at the moment. Parameters ---------- table1 : dataframe The pandas dataframe Daily pricing data. table2 : dataframe The Portara Minute pricing data. Returns ------- new_table : pandas dataframe The new merged table. \"\"\" # A function that merges # construct a master table of price across all minutes # merge the minute and daily data based on Date only and Price code new_table = table1 . merge ( table2 , on = [ 'Date only' , 'Price Code' ], how = 'right' ) # add c1 to the price code val = 0 table2 [ 'Price Code' ] = table2 [ 'symbol' ] + 'c' + str ( val + 1 ) new_table = table1 . merge ( table2 , on = [ 'Date only' , 'Price Code' ], how = 'right' ) del table1 , table2 # drop contract columns new_table = new_table . drop ( columns = 'Contract' ) return new_table merge_raw_data ( filename_list , save_filename , sort_by = 'PERIOD' ) A function that merges a list of CSV files into one CSV file. Parameters: filename_list ( list ) \u2013 A list of filename if CSV to be Concatenated. save_filename ( str ) \u2013 The filename for saving. sort_by ( str , default: 'PERIOD' ) \u2013 The column name used in the sorting. The default is \"PERIOD\". Returns: merged_data ( dataframe ) \u2013 The merged data. Source code in EC_tools/read.py 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 def merge_raw_data ( filename_list : list [ str ], save_filename : str , sort_by : str = \"PERIOD\" ) -> pd . DataFrame : \"\"\" A function that merges a list of CSV files into one CSV file. Parameters ---------- filename_list : list A list of filename if CSV to be Concatenated. save_filename : str The filename for saving. sort_by : str, optional The column name used in the sorting. The default is \"PERIOD\". Returns ------- merged_data : dataframe The merged data. \"\"\" merged_data = concat_CSVtable ( filename_list , sort_by = sort_by ) merged_data . to_csv ( save_filename , index = False ) return merged_data open_portfolio ( filename ) A handy function to open a portfolio. Nothing special but easy to remember. Parameters: filename ( str ) \u2013 The filename of the Portfolio object in pickle format . Returns: portfo ( Portfolio ) \u2013 Source code in EC_tools/read.py 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 def open_portfolio ( filename : str ): \"\"\" A handy function to open a portfolio. Nothing special but easy to remember. Parameters ---------- filename : str The filename of the Portfolio object in pickle format . Returns ------- portfo : Portfolio \"\"\" file = open ( filename , 'rb' ) portfo = pickle . load ( file ) file . close () return portfo portara_data_handling ( portara_dat ) A function that handle Portara's data. LEGACY function from Abbe. Not in Use at the moment. Parameters: portara_dat ( pandas dataframe ) \u2013 Input Portara data. Returns: portara_dat ( pandas dataframe ) \u2013 Output post-processed Portara data. Source code in EC_tools/read.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def portara_data_handling ( portara_dat : pd . DataFrame ) -> pd . DataFrame : \"\"\" A function that handle Portara's data. LEGACY function from Abbe. Not in Use at the moment. Parameters ---------- portara_dat : pandas dataframe Input Portara data. Returns ------- portara_dat : pandas dataframe Output post-processed Portara data. \"\"\" # now tidy up the data minutes = np . concatenate (( np . arange ( 30 , 60 ), np . arange ( 100 , 160 ), np . arange ( 200 , 260 ), np . arange ( 300 , 331 ))) minutes_2 = np . concatenate (( np . arange ( 30 , 60 ), # half past to 1 np . arange ( 100 , 160 ), # 1 to 2 np . arange ( 200 , 231 ))) # 2 to 3 for i in np . flip ( minutes ): # if there are no trades Portara doesn't create a bar so we have to go backwards to the last bar where a trade # happened to get the price iff there is no bar for 330 - otherwise the price is 'nan' price_330 = np . where ( np . isnan ( portara_dat [ 'Close 330' ] . to_numpy ()), portara_dat [ 'Close ' + str ( i )] . to_numpy (), portara_dat [ 'Close 330' ] . to_numpy ()) portara_dat [ 'Close 330' ] = price_330 for i in np . flip ( minutes_2 ): # if there are no trades Portara doesn't create a bar so we have to go backwards to the last bar where a trade # happened to get the price iff there is no bar for 330 (getting 230 prices for when daylight savings moving UK to BST (1 hour forward) from UTC/GMT price_230 = np . where ( np . isnan ( portara_dat [ 'Close 230' ] . to_numpy ()), portara_dat [ 'Close ' + str ( i )] . to_numpy (), portara_dat [ 'Close 230' ] . to_numpy ()) portara_dat [ 'Close 230' ] = price_230 portara_dat = portara_dat [[ 'Date only' , 'Close 330' , 'Settle' , 'Price Code' , 'Contract Symbol' , 'Close 230' ]] portara_dat [ 'daylight saving forward date' ] = portara_dat [ 'Date only' ] . apply ( lambda x : pd . to_datetime ( str ( x . year ) + '-03-31' )) # date for daylight savings start portara_dat [ 'daylight saving back date' ] = portara_dat [ 'Date only' ] . apply ( lambda x : pd . to_datetime ( str ( x . year ) + '-10-27' )) # date for daylight savings end portara_dat [ 'Close 330' ] = np . where ( np . logical_and ( portara_dat [ 'Date only' ] > portara_dat [ 'daylight saving forward date' ], portara_dat [ 'Date only' ] < portara_dat [ 'daylight saving back date' ]), portara_dat [ 'Close 230' ], portara_dat [ 'Close 330' ] ) portara_dat = portara_dat [[ 'Date only' , 'Close 330' , 'Settle' , 'Price Code' , 'Contract Symbol' ]] portara_dat = portara_dat . sort_values ( by = 'Date only' ) # dates in ascending order return portara_dat read_apc_data ( filename ) Nothing Special. Just a shorthand function to read the apc Parameters: filename ( str ) \u2013 APC CSVfilename. Returns: data ( Data Frame ) \u2013 APC in dataframe. Source code in EC_tools/read.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def read_apc_data ( filename : str ) -> pd . DataFrame : \"\"\" Nothing Special. Just a shorthand function to read the apc Parameters ---------- filename : str APC CSVfilename. Returns ------- data : Data Frame APC in dataframe. \"\"\" # This function should be used in conjuction with get_apc_from_server(). # The data should be pulled from the server using that function data = pd . read_csv ( filename ) return data read_portara_daily_data ( filename , symbol , start_date , end_date , column_select = [ 'Settle' , 'Price Code' , 'Contract Symbol' , 'Date only' ]) A generic function that read the Portara Data in a suitable form. The function itself only read a single csv file at a time. LEGACY function from Abbe. Use the function 'read_reformat_Portara_daily_data' instead. Parameters: filename ( str ) \u2013 The filename in the correct address. symbol ( str ) \u2013 A short symbol for the asset. start_date ( str ) \u2013 The start date of the query. e.g, \"2024-01-13\". end_date ( str ) \u2013 The end date of the query. e.g, \"2024-01-18\". column_select ( list [ str ] , default: ['Settle', 'Price Code', 'Contract Symbol', 'Date only'] ) \u2013 A list of columns name to select for in the master file. The default is ['Settle', 'Price Code', 'Contract Symbol', 'Date only'] Returns: portara_dat ( 2D pandas dataframe ) \u2013 The Portara daily data Source code in EC_tools/read.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def read_portara_daily_data ( filename : str , symbol : str , start_date : str , end_date : str , column_select : list [ str ] = [ 'Settle' , 'Price Code' , 'Contract Symbol' , 'Date only' ]) -> \\ pd . DataFrame : \"\"\" A generic function that read the Portara Data in a suitable form. The function itself only read a single csv file at a time. LEGACY function from Abbe. Use the function 'read_reformat_Portara_daily_data' instead. Parameters ---------- filename : str The filename in the correct address. symbol : str A short symbol for the asset. start_date: str The start date of the query. e.g, \"2024-01-13\". end_date: str The end date of the query. e.g, \"2024-01-18\". column_select: 1D list A list of columns name to select for in the master file. The default is ['Settle', 'Price Code', 'Contract Symbol', 'Date only'] Returns ------- portara_dat: 2D pandas dataframe The Portara daily data \"\"\" # Read downloaded data using panda portara_dat = pd . read_csv ( filename ) # A list of symbol portara_dat [ 'symbol' ] = symbol # Transform the date format from 20160104 to 2016-01-04 00:00:00 (panda timestamp) portara_dat [ 'Date' ] = portara_dat [ 'Date' ] . apply ( lambda x : str ( x )[ 0 : 4 ] + '-' + str ( x )[ 4 : 6 ] + '-' + str ( x )[ 6 :]) portara_dat [ 'Date' ] = pd . to_datetime ( portara_dat [ 'Date' ]) portara_dat [ 'Date only' ] = portara_dat [ 'Date' ] #2016-01-04 00:00:00 format # Datetime beyond 2020-12-14 is accepted beyond 2020-12-14 # Select datetime between start_date and end_date bools = portara_dat [ 'Date' ] . apply ( lambda x : x >= pd . to_datetime ( start_date ) and x <= pd . to_datetime ( end_date )) # Select for the data that fits the bool condition (date after 2020-12-14) portara_dat = portara_dat [ bools ] val = 0 # add c1 to the back of CL portara_dat [ 'Price Code' ] = portara_dat [ 'symbol' ] + 'c' + str ( val + 1 ) contract_year = portara_dat [ 'Contract' ] . apply ( lambda x : str ( x )[ - 3 : - 1 ]) # Get contract year 2021->21 contract_month = portara_dat [ 'Contract' ] . apply ( lambda x : str ( x )[ - 1 ]) # Get contract month # make a new column with CL21F from CLA2021F portara_dat [ 'Contract Symbol' ] = portara_dat [ 'symbol' ] + contract_year + contract_month # Select for only the following 4 columns because the others are not relevant to us portara_dat = portara_dat [ column_select ] return portara_dat read_portara_minute_data ( filename , symbol , start_date , end_date , start_filter_hour = 30 , end_filter_hour = 331 , column_select = []) A modified version of the generic Portara reading function specifically for the 1 minute data. LEGACY function from Abbe. Use the function 'read_reformat_Portara_minute_data' instead. Parameters: filename ( str ) \u2013 The filename in the correct address. symbol ( str ) \u2013 A short symbol for the asset. start_date \u2013 The start date of the query. e.g, \"2024-01-13\". end_date \u2013 The end date of the query. e.g, \"2024-01-18\". start_filter_hour ( int , default: 30 ) \u2013 The start time for filtering by hours. The default is 30 because of the london trading hours end_filter_hour ( int , default: 331 ) \u2013 The end time for filtering by hours. The default is 331. Returns: portara_dat_2 ( 2D panda dataframe ) \u2013 The Portara minute data. Source code in EC_tools/read.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def read_portara_minute_data ( filename , symbol , start_date , end_date , start_filter_hour = 30 , end_filter_hour = 331 , column_select = []): \"\"\" A modified version of the generic Portara reading function specifically for the 1 minute data. LEGACY function from Abbe. Use the function 'read_reformat_Portara_minute_data' instead. Parameters ---------- filename : str The filename in the correct address. symbol : str A short symbol for the asset. start_date: str The start date of the query. e.g, \"2024-01-13\". end_date: str The end date of the query. e.g, \"2024-01-18\". start_filter_hour : int, optional The start time for filtering by hours. The default is 30 because of the london trading hours end_filter_hour : int, optional The end time for filtering by hours. The default is 331. Returns ------- portara_dat_2 : 2D panda dataframe The Portara minute data. \"\"\" # Maybe first select for date then select for time? val = 0 # Reading only these column portara_dat_2 = pd . read_csv ( filename , names = [ 'Date' , 'Time' , 'Low' , 'High' , 'Open' , 'Close' , 'Trade Volume' , 'Contract' ]) # Add a column of symbol portara_dat_2 [ 'symbol' ] = symbol #print(portara_dat_2,'9') # Transform the date format from 20160104 to 2016-01-04 00:00:00 (panda timestamp) portara_dat_2 [ 'Date' ] = portara_dat_2 [ 'Date' ] . apply ( lambda x : str ( x )[ 0 : 4 ] + '-' + str ( x )[ 4 : 6 ] + '-' + str ( x )[ 6 :]) portara_dat_2 [ 'Date' ] = pd . to_datetime ( portara_dat_2 [ 'Date' ]) portara_dat_2 [ 'Date only' ] = portara_dat_2 [ 'Date' ] # only select time within the range of starting price and ending price bools = portara_dat_2 [ 'Time' ] . apply ( lambda x : x in np . arange ( start_filter_hour , end_filter_hour )) # for the moment need only price at 330 so filtering for prices at 330 and few hours before portara_dat_2 = portara_dat_2 [ bools ] # Select for only these five columns portara_dat_2 = portara_dat_2 [[ 'Date only' , 'Time' , 'Close' , 'Contract' , 'symbol' ]] #print(portara_dat_2,'5') # Pivot: Return reshaped DataFrame organized by given index / column values. # Make the main columns time basedm and indexed portara_dat_2 = portara_dat_2 . pivot ( index = [ 'Date only' , 'Contract' , 'symbol' ], columns = 'Time' , values = 'Close' ) # make new column order by ['Date only', 'Contract', 'symbol'] and reset index to numbers portara_dat_2 . reset_index ( inplace = True ) #print(portara_dat_2,'pivot') # add multiple columns list_names = [ 'Close ' + str ( i ) for i in portara_dat_2 . columns [ 3 :] . to_list ()] # rename the columns with times portara_dat_2 . columns = [ 'Date only' , 'Contract' , 'symbol' ] + list_names # Select for data after first date and end date bools = portara_dat_2 [ 'Date only' ] . apply ( lambda x : x >= pd . to_datetime ( start_date ) and x <= pd . to_datetime ( end_date )) # filter for data after given date portara_dat_2 = portara_dat_2 [ bools ] # add c1 for front month contract portara_dat_2 [ 'Price Code' ] = portara_dat_2 [ 'symbol' ] + 'c' + str ( val + 1 ) return portara_dat_2 read_reformat_APC_data ( filename , time_proxies = [ 'PUBLICATION_DATE' , 'PERIOD' ]) Read and reformat APC data Parameters: filename ( str ) \u2013 APC filename. time_proxies ( list [ str ] , default: ['PUBLICATION_DATE', 'PERIOD'] ) \u2013 A list of time (or Date) proxy. These are the column name in the DataFrame. The default is ['PUBLICATION_DATE', 'PERIOD']. Returns: DataFrame \u2013 Source code in EC_tools/read.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def read_reformat_APC_data ( filename : str , time_proxies : list [ str ] = [ 'PUBLICATION_DATE' , 'PERIOD' ]) -> pd . DataFrame : \"\"\" Read and reformat APC data Parameters ---------- filename : str APC filename. time_proxies : list[str], optional A list of time (or Date) proxy. These are the column name in the DataFrame. The default is ['PUBLICATION_DATE', 'PERIOD']. Returns ------- DataFrame \"\"\" signal_data = pd . read_csv ( filename ) if type ( time_proxies ) == str : time_proxies = [ time_proxies ] for time_proxy in time_proxies : signal_data [ time_proxy ] = [ datetime . datetime . strptime ( x , '%Y-%m- %d ' ) for x in signal_data [ time_proxy ]] #signal_data[time_proxy_2] = [datetime.datetime.strptime(x, '%Y-%m-%d') # for x in signal_data[time_proxy_2]] #signal_data_reindex = signal_data.set_index('Forecast Period',drop=False) signal_data_reindex = signal_data return signal_data #signal_data_reindex read_reformat_Portara_daily_data ( filename , add_col_data = {}) Reformat the Portara minute data in a format readable by the scripts. Parameters: filename ( str ) \u2013 The filename of the Portara minute data. Returns: history_data ( pandas dataframe ) \u2013 The reformatted table. Source code in EC_tools/read.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 def read_reformat_Portara_daily_data ( filename : str , add_col_data : dict = {}) -> \\ pd . DataFrame : \"\"\" Reformat the Portara minute data in a format readable by the scripts. Parameters ---------- filename : str The filename of the Portara minute data. Returns ------- history_data : pandas dataframe The reformatted table. \"\"\" history_data = pd . read_csv ( filename ) history_data . columns = [ 'Date' , 'Open' , 'High' , 'Low' , 'Settle' , 'Volume' , 'OpenInterest' , 'Contract Code' ] # change the date from 20220222 (int) to '2022-02-22' (str) history_data [ 'Date' ] = [ datetime . datetime . strptime ( str ( x )[ 0 : 4 ] + str ( x )[ 4 : 6 ] + str ( x )[ 6 :], '%Y%m %d ' ) for x in history_data [ 'Date' ]] #history_data_reindex = history_data.set_index('Date',drop=False) history_data_reindex = history_data match add_col_data : case {} | [] | None : pass case _ : for key in add_col_data : history_data_reindex [ key ] = add_col_data [ key ] return history_data read_reformat_Portara_minute_data ( filename , add_col_data = {}, time_to_datetime = False ) Reformat the Portara minute data in a format readable by the scripts. Parameters: filename ( str ) \u2013 The filename of the Portara minute data. Returns: history_data ( pandas dataframe ) \u2013 The reformatted table. Source code in EC_tools/read.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 def read_reformat_Portara_minute_data ( filename : str , add_col_data : dict = {}, time_to_datetime = False ) -> \\ pd . DataFrame : \"\"\" Reformat the Portara minute data in a format readable by the scripts. Parameters ---------- filename : str The filename of the Portara minute data. Returns ------- history_data : pandas dataframe The reformatted table. \"\"\" history_data = pd . read_csv ( filename ) history_data . columns = [ 'Date' , 'Time' , 'Open' , 'High' , 'Low' , 'Settle' , 'Volume' , 'Contract Code' ] # include a function that let user to choose the reformat? # change the date from 20220222 (int) to '2022-02-22' (str) history_data [ 'Date' ] = [ datetime . datetime . strptime ( str ( x )[ 0 : 4 ] + str ( x )[ 4 : 6 ] \\ + str ( x )[ 6 :], '%Y%m %d ' ) for x in history_data [ 'Date' ]] # convert the format 1330 (int) to 13:30 (datetime.time) obejct intmin = history_data [ 'Time' ] bucket = util . convert_intmin_to_time ( intmin ) #, label='Time') history_data [ 'Time' ] = bucket # ============================================================================= # if time_to_datetime: # history_data['Time'] = [datetime.datetime.strptime(t, '%H%M') # for t in history_data['Time']] # # ============================================================================= #history_data_reindex = history_data.set_index('Date',drop=False) history_data_reindex = history_data match add_col_data : case {} | [] | None : pass case _ : for key in add_col_data : history_data_reindex [ key ] = add_col_data [ key ] return history_data #history_data_reindex read_reformat_dateNtime ( filename , time_proxies = [ 'Date' , 'Time' ], str_formats = [ '%Y-%m- %d ' , '%H:%M:%S' ]) Utility function that read and reformat data with multiple columns of time elements, e.g. 'Date' and 'Time'. Parameters: filename ( str ) \u2013 CSV filename. time_proxies ( list [ str ] , default: ['Date', 'Time'] ) \u2013 A list. The default is ['Date', 'Time']. str_formats ( list [ str ] , default: ['%Y-%m-%d', '%H:%M:%S'] ) \u2013 A list of str arg passing to datetime.strptime function. The default is ['%Y-%m-%d', '%H:%M:%S']. Returns: data ( Data Frame ) \u2013 Source code in EC_tools/read.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 def read_reformat_dateNtime ( filename : str , time_proxies : list [ str ] = [ 'Date' , 'Time' ], str_formats : list [ str ] = [ '%Y-%m- %d ' , '%H:%M:%S' ]) \\ -> pd . DataFrame : \"\"\" Utility function that read and reformat data with multiple columns of time elements, e.g. 'Date' and 'Time'. Parameters ---------- filename : str CSV filename. time_proxies : list[str], optional A list. The default is ['Date', 'Time']. str_formats : list[str], optional A list of str arg passing to datetime.strptime function. The default is ['%Y-%m-%d', '%H:%M:%S']. Returns ------- data : Data Frame \"\"\" data = pd . read_csv ( filename ) bucket_1 = [ datetime . datetime . strptime ( x , str_formats [ 0 ]) for x in data [ time_proxies [ 0 ]]] bucket_2 = [ datetime . datetime . strptime ( x , str_formats [ 1 ]) . time () for x in data [ time_proxies [ 1 ]]] data [ time_proxies [ 0 ]] = bucket_1 data [ time_proxies [ 1 ]] = bucket_2 print ( data [ time_proxies [ 0 ]], data [ time_proxies [ 1 ]]) return data read_reformat_openprice_data ( filename ) A function that read and reformat the openprice data. Parameters: filename ( str ) \u2013 CSV filename. Returns: DataFrame \u2013 Source code in EC_tools/read.py 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def read_reformat_openprice_data ( filename : str ) -> pd . DataFrame : \"\"\" A function that read and reformat the openprice data. Parameters ---------- filename : str CSV filename. Returns ------- DataFrame \"\"\" openprice_data = pd . read_csv ( filename ) openprice_data [ \"Date\" ] = [ datetime . datetime ( year = int ( str ( x )[ 0 : 4 ]), month = int ( str ( x )[ 5 : 7 ]), day = int ( str ( x )[ 8 :])) for x in openprice_data [ 'Date' ]] # convert the format 1330 (int) to 13:30 (datetime.time) obejct intmin = openprice_data [ 'Time' ] bucket = [ datetime . datetime . strptime ( intmin . iloc [ i ], \"%H:%M:%S\" ) . time () for i in range ( len ( intmin ))] openprice_data [ 'Time' ] = bucket #openprice_data_reindex = openprice_data.set_index('Date',drop=False) openprice_data_reindex = openprice_data #print(openprice_data_reindex) return openprice_data #openprice_data_reindex render_PNL_xlsx ( listfiles , number_contracts_list = [ 5 , 10 , 15 , 20 , 25 , 50 ], suffix = '_.xlsx' , symbol_proxy = 'Price_Code' , entry_price_proxy = 'Entry_Price' , entry_date_proxy = 'Entry_Date' , exit_price_proxy = 'Exit_Price' , return_proxy = 'Return_Trades' ) A function that read in the back-test result to generate an xlsx PNL file Parameters: listfiles ( list ) \u2013 A list of filenames that to be included in the PNL report number_contracts_list ( list , default: [5, 10, 15, 20, 25, 50] ) \u2013 A list of numbers of contracts to be calculated in the return and cumulative return suffix ( str , default: '_.xlsx' ) \u2013 The suffix for the output filename. The Default is '_.xlsx'. symbol_proxy ( str , default: 'Price_Code' ) \u2013 The name for the symbol column. The Default is 'Price_Code'. entry_price_proxy ( str , default: 'Entry_Price' ) \u2013 The name of the entry price column. The Default is 'Entry_Price'. entry_date_proxy ( str , default: 'Entry_Date' ) \u2013 The name of the entry date column. The Default is 'Entry_Date'. exit_price_proxy ( str , default: 'Exit_Price' ) \u2013 The name of the exit price column. The Default is 'Exit_Price'. return_proxy ( str , default: 'Return_Trades' ) \u2013 The name of the return column. The Default is 'Return_Trades'. Returns: datpc ( DataFrame ) \u2013 The output PNL file. Source code in EC_tools/read.py 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 def render_PNL_xlsx ( listfiles : list [ str ], number_contracts_list : list [ int | float ] = [ 5 , 10 , 15 , 20 , 25 , 50 ], suffix : str = '_.xlsx' , symbol_proxy : str = 'Price_Code' , entry_price_proxy : str = 'Entry_Price' , entry_date_proxy : str = 'Entry_Date' , exit_price_proxy : str = 'Exit_Price' , return_proxy : str = 'Return_Trades' ) -> pd . DataFrame : \"\"\" A function that read in the back-test result to generate an xlsx PNL file Parameters ---------- listfiles : list A list of filenames that to be included in the PNL report number_contracts_list : list A list of numbers of contracts to be calculated in the return and cumulative return suffix : str The suffix for the output filename. The Default is '_.xlsx'. symbol_proxy: str The name for the symbol column. The Default is 'Price_Code'. entry_price_proxy: str The name of the entry price column. The Default is 'Entry_Price'. entry_date_proxy: str The name of the entry date column. The Default is 'Entry_Date'. exit_price_proxy: str The name of the exit price column. The Default is 'Exit_Price'. return_proxy: str The name of the return column. The Default is 'Return_Trades'. Returns ------- datpc : DataFrame The output PNL file. \"\"\" for fn in listfiles : # regular output price_codes = list ( SIZE_DICT . keys ()) dat = pd . read_csv ( fn ) print ( fn , dat ) with pd . ExcelWriter ( fn [: - 4 ] + suffix ) as excel_writer : dattotal = dat dattotal = dattotal . sort_values ( by = entry_date_proxy ) dattotal [ 'number barrels/gallons' ] = dattotal [ symbol_proxy ] . apply ( lambda x : SIZE_DICT [ x ]) dattotal [ 'fees' ] = dattotal [ symbol_proxy ] . apply ( lambda x : round_turn_fees [ x ]) dattotal [ 'fees' ] = np . where ( np . isnan ( dattotal [ 'Entry_Price' ]), 0.0 , dattotal [ 'fees' ]) # Make columns for scaled returns dattotal [ 'scaled returns from trades' ] = dattotal [ return_proxy ] * \\ dattotal [ 'number barrels/gallons' ] \\ - dattotal [ 'fees' ] for num_contracts in number_contracts_list : col_name = 'scaled returns from trades (x {} )' . format ( num_contracts ) dattotal [ col_name ] = dattotal [ 'scaled returns from trades' ] * num_contracts # Make columns for cumulative returns dattotal [ 'cumulative P&L from trades' ] = np . cumsum ( dattotal [ 'scaled returns from trades' ]) cum_col_name_list = [ 'cumulative P&L from trades' ] for num_contracts in number_contracts_list : cum_col_name = 'cumulative P&L from trades for contracts (x {} )' . format ( num_contracts ) PNL_col_name = 'scaled returns from trades (x {} )' . format ( num_contracts ) dattotal [ cum_col_name ] = np . cumsum ( dattotal [ PNL_col_name ]) cum_col_name_list . append ( cum_col_name ) dattotal . to_excel ( excel_writer = excel_writer , sheet_name = 'Total' ) # make sub-spread sheet for output sorted by individual asset for _ , pc in enumerate ( price_codes ): # recalculate the cumulative returns for each assets # First drop the columns previously calculated datpc = dattotal [ dattotal [ symbol_proxy ] == pc ] . drop ( columns = cum_col_name_list ) ################################## datpc [ 'cumulative P&L from trades' ] = np . cumsum ( datpc [ 'scaled returns from trades' ]) for num_contracts in number_contracts_list : cum_col_name = 'cumulative P&L from trades for contracts (x {} )' . format ( num_contracts ) PNL_col_name = 'scaled returns from trades (x {} )' . format ( num_contracts ) datpc [ cum_col_name ] = np . cumsum ( datpc [ PNL_col_name ]) if len ( datpc ) > 0 : datpc . to_excel ( excel_writer = excel_writer , sheet_name = pc ) return datpc","title":"read"},{"location":"EC_tools/read/#read","text":"Created on Tue Apr 2 14:09:54 2024 @author: dexter The read module contains handy functions related reading and reformating raw data. It also contains some relevant function in mainpulating data or deriving new information from the raw data.","title":"read"},{"location":"EC_tools/read/#EC_tools.read.concat_CSVtable","text":"Concatenate CSV tables. Parameters: filename_list ( list ) \u2013 A list of CSV filename. sort_by ( str , default: 'Date' ) \u2013 The column name in which the dataframe is sorted. The default is 'Date'. Returns: master_table ( dataframe ) \u2013 The resulting table. Source code in EC_tools/read.py 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 def concat_CSVtable ( filename_list : list [ str ], sort_by : str = 'Date' ) -> pd . DataFrame : \"\"\" Concatenate CSV tables. Parameters ---------- filename_list : list A list of CSV filename. sort_by : str, optional The column name in which the dataframe is sorted. The default is 'Date'. Returns ------- master_table : dataframe The resulting table. \"\"\" master_table = pd . DataFrame () for filename in filename_list : temp = pd . read_csv ( filename ) master_table = pd . concat ([ master_table , temp ]) master_table . sort_values ( by = sort_by , inplace = True ) return master_table","title":"concat_CSVtable"},{"location":"EC_tools/read/#EC_tools.read.extract_lag_data","text":"Extract the Lag data based on a given date. Parameters: signal_data ( pandas dataframe ) \u2013 The signal data. history_data ( pandas dataframe ) \u2013 The historical data. date ( str ) \u2013 The date of interest, format like this \"2024-01-10\". lag_size ( int , default: 5 ) \u2013 The size of the lag window. The default is 5 (days). Returns: signal_data_lag ( pandas data frame ) \u2013 The signal data five (lag_size) days prior to the given date. history_data_lag ( pandas data frame ) \u2013 The historical data five (lag_size) days prior to the given date. Source code in EC_tools/read.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 def extract_lag_data ( signal_data : pd . DataFrame , history_data : pd . DataFrame , date : str , lag_size : int = 5 , time_proxy = \"PERIOD\" ) -> \\ tuple [ pd . DataFrame , pd . DataFrame ]: \"\"\" Extract the Lag data based on a given date. Parameters ---------- signal_data : pandas dataframe The signal data. history_data : pandas dataframe The historical data. date : str The date of interest, format like this \"2024-01-10\". lag_size : int, optional The size of the lag window. The default is 5 (days). Returns ------- signal_data_lag : pandas data frame The signal data five (lag_size) days prior to the given date. history_data_lag : pandas data frame The historical data five (lag_size) days prior to the given date. \"\"\" # Find the row index of the history data first #row_index = history_data.index[history_data['Date'] == date].tolist()[0] row_index = history_data . index [ history_data [ 'Date' ] == date ] . item () #lag_days = datetime.timedelta(days=lag_size) #lag5days = row_index-lag_days #lag1day = row_index - datetime.timedelta(days=1) # extract exactly 5 (default) lag days array history_data_lag = history_data . loc [ row_index - lag_size : row_index - 1 ] # history_data_lag = history_data.loc[lag5days:lag1day] # use the relevant date from history data to get signal data to ensure matching date window = history_data_lag [ 'Date' ] . tolist () # turn Timstamp into string #window = [str(window[i])[0:10] for i in range(lag_size)] #Store the lag signal data in a list #signal_data_lag = signal_data[signal_data['Forecast Period'] == window[0]] signal_data_lag = signal_data [ signal_data [ time_proxy ] == window [ 0 ]] for i in range ( lag_size - 1 ): curve = signal_data [ signal_data [ time_proxy ] == window [ i + 1 ]] signal_data_lag = pd . concat ([ signal_data_lag , curve ]) return signal_data_lag , history_data_lag","title":"extract_lag_data"},{"location":"EC_tools/read/#EC_tools.read.find_closest_price","text":"A method to find the closest price next to a traget hour Parameters: day_minute_data ( DataFrame ) \u2013 The minute pricing data. target_hr ( str , default: '0330' ) \u2013 The target hour for the search. The default is '0330'. direction ( dtr , default: 'forward' ) \u2013 To search the list either 'backward' or 'forward'. The default is 'forward'. step ( int , default: 1 ) \u2013 The step size of the search. The default is 1. search_time ( int , default: 1000 ) \u2013 The total minutes (steps) of the search. The default is 1000. Returns: target_hr_dt ( datetime ) \u2013 The datetime of the closest hour to the target. float \u2013 The target price. Source code in EC_tools/read.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 def find_closest_price ( day_minute_data : pd . DataFrame , target_hr : str = '0330' , direction : str = 'forward' , price_proxy : str = 'Open' , time_proxy : str = 'Time' , step : int = 1 , search_time : int = 1000 ) -> \\ tuple [ datetime . datetime , float ]: \"\"\" A method to find the closest price next to a traget hour Parameters ---------- day_minute_data : DataFrame The minute pricing data. target_hr : str, optional The target hour for the search. The default is '0330'. direction : dtr, optional To search the list either 'backward' or 'forward'. The default is 'forward'. step : int, optional The step size of the search. The default is 1. search_time : int, optional The total minutes (steps) of the search. The default is 1000. Returns ------- target_hr_dt : datetime.datetime The datetime of the closest hour to the target. float The target price. \"\"\" # If the input is forward, the loop search forward a unit of minute (step) if direction == 'forward' : step = 1. * step # If the input is backward, the loop search back a unit of minute (step) elif direction == 'backward' : step = - 1 * step target_hr_dt = datetime . time ( hour = int ( target_hr [ 0 : 2 ]), minute = int ( target_hr [ 2 : 4 ])) #initial estimation of the target price target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] #loop through the next 30 minutes to find the opening price for i in range ( search_time ): if len ( target_price ) == 0 : delta = datetime . timedelta ( minutes = step ) # Note that the datetime.datetime.today() is a place holder, it does # not affect the target_hr_dt vatriables. target_hr_dt = ( datetime . datetime . combine ( datetime . datetime . today (), target_hr_dt ) + delta ) . time () #print(i, target_hr_dt) target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] target_price = [ float ( target_price . iloc [ 0 ])] # make sure that this is float return target_hr_dt , target_price [ 0 ]","title":"find_closest_price"},{"location":"EC_tools/read/#EC_tools.read.find_closest_price_datetime","text":"A method to find the closest price next to a traget date and hour Parameters: day_minute_data ( DataFrame ) \u2013 The minute pricing data. target_hr ( str , default: '0330' ) \u2013 The target hour for the search. The default is '0330'. direction ( dtr , default: 'forward' ) \u2013 To search the list either 'backward' or 'forward'. The default is 'forward'. step ( int , default: 1 ) \u2013 The step size of the search. The default is 1. search_time ( int , default: 1000 ) \u2013 The total minutes (steps) of the search. The default is 1000. Returns: target_hr_dt ( datetime ) \u2013 The datetime of the closest hour to the target. float \u2013 The target price. Source code in EC_tools/read.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 @util . time_it def find_closest_price_datetime ( day_minute_data : pd . DataFrame , target_date : datetime . datetime , target_hr : str = '0330' , direction : str = 'forward' , price_proxy : str = 'Open' , time_proxy : str = 'Time' , date_proxy : str = 'Date' , step : int = 1 , search_time : int = 1000 ) -> \\ tuple [ datetime . datetime , float ]: \"\"\" A method to find the closest price next to a traget date and hour Parameters ---------- day_minute_data : DataFrame The minute pricing data. target_hr : str, optional The target hour for the search. The default is '0330'. direction : dtr, optional To search the list either 'backward' or 'forward'. The default is 'forward'. step : int, optional The step size of the search. The default is 1. search_time : int, optional The total minutes (steps) of the search. The default is 1000. Returns ------- target_hr_dt : datetime.datetime The datetime of the closest hour to the target. float The target price. \"\"\" # If the input is forward, the loop search forward a unit of minute (step) if direction == 'forward' : step = 1. * step # If the input is backward, the loop search back a unit of minute (step) elif direction == 'backward' : step = - 1 * step target_hr_dt = datetime . time ( hour = int ( target_hr [ 0 : 2 ]), minute = int ( target_hr [ 2 : 4 ])) day_minute_data = day_minute_data [ day_minute_data [ date_proxy ] == target_date ] print ( target_date , day_minute_data ) #initial estimation of the target price target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] #loop through the next 30 minutes to find the opening price for i in range ( search_time ): if len ( target_price ) == 0 : delta = datetime . timedelta ( minutes = step ) # Note that the datetime.datetime.today() is a place holder, it does # not affect the target_hr_dt vatriables. target_hr_dt = ( datetime . datetime . combine ( datetime . datetime . today (), target_hr_dt ) + delta ) . time () #print(i, target_hr_dt) target_price = day_minute_data [ day_minute_data [ time_proxy ] == target_hr_dt ][ price_proxy ] print ( target_price ) target_price = [ float ( target_price . iloc [ 0 ])] # make sure that this is float return target_hr_dt , target_price [ 0 ]","title":"find_closest_price_datetime"},{"location":"EC_tools/read/#EC_tools.read.find_crossover","text":"A function that find the crossover points' indicies. It finds the points right after either rise above, or drop below the threshold value. Parameters: input_array ( numpy array ) \u2013 A 1D numpy array with only numbers. threshold ( float, list, numpy array ) \u2013 the threshold value. Returns: dict \u2013 The 'rise' value contains a numpy array containing the indicies of points that rise above the the threshold. The 'drop' value contains a numpy array containing the indicies of points that drop below the the threshold. Source code in EC_tools/read.py 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 def find_crossover ( input_array : np . ndarray , threshold : float | list [ float | int ] | np . ndarray ) -> dict : \"\"\" A function that find the crossover points' indicies. It finds the points right after either rise above, or drop below the threshold value. Parameters ---------- input_array : numpy array A 1D numpy array with only numbers. threshold : float, list, numpy array the threshold value. Returns ------- dict The 'rise' value contains a numpy array containing the indicies of points that rise above the the threshold. The 'drop' value contains a numpy array containing the indicies of points that drop below the the threshold. \"\"\" if type ( threshold ) == float : # make a numpy array of the threshold value threshold = np . repeat ( threshold , len ( input_array )) elif ( type ( threshold ) == list or type ( threshold ) == np . ndarray ) and \\ len ( threshold ) != len ( input_array ): raise Exception ( \"Mismatch input and threshold arraty length.\" ) elif type ( threshold ) == list and len ( threshold ) == len ( input_array ): # make a numpy array of the threshold value threshold = np . array ( threshold ) elif type ( threshold ) == np . ndarray and len ( threshold ) == len ( input_array ): pass # The difference between the input value and the threshold number # Positive values mean the input is higher than threshold # Negative values mean the input is lower than threshold delta = input_array - threshold # This is an array 1 unit in the past delta_lag = np . concatenate ([ np . array ([ np . nan ]), delta ])[: - 1 ] # IF delta[i] > delta_lag[i], then the price rise above threshold # Because all elements are either +1, -1 or 0, the larger value has to be +1. # np.sign(delta) = +1, while np.sign(delta_lag) = -1 means yesterday the value # is lower than threshold and today's value is higher than the threshold-> rise above indices_rise_above = np . where ( np . sign ( delta ) > np . sign ( delta_lag )) # IF delta[i] < delta_lag[i], then the price drop below threshold indices_drop_below = np . where ( np . sign ( delta ) < np . sign ( delta_lag )) # Produce a dic of indicies for below and above return { 'rise' : indices_rise_above , 'drop' : indices_drop_below }","title":"find_crossover"},{"location":"EC_tools/read/#EC_tools.read.find_minute_EES","text":"Find the points of crossover given a set of EES value in a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters: histroy_data_intraday ( dataframe ) \u2013 The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry ( float ) \u2013 target entry price. target_exit ( float ) \u2013 target exit price. stop_exit ( float ) \u2013 target stop loss price. open_hr ( str , default: '0330' ) \u2013 The opening hour of trade in military time format. The default is \"0330\". close_hr ( str , default: '1930' ) \u2013 The closing hour of trade in military time format. The default is \"1930\". price_proxy ( str , default: 'Open' ) \u2013 The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox \u2013 The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction ( str , default: 'Neutral' ) \u2013 Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr ( str , default: '1925' ) \u2013 The final minute to finish off the trade in military time format. The default is '1925'. dt_scale ( str , default: 'datetime' ) \u2013 Raises: ValueError \u2013 Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns: EES_dict ( dict ) \u2013 A dictionary that cantains the possible EES points and time. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} Source code in EC_tools/read.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 def find_minute_EES ( histroy_data_intraday : pd . DataFrame , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0330\" , close_hr : str = \"1930\" , price_proxy : str = 'Open' , time_proxy : str = 'Time' , date_proxy : str = 'Date' , direction : str = 'Neutral' , close_trade_hr : str = '1925' , dt_scale : str = 'datetime' ) -> dict : \"\"\" Find the points of crossover given a set of EES value in a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters ---------- histroy_data_intraday : dataframe The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry : float target entry price. target_exit : float target exit price. stop_exit : float target stop loss price. open_hr : str, optional The opening hour of trade in military time format. The default is \"0330\". close_hr : str, optional The closing hour of trade in military time format. The default is \"1930\". price_proxy : str, optional The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox: The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction : str, optional Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr : str, optional The final minute to finish off the trade in military time format. The default is '1925'. dt_scale : Raises ------ ValueError Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns ------- EES_dict : dict A dictionary that cantains the possible EES points and time. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} \"\"\" # (This function can be made in one more layer of abstraction. Work on this later) # define subsample. turn the pandas series into a numpy array price_list = histroy_data_intraday [ price_proxy ] . to_numpy () time_list = histroy_data_intraday [ time_proxy ] . to_numpy () #print(\"time_list\", time_list[0], type(time_list[0])) # read in date list date_list = histroy_data_intraday [ date_proxy ] . to_numpy () # Temporary solution. Can be made using two to three time layer # make datetime list datetime_list = np . array ([ datetime . datetime . combine ( pd . to_datetime ( d ) . date (), t ) \\ for d , t in zip ( date_list , time_list )]) if dt_scale == \"time\" : time_proxy_list = time_list elif dt_scale == 'date' : time_proxy_list = date_list elif dt_scale == 'datetime' : time_proxy_list = datetime_list # Find the crossover indices entry_pt_dict = find_crossover ( price_list , target_entry ) exit_pt_dict = find_crossover ( price_list , target_exit ) stop_pt_dict = find_crossover ( price_list , stop_exit ) if direction == \"Neitral\" : #print(\"Neutral day\") # for 'Neutral' action, all info are empty entry_pts , entry_times = [], [] exit_pts , exit_times = [], [] stop_pts , stop_times = [], [] elif direction == \"Buy\" : #print(\"Finding Buy points.\") # for 'Buy' action EES sequence is drop,rise,drop entry_pts = price_list [ entry_pt_dict [ 'drop' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'drop' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'rise' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'rise' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'drop' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'drop' ][ 0 ]] elif direction == \"Sell\" : #print(\"Finding Sell points.\") # for 'Sell' action EES sequence is rise,drop,rise entry_pts = price_list [ entry_pt_dict [ 'rise' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'rise' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'drop' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'drop' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'rise' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'rise' ][ 0 ]] else : raise ValueError ( 'Direction has to be either Buy, Sell, or Neutral.' ) # Define the opening/closing time and closing price. # Here we choose 19:25 for final trade open_hr_str = open_hr . strftime ( \"%H%M\" ) close_hr_str = close_hr . strftime ( \"%H%M\" ) ## Find the closest price and datettime instead of having it at exactly the open time open_date_new , open_pt = find_closest_price ( histroy_data_intraday , target_hr = open_hr_str , direction = 'forward' , price_proxy = price_proxy , time_proxy = time_proxy ) open_date = date_list [ np . where ( time_list == open_date_new )[ 0 ]][ 0 ] open_datetime = datetime . datetime . combine ( pd . to_datetime ( open_date ) . date (), open_date_new ) # Find the closest price and datettime instead of having it at exactly the close time close_date_new , close_pt = find_closest_price ( histroy_data_intraday , target_hr = close_hr_str , direction = 'backward' , price_proxy = price_proxy , time_proxy = time_proxy ) close_date = date_list [ np . where ( time_list == close_date_new )[ 0 ]][ 0 ] close_datetime = datetime . datetime . combine ( pd . to_datetime ( close_date ) . date (), close_date_new ) # storage EES_dict = { 'entry' : list ( zip ( entry_times , entry_pts )), 'exit' : list ( zip ( exit_times , exit_pts )), 'stop' : list ( zip ( stop_times , stop_pts )), 'open' : tuple (( open_datetime , open_pt )), 'close' : tuple (( close_datetime , close_pt ))} #print('EES_dict', EES_dict['close']) return EES_dict","title":"find_minute_EES"},{"location":"EC_tools/read/#EC_tools.read.find_minute_EES_long","text":"Set the EES value given a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters: histroy_data_intraday ( dataframe ) \u2013 The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry ( float ) \u2013 target entry price. target_exit ( float ) \u2013 target exit price. stop_exit ( float ) \u2013 target stop loss price. open_hr ( str , default: '0330' ) \u2013 The opening hour of trade in military time format. The default is \"0330\". close_hr ( str , default: '1930' ) \u2013 The closing hour of trade in military time format. The default is \"1930\". price_approx ( str ) \u2013 The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox \u2013 The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction ( str , default: 'Neutral' ) \u2013 Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr ( str , default: '1925' ) \u2013 The final minute to finish off the trade in military time format. The default is '1925'. dt_scale ( str , default: 'datetime' ) \u2013 Raises: ValueError \u2013 Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns: EES_dict ( dict ) \u2013 A dictionary that cantains the possible EES points and time. Source code in EC_tools/read.py 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 def find_minute_EES_long ( histroy_data : pd . DataFrame , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0330\" , close_hr : str = \"1930\" , price_proxy : str = 'Open' , time_proxy : str = 'Time' , date_proxy : str = 'Date' , direction : str = 'Neutral' , close_trade_hr : str = '1925' , dt_scale : str = 'datetime' , first_date = None , last_date = None ) -> dict : \"\"\" Set the EES value given a time-series of minute intraday data. This function is the key for crossover loops in the backtest Parameters ---------- histroy_data_intraday : dataframe The histort intraday minute data. This assume the file contains the ohlc value of the day target_entry : float target entry price. target_exit : float target exit price. stop_exit : float target stop loss price. open_hr : str, optional The opening hour of trade in military time format. The default is \"0330\". close_hr : str, optional The closing hour of trade in military time format. The default is \"1930\". price_approx : str, optional The price approximator. The default uses the opening price of each minute as the price indicator. It calls in the 'Open' column in the history intradday minute dataframe The default is 'Open'. time_prox: The time proxy. This function assume the input time data come fomr the 'Time' column of the dataframe. The default is 'Time'. direction : str, optional Trade direction. Either \"Buy\", \"Sell\", or \"Neutral\". The default is 'Neutral'. close_trade_hr : str, optional The final minute to finish off the trade in military time format. The default is '1925'. dt_scale : Raises ------ ValueError Direction data can only be either \"Buy\", \"Sell\", or \"Neutral\". Returns ------- EES_dict : dict A dictionary that cantains the possible EES points and time. \"\"\" # (This function can be made in one more layer of abstraction. Work on this later) if first_date == None : first_date = histroy_data [ date_proxy ] . iloc [ 0 ] if last_date == None : last_date = histroy_data [ date_proxy ] . iloc [ - 1 ] print ( 'first_date, last_date' , first_date , last_date ) # define subsample. turn the pandas series into a numpy array price_list = histroy_data [ price_proxy ] . to_numpy () time_list = histroy_data [ time_proxy ] . to_numpy () # read in date list date_list = histroy_data [ date_proxy ] . to_numpy () # Temporary solution. Can be made using two to three time layer # make datetime list datetime_list = np . array ([ datetime . datetime . combine ( pd . to_datetime ( d ) . date (), t ) \\ for d , t in zip ( date_list , time_list )]) if dt_scale == \"time\" : time_proxy_list = time_list elif dt_scale == 'date' : time_proxy_list = date_list elif dt_scale == 'datetime' : time_proxy_list = datetime_list # Find the crossover indices entry_pt_dict = find_crossover ( price_list , target_entry ) exit_pt_dict = find_crossover ( price_list , target_exit ) stop_pt_dict = find_crossover ( price_list , stop_exit ) if direction == \"Neitral\" : #print(\"Neutral day\") # for 'Neutral' action, all info are empty entry_pts , entry_times = [], [] exit_pts , exit_times = [], [] stop_pts , stop_times = [], [] elif direction == \"Buy\" : #print(\"Finding Buy points.\") # for 'Buy' action EES sequence is drop,rise,drop entry_pts = price_list [ entry_pt_dict [ 'drop' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'drop' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'rise' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'rise' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'drop' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'drop' ][ 0 ]] elif direction == \"Sell\" : #print(\"Finding Sell points.\") # for 'Sell' action EES sequence is rise,drop,rise entry_pts = price_list [ entry_pt_dict [ 'rise' ][ 0 ]] entry_times = time_proxy_list [ entry_pt_dict [ 'rise' ][ 0 ]] exit_pts = price_list [ exit_pt_dict [ 'drop' ][ 0 ]] exit_times = time_proxy_list [ exit_pt_dict [ 'drop' ][ 0 ]] stop_pts = price_list [ stop_pt_dict [ 'rise' ][ 0 ]] stop_times = time_proxy_list [ stop_pt_dict [ 'rise' ][ 0 ]] else : raise ValueError ( 'Direction has to be either Buy, Sell, or Neutral.' ) # Define the opening/closing time and closing price. first_date_str = first_date . strftime ( \"%y-%m- %d \" ) last_date_str = last_date . strftime ( \"%y-%m- %d \" ) # Here we choose 19:25 for final trade open_hr_str = open_hr . strftime ( \"%H%M\" ) close_hr_str = close_hr . strftime ( \"%H%M\" ) ## Find the closest price and datettime instead of having it at exactly the open time open_date_new , open_pt = find_closest_price_datetime ( histroy_data , target_date = first_date , target_hr = open_hr_str , price_proxy = price_proxy , direction = 'forward' ) #open_date = date_list[np.where(time_list==open_date_new)[0]][0] open_date = datetime_list [ 0 ] open_datetime = datetime . datetime . combine ( open_date . date (), open_date_new ) # Find the closest price and datettime instead of having it at exactly the close time close_date_new , close_pt = find_closest_price_datetime ( histroy_data , target_date = last_date , target_hr = close_hr_str , price_proxy = price_proxy , direction = 'backward' ) #close_date = date_list[np.where(time_list==close_date_new)[0]][0] close_date = datetime_list [ - 1 ] close_datetime = datetime . datetime . combine ( close_date . date (), close_date_new ) # storage EES_dict = { 'entry' : list ( zip ( entry_times , entry_pts )), 'exit' : list ( zip ( exit_times , exit_pts )), 'stop' : list ( zip ( stop_times , stop_pts )), 'open' : tuple (( open_datetime , open_pt )), 'close' : tuple (( close_datetime , close_pt ))} print ( 'EES_dict' , EES_dict ) return EES_dict","title":"find_minute_EES_long"},{"location":"EC_tools/read/#EC_tools.read.find_minute_EES_range","text":"Find the points within a range of EES value in a time-series of minute intrday data. This function is the key for range loop in backtesting. Parameters: histroy_data_intraday ( DataFrame ) \u2013 The historical data. target_entry_range ( list [ float | int ] | tuple [ float | int ] ) \u2013 A range of entry price in the format of [lower_bound_price, upper_bound_price]. target_exit_range ( list [ float | int ] | tuple [ float | int ] ) \u2013 A range of exit price in the format of [lower_bound_price, upper_bound_price]. stop_exit ( float | int ) \u2013 The stop loss value. open_hr ( str , default: '0330' ) \u2013 The opening hour. The default is \"0330\". close_hr ( str , default: '1930' ) \u2013 The closing hour. The default is \"1930\". price_proxy ( str , default: 'Open' ) \u2013 The column name for the price. The default is 'Open'. time_proxy ( str , default: 'Time' ) \u2013 The column name for the time. The default is 'Time'. direction ( str , default: 'Neutral' ) \u2013 The direction of the trade. The default is 'Neutral'. dt_scale ( str , default: 'datetime' ) \u2013 datetime scale. It could be either 'time', 'date', or 'datetime'. It choose from either the time or date columns, or combine the two into datetime. The default is 'datetime'. Returns: range_dict ( TYPE ) \u2013 A dictionary contianing the points in a day that falls within the entry and exit range, as well as points that crossover to the stoploss, along with the open and close points of the day. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} Source code in EC_tools/read.py 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 def find_minute_EES_range ( histroy_data_intraday : pd . DataFrame , target_entry_range : list [ float | int ] | tuple [ float | int ], target_exit_range : list [ float | int ] | tuple [ float | int ], stop_exit : float | int , open_hr : str = \"0330\" , close_hr : str = \"1930\" , price_proxy : str = 'Open' , date_proxy : str = 'Date' , time_proxy : str = 'Time' , direction : str = 'Neutral' , dt_scale : str = 'datetime' ) -> dict [ str , list | tuple ]: \"\"\" Find the points within a range of EES value in a time-series of minute intrday data. This function is the key for range loop in backtesting. Parameters ---------- histroy_data_intraday : pd.DataFrame The historical data. target_entry_range : list[float|int] | tuple[float|int] A range of entry price in the format of [lower_bound_price, upper_bound_price]. target_exit_range : list[float|int] | tuple[float|int] A range of exit price in the format of [lower_bound_price, upper_bound_price]. stop_exit : float | int The stop loss value. open_hr : str, optional The opening hour. The default is \"0330\". close_hr : str, optional The closing hour. The default is \"1930\". price_proxy : str, optional The column name for the price. The default is 'Open'. time_proxy : str, optional The column name for the time. The default is 'Time'. direction : str, optional The direction of the trade. The default is 'Neutral'. dt_scale : str, optional datetime scale. It could be either 'time', 'date', or 'datetime'. It choose from either the time or date columns, or combine the two into datetime. The default is 'datetime'. Returns ------- range_dict : TYPE A dictionary contianing the points in a day that falls within the entry and exit range, as well as points that crossover to the stoploss, along with the open and close points of the day. It has the following format: {'entry': [(entry_times,entry_pts), ...], 'exit': [(exit_times,exit_pts), ...], 'stop': [(stop_times,stop_pts), ...], 'open': (open_datetime, open_pt), 'close': (close_datetime, close_pt)} \"\"\" # define subsample. turn the pandas series into a numpy array price_array = histroy_data_intraday [ price_proxy ] . to_numpy () time_array = histroy_data_intraday [ time_proxy ] . to_numpy () # read in date list date_array = histroy_data_intraday [ date_proxy ] . to_numpy () # Temporary solution. Can be made using two to three time layer # make datetime list datetime_array = np . array ([ datetime . datetime . combine ( pd . to_datetime ( d ) . date (), t ) \\ for d , t in zip ( date_array , time_array )]) if dt_scale == \"time\" : time_proxy_array = time_array elif dt_scale == 'date' : time_proxy_array = date_array elif dt_scale == 'datetime' : time_proxy_array = datetime_array # Find the crossover indices entry_region_dict = find_range ( price_array , target_entry_range ) exit_region_dict = find_range ( price_array , target_exit_range ) # Stop loss find crossover stop_pt_dict = find_crossover ( price_array , stop_exit ) if direction == \"Neitral\" : # for 'Neutral' action, all info are empty entry_pts , entry_times = [], [] exit_pts , exit_times = [], [] stop_pts , stop_times = [], [] elif direction == \"Buy\" : #print(\"Finding Buy points.\") # for 'Buy' action EES sequence is drop,rise,drop entry_pts = price_array [ entry_region_dict [ 'range_indices' ][ 0 ]] entry_times = time_proxy_array [ entry_region_dict [ 'range_indices' ][ 0 ]] exit_pts = price_array [ exit_region_dict [ 'range_indices' ][ 0 ]] exit_times = time_proxy_array [ exit_region_dict [ 'range_indices' ][ 0 ]] stop_pts = price_array [ stop_pt_dict [ 'drop' ][ 0 ]] stop_times = time_proxy_array [ stop_pt_dict [ 'drop' ][ 0 ]] elif direction == \"Sell\" : #print(\"Finding Sell points.\") # for 'Sell' action EES sequence is rise,drop,rise entry_pts = price_array [ entry_region_dict [ 'range_indices' ][ 0 ]] entry_times = time_proxy_array [ entry_region_dict [ 'range_indices' ][ 0 ]] exit_pts = price_array [ exit_region_dict [ 'range_indices' ][ 0 ]] exit_times = time_proxy_array [ exit_region_dict [ 'range_indices' ][ 0 ]] stop_pts = price_array [ stop_pt_dict [ 'rise' ][ 0 ]] stop_times = time_proxy_array [ stop_pt_dict [ 'rise' ][ 0 ]] # Define the closing time and closing price. Here we choose 19:25 for final trade open_hr_str = open_hr . strftime ( \"%H%M\" ) close_hr_str = close_hr . strftime ( \"%H%M\" ) ## Find the closest price and datettime instead of having it at exactly the open time open_date_new , open_pt = find_closest_price ( histroy_data_intraday , target_hr = open_hr_str , direction = 'forward' ) open_date = date_array [ np . where ( time_array == open_date_new )[ 0 ]][ 0 ] open_datetime = datetime . datetime . combine ( pd . to_datetime ( open_date ) . date (), open_date_new ) ## Find the closest price and datettime instead of having it at exactly the close time close_date_new , close_pt = find_closest_price ( histroy_data_intraday , target_hr = close_hr_str , direction = 'backward' ) close_date = date_array [ np . where ( time_array == close_date_new )[ 0 ]][ 0 ] close_datetime = datetime . datetime . combine ( pd . to_datetime ( close_date ) . date (), close_date_new ) range_dict = { 'entry' : list ( zip ( entry_times , entry_pts )), 'exit' : list ( zip ( exit_times , exit_pts )), 'stop' : list ( zip ( stop_times , stop_pts )), 'open' : tuple (( open_datetime , open_pt )), 'close' : tuple (( close_datetime , close_pt ))} #print(range_dict) return range_dict","title":"find_minute_EES_range"},{"location":"EC_tools/read/#EC_tools.read.find_price_by_time","text":"A function to search for the opening price of the day. If at the opening hour, there are no bid or price information, the script loop through the next 30 minutes to find the opening price. Parameters: history_data_daily ( dataframe ) \u2013 The historical daily data. history_data_minute ( dataframe ) \u2013 The historical minute data. open_hr ( str , default: '0330' ) \u2013 Defining the opening hour. The default is '0330'. Returns: open_price_data ( dataframe ) \u2013 A table consist of three columns: 'Date', 'Time', and 'Open Price'. Source code in EC_tools/read.py 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 def find_price_by_time ( history_data_daily : pd . DataFrame , history_data_minute : pd . DataFrame , open_hr : str = '0330' ) -> pd . DataFrame : #tested \"\"\" A function to search for the opening price of the day. If at the opening hour, there are no bid or price information, the script loop through the next 30 minutes to find the opening price. Parameters ---------- history_data_daily : dataframe The historical daily data. history_data_minute : dataframe The historical minute data. open_hr : str, optional Defining the opening hour. The default is '0330'. Returns ------- open_price_data: dataframe A table consist of three columns: 'Date', 'Time', and 'Open Price'. \"\"\" date_list = history_data_daily [ 'Date' ] . to_list () open_price_data = [] #loop through daily data to get the date for date in date_list : day_data = history_data_minute [ history_data_minute [ 'Date' ] == date ] # Find the closest hour and price open_hr_dt , open_price = find_closest_price ( day_data , target_hr = '0330' ) #print('open_price',open_price) if type ( open_price ) == float : pass elif len ( open_price ) != 1 : print ( open_price ) #storage #open_price_data.append((date.to_pydatetime(), open_hr_dt , # open_price.item())) open_price_data . append (( date . to_pydatetime (), open_hr_dt , open_price )) open_price_data = pd . DataFrame ( open_price_data , columns = [ 'Date' , 'Time' , 'Open Price' ]) return open_price_data","title":"find_price_by_time"},{"location":"EC_tools/read/#EC_tools.read.find_range","text":"A function that find the points' indicies given a target range. It finds the points within that range . Parameters: input_array ( ndarray ) \u2013 A 1D numpy array with only numbers. target_range ( tuple [ float | int ] | list [ float | int ] | ndarray ) \u2013 A tuple, list, or array of target range. e.g. [0,1], (0,1),... The first element is the lower bound and the second the upper bound. Raises: Exception \u2013 When the target_range input does not contain exactly two values. Returns: dict \u2013 range_dict contains the indices of the element of the input_array that is within the target_range, outside the target_range, and the boundaries of the range. Source code in EC_tools/read.py 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 def find_range ( input_array : np . ndarray , target_range : tuple [ float | int ] | list [ float | int ] | np . ndarray ) \\ -> dict : \"\"\" A function that find the points' indicies given a target range. It finds the points within that range . Parameters ---------- input_array : np.ndarray A 1D numpy array with only numbers. target_range : tuple[float|int] | list[float|int] | np.ndarray A tuple, list, or array of target range. e.g. [0,1], (0,1),... The first element is the lower bound and the second the upper bound. Raises ------ Exception When the target_range input does not contain exactly two values. Returns ------- dict range_dict contains the indices of the element of the input_array that is within the target_range, outside the target_range, and the boundaries of the range. \"\"\" if len ( target_range ) != 2 : raise Exception ( \"Target Range input must contains exactly two values.\" ) if not target_range [ 1 ] > target_range [ 0 ]: raise Exception ( \"Second element is not larger than the first. \\ Target Range input must in the form of [lower_bound, \\ upper_bound].\" ) lower_bound = np . repeat ( target_range [ 0 ], len ( input_array )) upper_bound = np . repeat ( target_range [ 1 ], len ( input_array )) delta_lower = input_array - lower_bound delta_upper = upper_bound - input_array delta = np . sign ( delta_upper ) * np . sign ( delta_lower ) #print(np.sign(delta_lower), np.sign(delta_upper), delta) #print(delta_lower, delta_upper, delta) range_indices = np . where ( delta > 0 ) bound_indices = np . where ( delta == 0 ) outbound_indices = np . where ( delta < 0 ) return { 'range_indices' : range_indices , 'outbound_indices' : outbound_indices , 'bound_indices' : bound_indices }","title":"find_range"},{"location":"EC_tools/read/#EC_tools.read.get_apc_from_server","text":"Use the ArgusPossibilityCurve.py script to extract the APCin the wide format from the server. Note that the latest version is 1.1.0 (21 March 2024). Parameters: username ( str ) \u2013 The username of your argus account. password ( srt ) \u2013 The password of your argus account. start_date ( str ) \u2013 The desired start date of the apc, it should be in tcategorieshe format of this: \"2020-01-20\" end_date ( str ) \u2013 The end date of the apc. Similar to the above. categories ( str or list ) \u2013 The asset name. It could be either 1) A string such as \"Argus Nymex WTI month 1, Daily\", or 2) A list that contain the list of asset names, like this: ['Argus Nymex WTI month 1, Daily', 'Argus Nymex Heating oil month 1, Daily', ...] keywords ( Union [ str , list ] , default: None ) \u2013 Keywords in the categories to look for. Same dimension as the categories input. symbol ( Union [ str , list ] , default: None ) \u2013 Symbols to write in the new column. Same dimension as the categories input. Returns: apc_data ( list ) \u2013 A list that contain the spread of APC with the following collumns: Index(['Forecast Period', 'CATEGORY', '0.0025', '0.005', '0.0075', '0.01', '0.0125', '0.015', '0.0175', '0.02', ... '0.9775', '0.98', '0.9825', '0.985', '0.9875', '0.99', '0.9925', '0.995', '0.9975', 'symbol'], dtype='object', length=402) Source code in EC_tools/read.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get_apc_from_server ( username : str , password : str , start_date : str , end_date : str , categories : Union [ str , list ], keywords : Union [ str , list ] = None , symbol : Union [ str , list ] = None ) -> pd . DataFrame : \"\"\" Use the ArgusPossibilityCurve.py script to extract the APCin the wide format from the server. Note that the latest version is 1.1.0 (21 March 2024). Parameters ---------- username : str The username of your argus account. password : srt The password of your argus account. start_date : str The desired start date of the apc, it should be in tcategorieshe format of this: \"2020-01-20\" end_date : str The end date of the apc. Similar to the above. categories : str or list The asset name. It could be either 1) A string such as \"Argus Nymex WTI month 1, Daily\", or 2) A list that contain the list of asset names, like this: ['Argus Nymex WTI month 1, Daily', 'Argus Nymex Heating oil month 1, Daily', ...] keywords: str or list Keywords in the categories to look for. Same dimension as the categories input. symbol: str or list Symbols to write in the new column. Same dimension as the categories input. Returns ------- apc_data : list A list that contain the spread of APC with the following collumns: Index(['Forecast Period', 'CATEGORY', '0.0025', '0.005', '0.0075', '0.01', '0.0125', '0.015', '0.0175', '0.02', ... '0.9775', '0.98', '0.9825', '0.985', '0.9875', '0.99', '0.9925', '0.995', '0.9975', 'symbol'], dtype='object', length=402) \"\"\" print ( 'symbol' , symbol ) # Check if categories and keywords varaible matches in dimension # Login and Authentication apc = ArgusPossibilityCurves ( username = username , password = password ) apc . authenticate () apc . getMetadataCSV ( filepath = \"argus_latest_meta.csv\" ) # Make the start and end date in the datetime.date format start_date = datetime . date ( int ( start_date [: 4 ]), int ( start_date [ 5 : 7 ]), int ( start_date [ 8 : 10 ])) end_date = datetime . date ( int ( end_date [: 4 ]), int ( end_date [ 5 : 7 ]), int ( end_date [ 8 : 10 ])) if type ( categories ) is str : # if the asset name input is a string, pull only one # This retrieve the apc from the server apc_data = apc . getPossibilityCurves ( start_date = start_date , end_date = end_date , categories = [ categories ]) # Delete irrelavant columns #apc_data = apc_data.drop(columns=['PUBLICATION_DATE', # 'CONTINUOUS_FORWARD', # 'PRICE_UNIT', 'TIMESTAMP']) #apc_data.columns = ['Forecast_Period'] + [i for i in apc_data.columns[1:]] # Add the term \"APC\" in each column # If no specific symbol input, use the name of the categories if symbol == None : symbol = categories else : pass # make a new column with nothing in it. Then write the short symbol apc_data [ 'symbol' ] = None apc_data [ 'symbol' ] = np . where ( apc_data [ 'CATEGORY' ] . apply ( lambda x : keywords in x ), symbol , apc_data [ 'symbol' ]) elif type ( categories ) is list : # if the asset name input is a list, pull a list of APC apc_data = apc . getPossibilityCurves ( start_date = start_date , end_date = end_date , categories = categories ) #apc_data = apc_data.drop(columns=['PUBLICATION_DATE', # 'CONTINUOUS_FORWARD', # 'PRICE_UNIT', 'TIMESTAMP']) #apc_data.columns = ['Forecast_Period'] + [i for i in apc_data.columns[1:]] apc_data [ 'symbol' ] = None # add new column with symbols corresponding to the keywords. for i , c in zip ( keywords , symbol ): apc_data [ 'symbol' ] = np . where ( apc_data [ 'CATEGORY' ] . apply ( lambda x : i in x ), c , apc_data [ 'symbol' ]) # Drop the Category column #apc_data = apc_data.drop(columns=['CATEGORY']) return apc_data","title":"get_apc_from_server"},{"location":"EC_tools/read/#EC_tools.read.group_trade","text":"A function to group positions by trade id along with some given conditions. Parameters: position_pool ( list ) \u2013 The position_pool list inside a portfolio object. select_func ( Callable function , default: lambda x: True ) \u2013 Additional functions for unique condition for grouping trade. The default is a lambda function that return True (It will return true no matter what). Returns: list \u2013 A new list with each traded grouped as a list element in a bucket Source code in EC_tools/read.py 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 def group_trade ( position_pool : list , select_func : Callable [[ int ], bool ] = lambda x : True ) -> list : # \"\"\" A function to group positions by trade id along with some given conditions. Parameters ---------- position_pool : list The position_pool list inside a portfolio object. select_func : Callable function, optional Additional functions for unique condition for grouping trade. The default is a lambda function that return True (It will return true no matter what). Returns ------- list A new list with each traded grouped as a list element in a bucket \"\"\" # A function that matches the trade_id and group them in a list # First sort the pool by trade_id. pos_pool = position_pool . copy () pos_pool . sort ( key = lambda x : x . pos_id ) bucket , temp = [], [] trade_id_now = pos_pool [ 0 ] . pos_id i = 0 while i < len ( pos_pool ): # loop through each position, if the pos_id == trade_id_now, save in # a temp list if pos_pool [ i ] . pos_id == trade_id_now : if select_func ( i ): temp . append ( pos_pool [ i ]) i = i + 1 elif pos_pool [ i ] . pos_id != trade_id_now : # Otherwise, put the temp list into the overall bucket, restart # the counter and make a new temp list to repeat the process #print('switch') #print(i, pos_pool[i].pos_id) bucket . append ( temp ) trade_id_now = pos_pool [ i ] . pos_id temp = [] temp . append ( pos_pool [ i ]) i = i + 1 return bucket","title":"group_trade"},{"location":"EC_tools/read/#EC_tools.read.merge_portara_data","text":"Merging the Portara Daily and Minute table. The merger is operated on the two columns: 'Date only' and 'Price Code'. LEGACY function from Abbe. Not in use at the moment. Parameters: table1 ( dataframe ) \u2013 The pandas dataframe Daily pricing data. table2 ( dataframe ) \u2013 The Portara Minute pricing data. Returns: new_table ( pandas dataframe ) \u2013 The new merged table. Source code in EC_tools/read.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def merge_portara_data ( table1 : pd . DataFrame , table2 : pd . DataFrame ) -> pd . DataFrame : \"\"\" Merging the Portara Daily and Minute table. The merger is operated on the two columns: 'Date only' and 'Price Code'. LEGACY function from Abbe. Not in use at the moment. Parameters ---------- table1 : dataframe The pandas dataframe Daily pricing data. table2 : dataframe The Portara Minute pricing data. Returns ------- new_table : pandas dataframe The new merged table. \"\"\" # A function that merges # construct a master table of price across all minutes # merge the minute and daily data based on Date only and Price code new_table = table1 . merge ( table2 , on = [ 'Date only' , 'Price Code' ], how = 'right' ) # add c1 to the price code val = 0 table2 [ 'Price Code' ] = table2 [ 'symbol' ] + 'c' + str ( val + 1 ) new_table = table1 . merge ( table2 , on = [ 'Date only' , 'Price Code' ], how = 'right' ) del table1 , table2 # drop contract columns new_table = new_table . drop ( columns = 'Contract' ) return new_table","title":"merge_portara_data"},{"location":"EC_tools/read/#EC_tools.read.merge_raw_data","text":"A function that merges a list of CSV files into one CSV file. Parameters: filename_list ( list ) \u2013 A list of filename if CSV to be Concatenated. save_filename ( str ) \u2013 The filename for saving. sort_by ( str , default: 'PERIOD' ) \u2013 The column name used in the sorting. The default is \"PERIOD\". Returns: merged_data ( dataframe ) \u2013 The merged data. Source code in EC_tools/read.py 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 def merge_raw_data ( filename_list : list [ str ], save_filename : str , sort_by : str = \"PERIOD\" ) -> pd . DataFrame : \"\"\" A function that merges a list of CSV files into one CSV file. Parameters ---------- filename_list : list A list of filename if CSV to be Concatenated. save_filename : str The filename for saving. sort_by : str, optional The column name used in the sorting. The default is \"PERIOD\". Returns ------- merged_data : dataframe The merged data. \"\"\" merged_data = concat_CSVtable ( filename_list , sort_by = sort_by ) merged_data . to_csv ( save_filename , index = False ) return merged_data","title":"merge_raw_data"},{"location":"EC_tools/read/#EC_tools.read.open_portfolio","text":"A handy function to open a portfolio. Nothing special but easy to remember. Parameters: filename ( str ) \u2013 The filename of the Portfolio object in pickle format . Returns: portfo ( Portfolio ) \u2013 Source code in EC_tools/read.py 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 def open_portfolio ( filename : str ): \"\"\" A handy function to open a portfolio. Nothing special but easy to remember. Parameters ---------- filename : str The filename of the Portfolio object in pickle format . Returns ------- portfo : Portfolio \"\"\" file = open ( filename , 'rb' ) portfo = pickle . load ( file ) file . close () return portfo","title":"open_portfolio"},{"location":"EC_tools/read/#EC_tools.read.portara_data_handling","text":"A function that handle Portara's data. LEGACY function from Abbe. Not in Use at the moment. Parameters: portara_dat ( pandas dataframe ) \u2013 Input Portara data. Returns: portara_dat ( pandas dataframe ) \u2013 Output post-processed Portara data. Source code in EC_tools/read.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def portara_data_handling ( portara_dat : pd . DataFrame ) -> pd . DataFrame : \"\"\" A function that handle Portara's data. LEGACY function from Abbe. Not in Use at the moment. Parameters ---------- portara_dat : pandas dataframe Input Portara data. Returns ------- portara_dat : pandas dataframe Output post-processed Portara data. \"\"\" # now tidy up the data minutes = np . concatenate (( np . arange ( 30 , 60 ), np . arange ( 100 , 160 ), np . arange ( 200 , 260 ), np . arange ( 300 , 331 ))) minutes_2 = np . concatenate (( np . arange ( 30 , 60 ), # half past to 1 np . arange ( 100 , 160 ), # 1 to 2 np . arange ( 200 , 231 ))) # 2 to 3 for i in np . flip ( minutes ): # if there are no trades Portara doesn't create a bar so we have to go backwards to the last bar where a trade # happened to get the price iff there is no bar for 330 - otherwise the price is 'nan' price_330 = np . where ( np . isnan ( portara_dat [ 'Close 330' ] . to_numpy ()), portara_dat [ 'Close ' + str ( i )] . to_numpy (), portara_dat [ 'Close 330' ] . to_numpy ()) portara_dat [ 'Close 330' ] = price_330 for i in np . flip ( minutes_2 ): # if there are no trades Portara doesn't create a bar so we have to go backwards to the last bar where a trade # happened to get the price iff there is no bar for 330 (getting 230 prices for when daylight savings moving UK to BST (1 hour forward) from UTC/GMT price_230 = np . where ( np . isnan ( portara_dat [ 'Close 230' ] . to_numpy ()), portara_dat [ 'Close ' + str ( i )] . to_numpy (), portara_dat [ 'Close 230' ] . to_numpy ()) portara_dat [ 'Close 230' ] = price_230 portara_dat = portara_dat [[ 'Date only' , 'Close 330' , 'Settle' , 'Price Code' , 'Contract Symbol' , 'Close 230' ]] portara_dat [ 'daylight saving forward date' ] = portara_dat [ 'Date only' ] . apply ( lambda x : pd . to_datetime ( str ( x . year ) + '-03-31' )) # date for daylight savings start portara_dat [ 'daylight saving back date' ] = portara_dat [ 'Date only' ] . apply ( lambda x : pd . to_datetime ( str ( x . year ) + '-10-27' )) # date for daylight savings end portara_dat [ 'Close 330' ] = np . where ( np . logical_and ( portara_dat [ 'Date only' ] > portara_dat [ 'daylight saving forward date' ], portara_dat [ 'Date only' ] < portara_dat [ 'daylight saving back date' ]), portara_dat [ 'Close 230' ], portara_dat [ 'Close 330' ] ) portara_dat = portara_dat [[ 'Date only' , 'Close 330' , 'Settle' , 'Price Code' , 'Contract Symbol' ]] portara_dat = portara_dat . sort_values ( by = 'Date only' ) # dates in ascending order return portara_dat","title":"portara_data_handling"},{"location":"EC_tools/read/#EC_tools.read.read_apc_data","text":"Nothing Special. Just a shorthand function to read the apc Parameters: filename ( str ) \u2013 APC CSVfilename. Returns: data ( Data Frame ) \u2013 APC in dataframe. Source code in EC_tools/read.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def read_apc_data ( filename : str ) -> pd . DataFrame : \"\"\" Nothing Special. Just a shorthand function to read the apc Parameters ---------- filename : str APC CSVfilename. Returns ------- data : Data Frame APC in dataframe. \"\"\" # This function should be used in conjuction with get_apc_from_server(). # The data should be pulled from the server using that function data = pd . read_csv ( filename ) return data","title":"read_apc_data"},{"location":"EC_tools/read/#EC_tools.read.read_portara_daily_data","text":"A generic function that read the Portara Data in a suitable form. The function itself only read a single csv file at a time. LEGACY function from Abbe. Use the function 'read_reformat_Portara_daily_data' instead. Parameters: filename ( str ) \u2013 The filename in the correct address. symbol ( str ) \u2013 A short symbol for the asset. start_date ( str ) \u2013 The start date of the query. e.g, \"2024-01-13\". end_date ( str ) \u2013 The end date of the query. e.g, \"2024-01-18\". column_select ( list [ str ] , default: ['Settle', 'Price Code', 'Contract Symbol', 'Date only'] ) \u2013 A list of columns name to select for in the master file. The default is ['Settle', 'Price Code', 'Contract Symbol', 'Date only'] Returns: portara_dat ( 2D pandas dataframe ) \u2013 The Portara daily data Source code in EC_tools/read.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def read_portara_daily_data ( filename : str , symbol : str , start_date : str , end_date : str , column_select : list [ str ] = [ 'Settle' , 'Price Code' , 'Contract Symbol' , 'Date only' ]) -> \\ pd . DataFrame : \"\"\" A generic function that read the Portara Data in a suitable form. The function itself only read a single csv file at a time. LEGACY function from Abbe. Use the function 'read_reformat_Portara_daily_data' instead. Parameters ---------- filename : str The filename in the correct address. symbol : str A short symbol for the asset. start_date: str The start date of the query. e.g, \"2024-01-13\". end_date: str The end date of the query. e.g, \"2024-01-18\". column_select: 1D list A list of columns name to select for in the master file. The default is ['Settle', 'Price Code', 'Contract Symbol', 'Date only'] Returns ------- portara_dat: 2D pandas dataframe The Portara daily data \"\"\" # Read downloaded data using panda portara_dat = pd . read_csv ( filename ) # A list of symbol portara_dat [ 'symbol' ] = symbol # Transform the date format from 20160104 to 2016-01-04 00:00:00 (panda timestamp) portara_dat [ 'Date' ] = portara_dat [ 'Date' ] . apply ( lambda x : str ( x )[ 0 : 4 ] + '-' + str ( x )[ 4 : 6 ] + '-' + str ( x )[ 6 :]) portara_dat [ 'Date' ] = pd . to_datetime ( portara_dat [ 'Date' ]) portara_dat [ 'Date only' ] = portara_dat [ 'Date' ] #2016-01-04 00:00:00 format # Datetime beyond 2020-12-14 is accepted beyond 2020-12-14 # Select datetime between start_date and end_date bools = portara_dat [ 'Date' ] . apply ( lambda x : x >= pd . to_datetime ( start_date ) and x <= pd . to_datetime ( end_date )) # Select for the data that fits the bool condition (date after 2020-12-14) portara_dat = portara_dat [ bools ] val = 0 # add c1 to the back of CL portara_dat [ 'Price Code' ] = portara_dat [ 'symbol' ] + 'c' + str ( val + 1 ) contract_year = portara_dat [ 'Contract' ] . apply ( lambda x : str ( x )[ - 3 : - 1 ]) # Get contract year 2021->21 contract_month = portara_dat [ 'Contract' ] . apply ( lambda x : str ( x )[ - 1 ]) # Get contract month # make a new column with CL21F from CLA2021F portara_dat [ 'Contract Symbol' ] = portara_dat [ 'symbol' ] + contract_year + contract_month # Select for only the following 4 columns because the others are not relevant to us portara_dat = portara_dat [ column_select ] return portara_dat","title":"read_portara_daily_data"},{"location":"EC_tools/read/#EC_tools.read.read_portara_minute_data","text":"A modified version of the generic Portara reading function specifically for the 1 minute data. LEGACY function from Abbe. Use the function 'read_reformat_Portara_minute_data' instead. Parameters: filename ( str ) \u2013 The filename in the correct address. symbol ( str ) \u2013 A short symbol for the asset. start_date \u2013 The start date of the query. e.g, \"2024-01-13\". end_date \u2013 The end date of the query. e.g, \"2024-01-18\". start_filter_hour ( int , default: 30 ) \u2013 The start time for filtering by hours. The default is 30 because of the london trading hours end_filter_hour ( int , default: 331 ) \u2013 The end time for filtering by hours. The default is 331. Returns: portara_dat_2 ( 2D panda dataframe ) \u2013 The Portara minute data. Source code in EC_tools/read.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def read_portara_minute_data ( filename , symbol , start_date , end_date , start_filter_hour = 30 , end_filter_hour = 331 , column_select = []): \"\"\" A modified version of the generic Portara reading function specifically for the 1 minute data. LEGACY function from Abbe. Use the function 'read_reformat_Portara_minute_data' instead. Parameters ---------- filename : str The filename in the correct address. symbol : str A short symbol for the asset. start_date: str The start date of the query. e.g, \"2024-01-13\". end_date: str The end date of the query. e.g, \"2024-01-18\". start_filter_hour : int, optional The start time for filtering by hours. The default is 30 because of the london trading hours end_filter_hour : int, optional The end time for filtering by hours. The default is 331. Returns ------- portara_dat_2 : 2D panda dataframe The Portara minute data. \"\"\" # Maybe first select for date then select for time? val = 0 # Reading only these column portara_dat_2 = pd . read_csv ( filename , names = [ 'Date' , 'Time' , 'Low' , 'High' , 'Open' , 'Close' , 'Trade Volume' , 'Contract' ]) # Add a column of symbol portara_dat_2 [ 'symbol' ] = symbol #print(portara_dat_2,'9') # Transform the date format from 20160104 to 2016-01-04 00:00:00 (panda timestamp) portara_dat_2 [ 'Date' ] = portara_dat_2 [ 'Date' ] . apply ( lambda x : str ( x )[ 0 : 4 ] + '-' + str ( x )[ 4 : 6 ] + '-' + str ( x )[ 6 :]) portara_dat_2 [ 'Date' ] = pd . to_datetime ( portara_dat_2 [ 'Date' ]) portara_dat_2 [ 'Date only' ] = portara_dat_2 [ 'Date' ] # only select time within the range of starting price and ending price bools = portara_dat_2 [ 'Time' ] . apply ( lambda x : x in np . arange ( start_filter_hour , end_filter_hour )) # for the moment need only price at 330 so filtering for prices at 330 and few hours before portara_dat_2 = portara_dat_2 [ bools ] # Select for only these five columns portara_dat_2 = portara_dat_2 [[ 'Date only' , 'Time' , 'Close' , 'Contract' , 'symbol' ]] #print(portara_dat_2,'5') # Pivot: Return reshaped DataFrame organized by given index / column values. # Make the main columns time basedm and indexed portara_dat_2 = portara_dat_2 . pivot ( index = [ 'Date only' , 'Contract' , 'symbol' ], columns = 'Time' , values = 'Close' ) # make new column order by ['Date only', 'Contract', 'symbol'] and reset index to numbers portara_dat_2 . reset_index ( inplace = True ) #print(portara_dat_2,'pivot') # add multiple columns list_names = [ 'Close ' + str ( i ) for i in portara_dat_2 . columns [ 3 :] . to_list ()] # rename the columns with times portara_dat_2 . columns = [ 'Date only' , 'Contract' , 'symbol' ] + list_names # Select for data after first date and end date bools = portara_dat_2 [ 'Date only' ] . apply ( lambda x : x >= pd . to_datetime ( start_date ) and x <= pd . to_datetime ( end_date )) # filter for data after given date portara_dat_2 = portara_dat_2 [ bools ] # add c1 for front month contract portara_dat_2 [ 'Price Code' ] = portara_dat_2 [ 'symbol' ] + 'c' + str ( val + 1 ) return portara_dat_2","title":"read_portara_minute_data"},{"location":"EC_tools/read/#EC_tools.read.read_reformat_APC_data","text":"Read and reformat APC data Parameters: filename ( str ) \u2013 APC filename. time_proxies ( list [ str ] , default: ['PUBLICATION_DATE', 'PERIOD'] ) \u2013 A list of time (or Date) proxy. These are the column name in the DataFrame. The default is ['PUBLICATION_DATE', 'PERIOD']. Returns: DataFrame \u2013 Source code in EC_tools/read.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def read_reformat_APC_data ( filename : str , time_proxies : list [ str ] = [ 'PUBLICATION_DATE' , 'PERIOD' ]) -> pd . DataFrame : \"\"\" Read and reformat APC data Parameters ---------- filename : str APC filename. time_proxies : list[str], optional A list of time (or Date) proxy. These are the column name in the DataFrame. The default is ['PUBLICATION_DATE', 'PERIOD']. Returns ------- DataFrame \"\"\" signal_data = pd . read_csv ( filename ) if type ( time_proxies ) == str : time_proxies = [ time_proxies ] for time_proxy in time_proxies : signal_data [ time_proxy ] = [ datetime . datetime . strptime ( x , '%Y-%m- %d ' ) for x in signal_data [ time_proxy ]] #signal_data[time_proxy_2] = [datetime.datetime.strptime(x, '%Y-%m-%d') # for x in signal_data[time_proxy_2]] #signal_data_reindex = signal_data.set_index('Forecast Period',drop=False) signal_data_reindex = signal_data return signal_data #signal_data_reindex","title":"read_reformat_APC_data"},{"location":"EC_tools/read/#EC_tools.read.read_reformat_Portara_daily_data","text":"Reformat the Portara minute data in a format readable by the scripts. Parameters: filename ( str ) \u2013 The filename of the Portara minute data. Returns: history_data ( pandas dataframe ) \u2013 The reformatted table. Source code in EC_tools/read.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 def read_reformat_Portara_daily_data ( filename : str , add_col_data : dict = {}) -> \\ pd . DataFrame : \"\"\" Reformat the Portara minute data in a format readable by the scripts. Parameters ---------- filename : str The filename of the Portara minute data. Returns ------- history_data : pandas dataframe The reformatted table. \"\"\" history_data = pd . read_csv ( filename ) history_data . columns = [ 'Date' , 'Open' , 'High' , 'Low' , 'Settle' , 'Volume' , 'OpenInterest' , 'Contract Code' ] # change the date from 20220222 (int) to '2022-02-22' (str) history_data [ 'Date' ] = [ datetime . datetime . strptime ( str ( x )[ 0 : 4 ] + str ( x )[ 4 : 6 ] + str ( x )[ 6 :], '%Y%m %d ' ) for x in history_data [ 'Date' ]] #history_data_reindex = history_data.set_index('Date',drop=False) history_data_reindex = history_data match add_col_data : case {} | [] | None : pass case _ : for key in add_col_data : history_data_reindex [ key ] = add_col_data [ key ] return history_data","title":"read_reformat_Portara_daily_data"},{"location":"EC_tools/read/#EC_tools.read.read_reformat_Portara_minute_data","text":"Reformat the Portara minute data in a format readable by the scripts. Parameters: filename ( str ) \u2013 The filename of the Portara minute data. Returns: history_data ( pandas dataframe ) \u2013 The reformatted table. Source code in EC_tools/read.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 def read_reformat_Portara_minute_data ( filename : str , add_col_data : dict = {}, time_to_datetime = False ) -> \\ pd . DataFrame : \"\"\" Reformat the Portara minute data in a format readable by the scripts. Parameters ---------- filename : str The filename of the Portara minute data. Returns ------- history_data : pandas dataframe The reformatted table. \"\"\" history_data = pd . read_csv ( filename ) history_data . columns = [ 'Date' , 'Time' , 'Open' , 'High' , 'Low' , 'Settle' , 'Volume' , 'Contract Code' ] # include a function that let user to choose the reformat? # change the date from 20220222 (int) to '2022-02-22' (str) history_data [ 'Date' ] = [ datetime . datetime . strptime ( str ( x )[ 0 : 4 ] + str ( x )[ 4 : 6 ] \\ + str ( x )[ 6 :], '%Y%m %d ' ) for x in history_data [ 'Date' ]] # convert the format 1330 (int) to 13:30 (datetime.time) obejct intmin = history_data [ 'Time' ] bucket = util . convert_intmin_to_time ( intmin ) #, label='Time') history_data [ 'Time' ] = bucket # ============================================================================= # if time_to_datetime: # history_data['Time'] = [datetime.datetime.strptime(t, '%H%M') # for t in history_data['Time']] # # ============================================================================= #history_data_reindex = history_data.set_index('Date',drop=False) history_data_reindex = history_data match add_col_data : case {} | [] | None : pass case _ : for key in add_col_data : history_data_reindex [ key ] = add_col_data [ key ] return history_data #history_data_reindex","title":"read_reformat_Portara_minute_data"},{"location":"EC_tools/read/#EC_tools.read.read_reformat_dateNtime","text":"Utility function that read and reformat data with multiple columns of time elements, e.g. 'Date' and 'Time'. Parameters: filename ( str ) \u2013 CSV filename. time_proxies ( list [ str ] , default: ['Date', 'Time'] ) \u2013 A list. The default is ['Date', 'Time']. str_formats ( list [ str ] , default: ['%Y-%m-%d', '%H:%M:%S'] ) \u2013 A list of str arg passing to datetime.strptime function. The default is ['%Y-%m-%d', '%H:%M:%S']. Returns: data ( Data Frame ) \u2013 Source code in EC_tools/read.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 def read_reformat_dateNtime ( filename : str , time_proxies : list [ str ] = [ 'Date' , 'Time' ], str_formats : list [ str ] = [ '%Y-%m- %d ' , '%H:%M:%S' ]) \\ -> pd . DataFrame : \"\"\" Utility function that read and reformat data with multiple columns of time elements, e.g. 'Date' and 'Time'. Parameters ---------- filename : str CSV filename. time_proxies : list[str], optional A list. The default is ['Date', 'Time']. str_formats : list[str], optional A list of str arg passing to datetime.strptime function. The default is ['%Y-%m-%d', '%H:%M:%S']. Returns ------- data : Data Frame \"\"\" data = pd . read_csv ( filename ) bucket_1 = [ datetime . datetime . strptime ( x , str_formats [ 0 ]) for x in data [ time_proxies [ 0 ]]] bucket_2 = [ datetime . datetime . strptime ( x , str_formats [ 1 ]) . time () for x in data [ time_proxies [ 1 ]]] data [ time_proxies [ 0 ]] = bucket_1 data [ time_proxies [ 1 ]] = bucket_2 print ( data [ time_proxies [ 0 ]], data [ time_proxies [ 1 ]]) return data","title":"read_reformat_dateNtime"},{"location":"EC_tools/read/#EC_tools.read.read_reformat_openprice_data","text":"A function that read and reformat the openprice data. Parameters: filename ( str ) \u2013 CSV filename. Returns: DataFrame \u2013 Source code in EC_tools/read.py 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def read_reformat_openprice_data ( filename : str ) -> pd . DataFrame : \"\"\" A function that read and reformat the openprice data. Parameters ---------- filename : str CSV filename. Returns ------- DataFrame \"\"\" openprice_data = pd . read_csv ( filename ) openprice_data [ \"Date\" ] = [ datetime . datetime ( year = int ( str ( x )[ 0 : 4 ]), month = int ( str ( x )[ 5 : 7 ]), day = int ( str ( x )[ 8 :])) for x in openprice_data [ 'Date' ]] # convert the format 1330 (int) to 13:30 (datetime.time) obejct intmin = openprice_data [ 'Time' ] bucket = [ datetime . datetime . strptime ( intmin . iloc [ i ], \"%H:%M:%S\" ) . time () for i in range ( len ( intmin ))] openprice_data [ 'Time' ] = bucket #openprice_data_reindex = openprice_data.set_index('Date',drop=False) openprice_data_reindex = openprice_data #print(openprice_data_reindex) return openprice_data #openprice_data_reindex","title":"read_reformat_openprice_data"},{"location":"EC_tools/read/#EC_tools.read.render_PNL_xlsx","text":"A function that read in the back-test result to generate an xlsx PNL file Parameters: listfiles ( list ) \u2013 A list of filenames that to be included in the PNL report number_contracts_list ( list , default: [5, 10, 15, 20, 25, 50] ) \u2013 A list of numbers of contracts to be calculated in the return and cumulative return suffix ( str , default: '_.xlsx' ) \u2013 The suffix for the output filename. The Default is '_.xlsx'. symbol_proxy ( str , default: 'Price_Code' ) \u2013 The name for the symbol column. The Default is 'Price_Code'. entry_price_proxy ( str , default: 'Entry_Price' ) \u2013 The name of the entry price column. The Default is 'Entry_Price'. entry_date_proxy ( str , default: 'Entry_Date' ) \u2013 The name of the entry date column. The Default is 'Entry_Date'. exit_price_proxy ( str , default: 'Exit_Price' ) \u2013 The name of the exit price column. The Default is 'Exit_Price'. return_proxy ( str , default: 'Return_Trades' ) \u2013 The name of the return column. The Default is 'Return_Trades'. Returns: datpc ( DataFrame ) \u2013 The output PNL file. Source code in EC_tools/read.py 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 def render_PNL_xlsx ( listfiles : list [ str ], number_contracts_list : list [ int | float ] = [ 5 , 10 , 15 , 20 , 25 , 50 ], suffix : str = '_.xlsx' , symbol_proxy : str = 'Price_Code' , entry_price_proxy : str = 'Entry_Price' , entry_date_proxy : str = 'Entry_Date' , exit_price_proxy : str = 'Exit_Price' , return_proxy : str = 'Return_Trades' ) -> pd . DataFrame : \"\"\" A function that read in the back-test result to generate an xlsx PNL file Parameters ---------- listfiles : list A list of filenames that to be included in the PNL report number_contracts_list : list A list of numbers of contracts to be calculated in the return and cumulative return suffix : str The suffix for the output filename. The Default is '_.xlsx'. symbol_proxy: str The name for the symbol column. The Default is 'Price_Code'. entry_price_proxy: str The name of the entry price column. The Default is 'Entry_Price'. entry_date_proxy: str The name of the entry date column. The Default is 'Entry_Date'. exit_price_proxy: str The name of the exit price column. The Default is 'Exit_Price'. return_proxy: str The name of the return column. The Default is 'Return_Trades'. Returns ------- datpc : DataFrame The output PNL file. \"\"\" for fn in listfiles : # regular output price_codes = list ( SIZE_DICT . keys ()) dat = pd . read_csv ( fn ) print ( fn , dat ) with pd . ExcelWriter ( fn [: - 4 ] + suffix ) as excel_writer : dattotal = dat dattotal = dattotal . sort_values ( by = entry_date_proxy ) dattotal [ 'number barrels/gallons' ] = dattotal [ symbol_proxy ] . apply ( lambda x : SIZE_DICT [ x ]) dattotal [ 'fees' ] = dattotal [ symbol_proxy ] . apply ( lambda x : round_turn_fees [ x ]) dattotal [ 'fees' ] = np . where ( np . isnan ( dattotal [ 'Entry_Price' ]), 0.0 , dattotal [ 'fees' ]) # Make columns for scaled returns dattotal [ 'scaled returns from trades' ] = dattotal [ return_proxy ] * \\ dattotal [ 'number barrels/gallons' ] \\ - dattotal [ 'fees' ] for num_contracts in number_contracts_list : col_name = 'scaled returns from trades (x {} )' . format ( num_contracts ) dattotal [ col_name ] = dattotal [ 'scaled returns from trades' ] * num_contracts # Make columns for cumulative returns dattotal [ 'cumulative P&L from trades' ] = np . cumsum ( dattotal [ 'scaled returns from trades' ]) cum_col_name_list = [ 'cumulative P&L from trades' ] for num_contracts in number_contracts_list : cum_col_name = 'cumulative P&L from trades for contracts (x {} )' . format ( num_contracts ) PNL_col_name = 'scaled returns from trades (x {} )' . format ( num_contracts ) dattotal [ cum_col_name ] = np . cumsum ( dattotal [ PNL_col_name ]) cum_col_name_list . append ( cum_col_name ) dattotal . to_excel ( excel_writer = excel_writer , sheet_name = 'Total' ) # make sub-spread sheet for output sorted by individual asset for _ , pc in enumerate ( price_codes ): # recalculate the cumulative returns for each assets # First drop the columns previously calculated datpc = dattotal [ dattotal [ symbol_proxy ] == pc ] . drop ( columns = cum_col_name_list ) ################################## datpc [ 'cumulative P&L from trades' ] = np . cumsum ( datpc [ 'scaled returns from trades' ]) for num_contracts in number_contracts_list : cum_col_name = 'cumulative P&L from trades for contracts (x {} )' . format ( num_contracts ) PNL_col_name = 'scaled returns from trades (x {} )' . format ( num_contracts ) datpc [ cum_col_name ] = np . cumsum ( datpc [ PNL_col_name ]) if len ( datpc ) > 0 : datpc . to_excel ( excel_writer = excel_writer , sheet_name = pc ) return datpc","title":"render_PNL_xlsx"},{"location":"EC_tools/simple_trade/","text":"Simple_Trade Created on Wed Aug 7 16:48:40 2024 @author: dexter onetrade_simple ( EES_dict ) A simple trading method that returns a pair of trade open and close time as long as the price. Parameters: EES_dict ( dict ) \u2013 A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns: tuple \u2013 Two tuples containing rhe trade open and trade close in the format of (time. price). Source code in EC_tools/simple_trade.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def onetrade_simple ( EES_dict : dict ) -> tuple [ tuple , tuple ]: \"\"\" A simple trading method that returns a pair of trade open and close time as long as the price. Parameters ---------- EES_dict : dict A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns ------- tuple Two tuples containing rhe trade open and trade close in the format of (time. price). \"\"\" entry_pt , exit_pt , stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ), \\ ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] if close_pt == ( np . nan , np . nan ): print ( 'no close WTF' , EES_dict [ 'entry' ]) print ( type ( close_pt ), close_pt ) # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. #print('no entry', EES_dict['entry'], close_pt) trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] trade_open = entry_pt if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop #print('SSC_key', exit_pt, stop_pt, close_pt) #see which points comes the earliest if exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print('both null') trade_close = close_pt elif exit_pt != ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): trade_close = exit_pt #print('stop null') elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): trade_close = stop_pt #print('exit null') elif exit_pt != ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): if exit_pt [ 0 ] >= stop_pt [ 0 ]: #print('stop loss') trade_close = stop_pt elif exit_pt [ 0 ] < stop_pt [ 0 ]: #print('exit') trade_close = exit_pt else : raise Exception ( \"WTF\" ) if trade_open != ( np . nan , np . nan ) and trade_close == ( np . nan , np . nan ): raise Exception ( 'trade WTF {} , {} ' . format ( trade_open , trade_close )) #print('trade', trade_open, trade_close, type(trade_open), type(trade_close)) return trade_open , trade_close onetrade_simple_LEGACY ( EES_dict ) LEGACY code before the development of trade and portfolio modules a function that control which price to buy and sell. The trade logic is incorrect in this one (It hit the stop-loss automatically) Parameters: EES_dict ( dict ) \u2013 A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns: tuple \u2013 Two tuples containing rhe trade open and trade close in the format of (time. price). Source code in EC_tools/simple_trade.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def onetrade_simple_LEGACY ( EES_dict : dict ) -> tuple [ tuple , tuple ]: \"\"\" LEGACY code before the development of trade and portfolio modules a function that control which price to buy and sell. The trade logic is incorrect in this one (It hit the stop-loss automatically) Parameters ---------- EES_dict : dict A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns ------- tuple Two tuples containing rhe trade open and trade close in the format of (time. price). \"\"\" # add the amount of exchange trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) # Trade logic if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point trade_open = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'stop' ]) == 0 : # if the stop loss wasn't hit pass else : trade_close = EES_dict [ 'stop' ][ 0 ] #set the trade close at stop loss if len ( EES_dict [ 'exit' ]) == 0 : trade_close = EES_dict [ 'close' ] else : # make sure the exit comes after the entry point for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > trade_open [ 0 ]: trade_close = exit_cand break else : pass return trade_open , trade_close","title":"simple_trade"},{"location":"EC_tools/simple_trade/#simple_trade","text":"Created on Wed Aug 7 16:48:40 2024 @author: dexter","title":"Simple_Trade"},{"location":"EC_tools/simple_trade/#EC_tools.simple_trade.onetrade_simple","text":"A simple trading method that returns a pair of trade open and close time as long as the price. Parameters: EES_dict ( dict ) \u2013 A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns: tuple \u2013 Two tuples containing rhe trade open and trade close in the format of (time. price). Source code in EC_tools/simple_trade.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def onetrade_simple ( EES_dict : dict ) -> tuple [ tuple , tuple ]: \"\"\" A simple trading method that returns a pair of trade open and close time as long as the price. Parameters ---------- EES_dict : dict A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns ------- tuple Two tuples containing rhe trade open and trade close in the format of (time. price). \"\"\" entry_pt , exit_pt , stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ), \\ ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] if close_pt == ( np . nan , np . nan ): print ( 'no close WTF' , EES_dict [ 'entry' ]) print ( type ( close_pt ), close_pt ) # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. #print('no entry', EES_dict['entry'], close_pt) trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] trade_open = entry_pt if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop #print('SSC_key', exit_pt, stop_pt, close_pt) #see which points comes the earliest if exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print('both null') trade_close = close_pt elif exit_pt != ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): trade_close = exit_pt #print('stop null') elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): trade_close = stop_pt #print('exit null') elif exit_pt != ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): if exit_pt [ 0 ] >= stop_pt [ 0 ]: #print('stop loss') trade_close = stop_pt elif exit_pt [ 0 ] < stop_pt [ 0 ]: #print('exit') trade_close = exit_pt else : raise Exception ( \"WTF\" ) if trade_open != ( np . nan , np . nan ) and trade_close == ( np . nan , np . nan ): raise Exception ( 'trade WTF {} , {} ' . format ( trade_open , trade_close )) #print('trade', trade_open, trade_close, type(trade_open), type(trade_close)) return trade_open , trade_close","title":"onetrade_simple"},{"location":"EC_tools/simple_trade/#EC_tools.simple_trade.onetrade_simple_LEGACY","text":"LEGACY code before the development of trade and portfolio modules a function that control which price to buy and sell. The trade logic is incorrect in this one (It hit the stop-loss automatically) Parameters: EES_dict ( dict ) \u2013 A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns: tuple \u2013 Two tuples containing rhe trade open and trade close in the format of (time. price). Source code in EC_tools/simple_trade.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def onetrade_simple_LEGACY ( EES_dict : dict ) -> tuple [ tuple , tuple ]: \"\"\" LEGACY code before the development of trade and portfolio modules a function that control which price to buy and sell. The trade logic is incorrect in this one (It hit the stop-loss automatically) Parameters ---------- EES_dict : dict A dictionary containing the points that crosses over the Entry, Exit, and Stop Loss points (EES), as well as the closing time and price of the trading day. This should be the output of find_minute_EES from EC_tools.read module. Returns ------- tuple Two tuples containing rhe trade open and trade close in the format of (time. price). \"\"\" # add the amount of exchange trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) # Trade logic if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point trade_open = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'stop' ]) == 0 : # if the stop loss wasn't hit pass else : trade_close = EES_dict [ 'stop' ][ 0 ] #set the trade close at stop loss if len ( EES_dict [ 'exit' ]) == 0 : trade_close = EES_dict [ 'close' ] else : # make sure the exit comes after the entry point for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > trade_open [ 0 ]: trade_close = exit_cand break else : pass return trade_open , trade_close","title":"onetrade_simple_LEGACY"},{"location":"EC_tools/strategy/","text":"Strategy Created on Thu Jul 4 04:59:37 2024 @author: Dexter S.-H. Hon The Strategy module contains the parent class for all strategy to be applied in signal generation. ArgusMRStrategy Bases: Strategy Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. Source code in EC_tools/strategy.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 class ArgusMRStrategy ( Strategy ): \"\"\" Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. \"\"\" def __init__ ( self , curve_today = np . arange ( 0.0025 , 0.9975 , 0.0025 ), quant_list = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_exact' def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , quantile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc #cond_buy_list_3 = [(open_price >= self._curve_today_spline([ # apc_trade_Qlimit[0]])[0])] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc #cond_sell_list_3 = [(open_price <= self._curve_today_spline([ # apc_trade_Qlimit[1]])[0])] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , open_price : float , quantile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple [ list | tuple , float ] = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple [ list | tuple , float ] = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , quantile = quantile ) direction , cond_info = self . run_cond ( strategy_info , open_price , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value } apply_strategy ( history_data_lag , apc_curve_lag , open_price , quantile = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days = 2 , apc_mid_Q = 0.5 , buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 )) A method to apply the strategy. Parameters: history_data_lag ( DataFrame ) \u2013 The history data of the lag days. apc_curve_lag ( DataFrame ) \u2013 The APC curve of the lag days. open_price ( float ) \u2013 The opening price of the day. qunatile ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile value. The default is 0.5. buy_range ( tuple [ list | tuple , float ] , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns: dict \u2013 A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). Source code in EC_tools/strategy.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def apply_strategy ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , open_price : float , quantile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple [ list | tuple , float ] = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple [ list | tuple , float ] = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , quantile = quantile ) direction , cond_info = self . run_cond ( strategy_info , open_price , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value } flatten_sub_cond_dict () A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList gen_data ( history_data_lag , apc_curve_lag , price_proxy = 'Settle' , quantile = [ 0.25 , 0.4 , 0.6 , 0.75 ]) A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters: history_data_lag ( list ) \u2013 The history data of the lag days. apc_curve_lag ( list ) \u2013 The APC curve of the lag days. price_proxy ( str , default: 'Settle' ) \u2013 The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile ( list ) \u2013 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns: strategy_info ( dict ) \u2013 A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. Source code in EC_tools/strategy.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , quantile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info run_cond ( data , open_price , total_lag_days = 2 , apc_mid_Q = 0.5 ) A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters: data ( dict ) \u2013 strategy_info from gen_data. open_price ( float ) \u2013 The value of the open price. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile of an APC. The default is 0.5. apc_trade_Qrange ( tuple ) \u2013 The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin ( TYPE ) \u2013 The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit ( TYPE ) \u2013 The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns: direction \u2013 The trading direction of the day. cond_info ( list ) \u2013 A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. Source code in EC_tools/strategy.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc #cond_buy_list_3 = [(open_price >= self._curve_today_spline([ # apc_trade_Qlimit[0]])[0])] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc #cond_sell_list_3 = [(open_price <= self._curve_today_spline([ # apc_trade_Qlimit[1]])[0])] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info set_EES ( buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 )) A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters: buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises: Exception \u2013 For invalid direction. It has to conform to the StrategyStatus Attributes. Returns: entry_price ( list ) \u2013 A list contain the price caculated by the APC given the buy_range input. exit_price ( list ) \u2013 A list contain the price caculated by the APC given the sell_range input. stop_loss ( float ) \u2013 A price caculated by the APC given the stop_loss input. Source code in EC_tools/strategy.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss ArgusMRStrategyMode Bases: Strategy Source code in EC_tools/strategy.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 class ArgusMRStrategyMode ( Strategy ): def __init__ ( self , curve_today : NDArray , quant_list : NDArray = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today , method = 'cubic' ) self . _curve_today_reverse_spline = mfunc . generic_spline ( self . _curve_today , self . _quant_list , method = 'cubic' ) self . _pdf_price , self . _pdf = mfunc . cal_pdf ( self . _quant_list , self . _curve_today ) self . _pdf_spline = mfunc . generic_spline ( self . _pdf_price , self . _pdf ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_exact_mode' @property def mode_price ( self ): return float ( mfunc . find_pdf_val ( self . _pdf_price , self . _pdf , func = max )) def flatten_sub_cond_dict ( self ): \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , history_data_lag , apc_curve_lag , price_proxy = 'Settle' , quantile_delta = [ - 0.1 , 0.0 , + 0.1 ]): lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # turn the APC (cdf) to pdf in a list lag_pdf_list = [ mfunc . cal_pdf ( self . _quant_list , apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ]) for i in range ( len ( apc_curve_lag ))] # Calculate the price of the mode in these apc mode_Q_list = [ mfunc . find_pdf_quant ( lag_pdf_list [ i ][ 0 ], lag_pdf_list [ i ][ 1 ]) for i in range ( len ( apc_curve_lag ))] mode_Q_list . reverse () # calculate the rolling average for the mode rollingaverage_mode_q = np . average ( mode_Q_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q , 'mode_Q_list' : mode_Q_list , 'rollingaverage_mode' : rollingaverage_mode_q } # Find the quantile in the CDF (NOT THE PDF! important) from the mode_price quantile = [ quant + self . _curve_today_reverse_spline ( self . mode_price ) for quant in quantile_delta ] qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info def run_cond ( self , data , open_price_quant , total_lag_days = 2 ): rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mode_Q_list = data [ 'mode_Q_list' ] average_mode_Q = data [ 'rollingaverage_mode' ] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mode_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < average_mode_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc cond_buy_list_3 = [( open_price_quant >= 0.1 )] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mode_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > average_mode_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc cond_sell_list_3 = [( open_price_quant <= 0.9 )] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ], 'OP_WITHIN' : [ cond_buy_list_3 ]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ], 'OP_WITHIN' : [ cond_sell_list_3 ]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info def set_EES ( self , buy_range = ( - 0.1 , 0.1 , - 0.45 ), sell_range = ( 0.1 , - 0.1 , + 0.45 )): mode_quant = self . _curve_today_reverse_spline ( self . mode_price ) if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = float ( self . _curve_today_spline ( mode_quant + buy_range [ 0 ])) # (B) Exit price exit_price = float ( self . _curve_today_spline ( mode_quant + buy_range [ 1 ])) # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( mode_quant + buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = float ( self . _curve_today_spline ( mode_quant + sell_range [ 0 ])) # (B) Exit price exit_price = float ( self . _curve_today_spline ( mode_quant + sell_range [ 1 ])) # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( mode_quant + sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = \"NA\" exit_price = \"NA\" stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag , apc_curve_lag , open_price , quantile : list = [ - 0.1 , 0.0 , + 0.1 ], total_lag_days : int = 2 , buy_range : tuple = ( - 0.1 , 0.1 , - 0.45 ), sell_range : tuple = ( 0.1 , - 0.1 , + 0.45 )): strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , quantile_delta = quantile ) open_price_quant = mfunc . find_quant ( self . _curve_today , self . _quant_list , open_price ) direction , cond_info = self . run_cond ( strategy_info , open_price_quant , total_lag_days = total_lag_days ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price , exit_price elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price , exit_price elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price , exit_price # Bookkeeping area EES = [ entry_price , entry_price , exit_price , exit_price , stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value } flatten_sub_cond_dict () A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 def flatten_sub_cond_dict ( self ): \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList ArgusMRStrategy_22 Bases: Strategy Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. Source code in EC_tools/strategy.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 class ArgusMRStrategy_22 ( Strategy ): \"\"\" Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. \"\"\" def __init__ ( self , curve_today = np . arange ( 0.0025 , 0.9975 , 0.0025 ), quant_list = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_exact' def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The APC quantile value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc cond_buy_list_3 = [( open_price >= apc_mid_Q )] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc cond_sell_list_3 = [( open_price <= apc_mid_Q )] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag : list , apc_curve_lag : list , open_price : float , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , qunatile = qunatile ) open_price_quant = mfunc . find_quant ( self . _curve_today , self . _quant_list , open_price ) direction , cond_info = self . run_cond ( strategy_info , open_price_quant , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value } apply_strategy ( history_data_lag , apc_curve_lag , open_price , qunatile = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days = 2 , apc_mid_Q = 0.5 , buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 )) A method to apply the strategy. Parameters: history_data_lag ( list ) \u2013 The history data of the lag days. apc_curve_lag ( list ) \u2013 The APC curve of the lag days. open_price ( float ) \u2013 The opening price of the day. qunatile ( list , default: [0.25, 0.4, 0.6, 0.75] ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile value. The default is 0.5. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns: dict \u2013 A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). Source code in EC_tools/strategy.py 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 def apply_strategy ( self , history_data_lag : list , apc_curve_lag : list , open_price : float , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , qunatile = qunatile ) open_price_quant = mfunc . find_quant ( self . _curve_today , self . _quant_list , open_price ) direction , cond_info = self . run_cond ( strategy_info , open_price_quant , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value } flatten_sub_cond_dict () A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList gen_data ( history_data_lag , apc_curve_lag , price_proxy = 'Settle' , qunatile = [ 0.25 , 0.4 , 0.6 , 0.75 ]) A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters: history_data_lag ( list ) \u2013 The history data of the lag days. apc_curve_lag ( list ) \u2013 The APC curve of the lag days. price_proxy ( str , default: 'Settle' ) \u2013 The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile ( list , default: [0.25, 0.4, 0.6, 0.75] ) \u2013 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns: strategy_info ( dict ) \u2013 A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. Source code in EC_tools/strategy.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info run_cond ( data , open_price , total_lag_days = 2 , apc_mid_Q = 0.5 ) A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters: data ( dict ) \u2013 strategy_info from gen_data. open_price ( float ) \u2013 The APC quantile value of the open price. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile of an APC. The default is 0.5. apc_trade_Qrange ( tuple ) \u2013 The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin ( TYPE ) \u2013 The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit ( TYPE ) \u2013 The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns: direction \u2013 The trading direction of the day. cond_info ( list ) \u2013 A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. Source code in EC_tools/strategy.py 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The APC quantile value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc cond_buy_list_3 = [( open_price >= apc_mid_Q )] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc cond_sell_list_3 = [( open_price <= apc_mid_Q )] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info set_EES ( buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 )) A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters: buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises: Exception \u2013 For invalid direction. It has to conform to the StrategyStatus Attributes. Returns: entry_price ( list ) \u2013 A list contain the price caculated by the APC given the buy_range input. exit_price ( list ) \u2013 A list contain the price caculated by the APC given the sell_range input. stop_loss ( float ) \u2013 A price caculated by the APC given the stop_loss input. Source code in EC_tools/strategy.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss ArgusMonthlyStrategy Bases: Strategy Source code in EC_tools/strategy.py 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 class ArgusMonthlyStrategy ( Strategy ): def __init__ ( self , curve_monthly = np . arange ( 0.0025 , 0.9975 , 0.0025 ), curve_today = np . arange ( 0.0025 , 0.9975 , 0.0025 ), quant_list = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_monthly = curve_monthly self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_monthly_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_monthly ) self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_monthly' def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , daily_cumavg : float , prev_cum_n : float , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , quantile : list = [ 0.05 , 0.10 , 0.35 , 0.50 , 0.65 , 0.90 , 0.95 ]): lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { \"daily_cumavg\" : daily_cumavg , \"prev_cum_n\" : prev_cum_n , 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } quantile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , quantile_info def run_cond ( self , data : dict , total_lag_days : int = 2 , apc_range_trigger_buy : list = [ 0.10 , 0.35 ], apc_range_trigger_sell : list = [ 0.65 , 0.90 ]): lag1q = data [ 'lag_list' ][ 0 ] rollingaverage_q = data [ 'rollingaverage' ] daily_cumavg = data [ \"daily_cumavg\" ] prev_cum_n = data [ \"prev_cum_n\" ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] #mid_Q_list = [apc_mid_Q for i in range(total_lag_days)] quant_price_entry_lower_buy = self . _curve_monthly_spline ( apc_range_trigger_buy [ 0 ]) quant_price_entry_upper_buy = self . _curve_monthly_spline ( apc_range_trigger_buy [ 1 ]) quant_price_entry_lower_sell = self . _curve_monthly_spline ( apc_range_trigger_sell [ 0 ]) quant_price_entry_upper_sell = self . _curve_monthly_spline ( apc_range_trigger_sell [ 1 ]) # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the # total_cum_avg is within the monthly APC: Q0.1 < total_cum_avg < Q0.35 cond_buy_list_1 = list ( map ( lambda x , low , up : low < x < up , [ daily_cumavg ], [ quant_price_entry_lower_buy ], [ quant_price_entry_upper_buy ])) print ( \"condition 1 Buy\" ) print ( quant_price_entry_lower_buy , '<' , daily_cumavg , '<' , quant_price_entry_upper_buy , cond_buy_list_1 ) # (2) The lag1q for the day before has to be lower than the entry lower bound # (2) rolling 5 days average lower than the daily apc entry upper bound cond_buy_list_2 = [( lag1q < 0.25 )] print ( \"condition 2 Buy\" ) print ( lag1q , '<' , 0.25 , lag1q < 0.25 ) cond_buy_list_3 = [( rollingaverage_q < 0.4 )] print ( \"condition 3 Buy\" ) print ( rollingaverage_q , '<' , 0.4 , rollingaverage_q < 0.4 ) # \"SELL\" condition # (1) create a list of Boolean value for evaluating if the # total_cum_avg is within the monthly APC: Q0.65 < total_cum_avg < Q0.9 cond_sell_list_1 = list ( map ( lambda x , low , up : low < x < up , [ daily_cumavg ], [ quant_price_entry_lower_sell ], [ quant_price_entry_upper_sell ])) print ( \"condition 1 Sell\" ) print ( quant_price_entry_lower_sell , '<' , daily_cumavg , '<' , quant_price_entry_upper_sell , cond_sell_list_1 ) # (2) price at today's opening hour below the 0.9 quantile of today's apc # (2) rolling 5 days average higher than the daily apc entry upper bound cond_sell_list_2 = [( lag1q > 0.75 )] print ( \"condition 2 Sell\" ) print ( lag1q , '>' , 0.75 , lag1q > 0.75 ) cond_sell_list_3 = [( rollingaverage_q > 0.6 )] print ( \"condition 3 Sell\" ) print ( rollingaverage_q , '>' , 0.6 , rollingaverage_q > 0.6 ) # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCUM_CONS' : [ cond_buy_list_1 ], 'NCONS' : [ cond_buy_list_2 ], 'NROLL' : [ cond_buy_list_3 ]} self . _sub_sell_cond_dict = { 'NCUM_CONS' : [ cond_sell_list_1 ], 'NCONS' : [ cond_sell_list_2 ], 'NROLL' : [ cond_sell_list_3 ]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCUM_CONS , NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCUM_CONS' ]), \\ len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCUM_CONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_3 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCUM_CONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_3 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_2 ^ sub_sell_2 )} cond_dict_3 = { 'Buy' : sub_buy_3 , 'Sell' : sub_sell_3 , 'Neutral' : not ( sub_buy_3 ^ sub_sell_3 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCUM_CONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NCONS = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_3 if cond_dict_3 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCUM_CONS , NCONS , NROLL , Signal_NCUM_CONS , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info # ============================================================================= # # \"Entry condition\" These information are for the backtests # check_entry_buy = (q0_10 < today_cum_avg < q0_35) # Buy # check_entry_sell = (q0_65 < today_cum_avg < q0_90) # Sell # # Exit condition # check_exit_buy = (q0_50 < today_cum_avg < q0_90) # Buy # check_exit_sell = (q0_10 < today_cum_avg < q0_50) # Sell # # # Stoploss # check_stoploss_buy = (today_cum_avg < q0_05) # check_stoploss_sell = (today_cum_avg > q0_95) # ============================================================================= def set_EES ( self , data : dict , buy_range : tuple = ([ 0.10 , 0.35 ],[ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ],[ 0.10 , 0.50 ], 0.95 )): # buy_range = ([lower_bound_entry, upper_bound_entry], # [lower_bound_exit, upper_bound_exit], stoploss) prev_cum_avg = data [ \"daily_cumavg\" ] prev_cum_n = data [ \"prev_cum_n\" ] # A list of quantile price for buy and sell range quant_price_entry_lower_buy = self . _curve_monthly_spline ( buy_range [ 0 ][ 0 ]) quant_price_entry_upper_buy = self . _curve_monthly_spline ( buy_range [ 0 ][ 1 ]) quant_price_exit_lower_buy = self . _curve_monthly_spline ( buy_range [ 1 ][ 0 ]) quant_price_exit_upper_buy = self . _curve_monthly_spline ( buy_range [ 1 ][ 1 ]) quant_price_entry_lower_sell = self . _curve_monthly_spline ( sell_range [ 0 ][ 0 ]) quant_price_entry_upper_sell = self . _curve_monthly_spline ( sell_range [ 0 ][ 1 ]) quant_price_exit_lower_sell = self . _curve_monthly_spline ( sell_range [ 1 ][ 0 ]) quant_price_exit_upper_sell = self . _curve_monthly_spline ( sell_range [ 1 ][ 1 ]) quant_price_stoploss_buy = self . _curve_monthly_spline ( buy_range [ 2 ]) quant_price_stoploss_sell = self . _curve_monthly_spline ( sell_range [ 2 ]) # The actual price target # \"Buy\" target entry range buy_target_lower_entry = quant_price_entry_lower_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n buy_target_upper_entry = quant_price_entry_upper_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Buy\" target exit range buy_target_lower_exit = quant_price_exit_lower_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n buy_target_upper_exit = quant_price_exit_upper_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Buy\" target stoploss buy_stoploss_exit = quant_price_stoploss_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Sell\" target entry range sell_target_lower_entry = quant_price_entry_lower_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n sell_target_upper_entry = quant_price_entry_upper_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Sell\" target exit range sell_target_lower_exit = quant_price_exit_lower_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n sell_target_upper_exit = quant_price_exit_upper_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Sell\" target Stoploss sell_stoploss_exit = quant_price_stoploss_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ buy_target_lower_entry , buy_target_upper_entry ] # (B) Exit price exit_price = [ buy_target_lower_exit , buy_target_upper_exit ] # (C) Stop loss at APC p=0.1 stop_loss = buy_stoploss_exit elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ sell_target_lower_entry , sell_target_upper_entry ] # (B) Exit price exit_price = [ sell_target_lower_exit , sell_target_upper_exit ] # (C) Stop loss at APC p=0.9 stop_loss = sell_stoploss_exit elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag : list , apc_curve_lag : list , daily_cumavg : float , prev_cum_n : float , quantile : list = [ 0.05 , 0.10 , 0.35 , 0.50 , 0.65 , 0.90 , 0.95 ], total_lag_days : int = 1 , buy_range : tuple = ([ 0.10 , 0.35 ],[ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ],[ 0.10 , 0.50 ], 0.95 )): strategy_info , quantile_info = self . gen_data ( daily_cumavg , prev_cum_n , history_data_lag , apc_curve_lag , quantile = quantile ) #open_price_quant = mfunc.find_quant(self._curve_today, # self._quant_list, open_price) direction , cond_info = self . run_cond ( strategy_info , total_lag_days = total_lag_days ) entry_price , exit_price , stop_loss = self . set_EES ( strategy_info , buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value } flatten_sub_cond_dict () A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList SignalStatus Bases: Enum A simple class that contains the avaliable status for signals. Source code in EC_tools/strategy.py 29 30 31 32 33 34 35 36 class SignalStatus ( Enum ): \"\"\" A simple class that contains the avaliable status for signals. \"\"\" BUY = \"Buy\" # When the position is added but not filled SELL = \"Sell\" # When the position is executed NEUTRAL = \"Neutral\" # When the position is cancelled Strategy Bases: Protocol A Strategy is defined by given specific inputs related to forecasting or past price data or other indicators that out put a specific instructions (e.g., Buy/Sell/Neutral or something more complex) for a back-testing system or a live trading alogirthm to execute. The trading instructions in question does not contain information about the style of trading (e.g., one entry per day, or more), It is solely informational on where you should buy/sell. Source code in EC_tools/strategy.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class Strategy ( Protocol ): \"\"\" A Strategy is defined by given specific inputs related to forecasting or past price data or other indicators that out put a specific instructions (e.g., Buy/Sell/Neutral or something more complex) for a back-testing system or a live trading alogirthm to execute. The trading instructions in question does not contain information about the style of trading (e.g., one entry per day, or more), It is solely informational on where you should buy/sell. \"\"\" def __init__ ( self ): self . _buy_cond = False self . _sell_cond = False self . _neutral_cond = True self . cond_dict = { \"Buy\" : [ False ], \"Sell\" : [ False ]} # make the default value of a strategy 'Neutral' self . _direction = SignalStatus . NEUTRAL @property def buy_cond ( self ): \"\"\" The overall boolean value of the Buy condition \"\"\" self . _buy_cond = all ( self . cond_dict [ 'Buy' ]) return self . _buy_cond @property def sell_cond ( self ): \"\"\" The overall boolean value of the Sell condition \"\"\" self . _sell_cond = all ( self . cond_dict [ 'Sell' ]) return self . _sell_cond @property def neutral_cond ( self ): \"\"\" The overall boolean value of the Neutral condition \"\"\" self . _neutral_cond = not ( self . buy_cond ^ self . sell_cond ) return self . _neutral_cond @property def direction ( self ): if self . buy_cond == True : self . _direction = SignalStatus . BUY if self . sell_cond == True : self . _direction = SignalStatus . SELL if self . neutral_cond == True : self . _direction = SignalStatus . NEUTRAL return self . _direction buy_cond property The overall boolean value of the Buy condition neutral_cond property The overall boolean value of the Neutral condition sell_cond property The overall boolean value of the Sell condition","title":"strategy"},{"location":"EC_tools/strategy/#strategy","text":"Created on Thu Jul 4 04:59:37 2024 @author: Dexter S.-H. Hon The Strategy module contains the parent class for all strategy to be applied in signal generation.","title":"Strategy"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy","text":"Bases: Strategy Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. Source code in EC_tools/strategy.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 class ArgusMRStrategy ( Strategy ): \"\"\" Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. \"\"\" def __init__ ( self , curve_today = np . arange ( 0.0025 , 0.9975 , 0.0025 ), quant_list = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_exact' def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , quantile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc #cond_buy_list_3 = [(open_price >= self._curve_today_spline([ # apc_trade_Qlimit[0]])[0])] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc #cond_sell_list_3 = [(open_price <= self._curve_today_spline([ # apc_trade_Qlimit[1]])[0])] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , open_price : float , quantile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple [ list | tuple , float ] = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple [ list | tuple , float ] = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , quantile = quantile ) direction , cond_info = self . run_cond ( strategy_info , open_price , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value }","title":"ArgusMRStrategy"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy.apply_strategy","text":"A method to apply the strategy. Parameters: history_data_lag ( DataFrame ) \u2013 The history data of the lag days. apc_curve_lag ( DataFrame ) \u2013 The APC curve of the lag days. open_price ( float ) \u2013 The opening price of the day. qunatile ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile value. The default is 0.5. buy_range ( tuple [ list | tuple , float ] , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns: dict \u2013 A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). Source code in EC_tools/strategy.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def apply_strategy ( self , history_data_lag : pd . DataFrame , apc_curve_lag : pd . DataFrame , open_price : float , quantile : list [ float ] = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple [ list | tuple , float ] = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple [ list | tuple , float ] = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : DataFrame The history data of the lag days. apc_curve_lag : DataFrame The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , quantile = quantile ) direction , cond_info = self . run_cond ( strategy_info , open_price , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value }","title":"apply_strategy"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy.flatten_sub_cond_dict","text":"A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList","title":"flatten_sub_cond_dict"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy.gen_data","text":"A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters: history_data_lag ( list ) \u2013 The history data of the lag days. apc_curve_lag ( list ) \u2013 The APC curve of the lag days. price_proxy ( str , default: 'Settle' ) \u2013 The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile ( list ) \u2013 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns: strategy_info ( dict ) \u2013 A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. Source code in EC_tools/strategy.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , quantile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info","title":"gen_data"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy.run_cond","text":"A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters: data ( dict ) \u2013 strategy_info from gen_data. open_price ( float ) \u2013 The value of the open price. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile of an APC. The default is 0.5. apc_trade_Qrange ( tuple ) \u2013 The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin ( TYPE ) \u2013 The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit ( TYPE ) \u2013 The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns: direction \u2013 The trading direction of the day. cond_info ( list ) \u2013 A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. Source code in EC_tools/strategy.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc #cond_buy_list_3 = [(open_price >= self._curve_today_spline([ # apc_trade_Qlimit[0]])[0])] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc #cond_sell_list_3 = [(open_price <= self._curve_today_spline([ # apc_trade_Qlimit[1]])[0])] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info","title":"run_cond"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy.set_EES","text":"A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters: buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises: Exception \u2013 For invalid direction. It has to conform to the StrategyStatus Attributes. Returns: entry_price ( list ) \u2013 A list contain the price caculated by the APC given the buy_range input. exit_price ( list ) \u2013 A list contain the price caculated by the APC given the sell_range input. stop_loss ( float ) \u2013 A price caculated by the APC given the stop_loss input. Source code in EC_tools/strategy.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss","title":"set_EES"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategyMode","text":"Bases: Strategy Source code in EC_tools/strategy.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 class ArgusMRStrategyMode ( Strategy ): def __init__ ( self , curve_today : NDArray , quant_list : NDArray = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today , method = 'cubic' ) self . _curve_today_reverse_spline = mfunc . generic_spline ( self . _curve_today , self . _quant_list , method = 'cubic' ) self . _pdf_price , self . _pdf = mfunc . cal_pdf ( self . _quant_list , self . _curve_today ) self . _pdf_spline = mfunc . generic_spline ( self . _pdf_price , self . _pdf ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_exact_mode' @property def mode_price ( self ): return float ( mfunc . find_pdf_val ( self . _pdf_price , self . _pdf , func = max )) def flatten_sub_cond_dict ( self ): \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , history_data_lag , apc_curve_lag , price_proxy = 'Settle' , quantile_delta = [ - 0.1 , 0.0 , + 0.1 ]): lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) # turn the APC (cdf) to pdf in a list lag_pdf_list = [ mfunc . cal_pdf ( self . _quant_list , apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ]) for i in range ( len ( apc_curve_lag ))] # Calculate the price of the mode in these apc mode_Q_list = [ mfunc . find_pdf_quant ( lag_pdf_list [ i ][ 0 ], lag_pdf_list [ i ][ 1 ]) for i in range ( len ( apc_curve_lag ))] mode_Q_list . reverse () # calculate the rolling average for the mode rollingaverage_mode_q = np . average ( mode_Q_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q , 'mode_Q_list' : mode_Q_list , 'rollingaverage_mode' : rollingaverage_mode_q } # Find the quantile in the CDF (NOT THE PDF! important) from the mode_price quantile = [ quant + self . _curve_today_reverse_spline ( self . mode_price ) for quant in quantile_delta ] qunatile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , qunatile_info def run_cond ( self , data , open_price_quant , total_lag_days = 2 ): rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mode_Q_list = data [ 'mode_Q_list' ] average_mode_Q = data [ 'rollingaverage_mode' ] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mode_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < average_mode_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc cond_buy_list_3 = [( open_price_quant >= 0.1 )] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mode_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > average_mode_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc cond_sell_list_3 = [( open_price_quant <= 0.9 )] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ], 'OP_WITHIN' : [ cond_buy_list_3 ]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ], 'OP_WITHIN' : [ cond_sell_list_3 ]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info def set_EES ( self , buy_range = ( - 0.1 , 0.1 , - 0.45 ), sell_range = ( 0.1 , - 0.1 , + 0.45 )): mode_quant = self . _curve_today_reverse_spline ( self . mode_price ) if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = float ( self . _curve_today_spline ( mode_quant + buy_range [ 0 ])) # (B) Exit price exit_price = float ( self . _curve_today_spline ( mode_quant + buy_range [ 1 ])) # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( mode_quant + buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = float ( self . _curve_today_spline ( mode_quant + sell_range [ 0 ])) # (B) Exit price exit_price = float ( self . _curve_today_spline ( mode_quant + sell_range [ 1 ])) # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( mode_quant + sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = \"NA\" exit_price = \"NA\" stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag , apc_curve_lag , open_price , quantile : list = [ - 0.1 , 0.0 , + 0.1 ], total_lag_days : int = 2 , buy_range : tuple = ( - 0.1 , 0.1 , - 0.45 ), sell_range : tuple = ( 0.1 , - 0.1 , + 0.45 )): strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , quantile_delta = quantile ) open_price_quant = mfunc . find_quant ( self . _curve_today , self . _quant_list , open_price ) direction , cond_info = self . run_cond ( strategy_info , open_price_quant , total_lag_days = total_lag_days ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price , exit_price elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price , exit_price elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price , exit_price # Bookkeeping area EES = [ entry_price , entry_price , exit_price , exit_price , stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value }","title":"ArgusMRStrategyMode"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategyMode.flatten_sub_cond_dict","text":"A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 def flatten_sub_cond_dict ( self ): \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList","title":"flatten_sub_cond_dict"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy_22","text":"Bases: Strategy Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. Source code in EC_tools/strategy.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 class ArgusMRStrategy_22 ( Strategy ): \"\"\" Mean-Reversion Strategy based on Argus Possibility Curves. This class allows us to ... The Strategy condition is described in the run_cond method. \"\"\" def __init__ ( self , curve_today = np . arange ( 0.0025 , 0.9975 , 0.0025 ), quant_list = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_exact' def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The APC quantile value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc cond_buy_list_3 = [( open_price >= apc_mid_Q )] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc cond_sell_list_3 = [( open_price <= apc_mid_Q )] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag : list , apc_curve_lag : list , open_price : float , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , qunatile = qunatile ) open_price_quant = mfunc . find_quant ( self . _curve_today , self . _quant_list , open_price ) direction , cond_info = self . run_cond ( strategy_info , open_price_quant , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value }","title":"ArgusMRStrategy_22"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy_22.apply_strategy","text":"A method to apply the strategy. Parameters: history_data_lag ( list ) \u2013 The history data of the lag days. apc_curve_lag ( list ) \u2013 The APC curve of the lag days. open_price ( float ) \u2013 The opening price of the day. qunatile ( list , default: [0.25, 0.4, 0.6, 0.75] ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile value. The default is 0.5. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns: dict \u2013 A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). Source code in EC_tools/strategy.py 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 def apply_strategy ( self , history_data_lag : list , apc_curve_lag : list , open_price : float , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ], total_lag_days : int = 2 , apc_mid_Q : float = 0.5 , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method to apply the strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. open_price : float The opening price of the day. qunatile : list, optional A list of prices calculating using qunatile input into the APC of the date of interest. The default is [0.25,0.4,0.6,0.75]. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile value. The default is 0.5. buy_range: tuple, optional A tuple that contain the desired quantile value range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). Returns ------- dict A dictionary that contains the strategy data from the process. 'data' contains EES value, cond_info, lag_list, rollingaverage, quantile_info, EES value (not range), and the strategy name 'direction' contains the string of the trading direction (strategy status). \"\"\" strategy_info , quantile_info = self . gen_data ( history_data_lag , apc_curve_lag , qunatile = qunatile ) open_price_quant = mfunc . find_quant ( self . _curve_today , self . _quant_list , open_price ) direction , cond_info = self . run_cond ( strategy_info , open_price_quant , total_lag_days = total_lag_days , apc_mid_Q = apc_mid_Q ) entry_price , exit_price , stop_loss = self . set_EES ( buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value }","title":"apply_strategy"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy_22.flatten_sub_cond_dict","text":"A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList","title":"flatten_sub_cond_dict"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy_22.gen_data","text":"A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters: history_data_lag ( list ) \u2013 The history data of the lag days. apc_curve_lag ( list ) \u2013 The APC curve of the lag days. price_proxy ( str , default: 'Settle' ) \u2013 The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile ( list , default: [0.25, 0.4, 0.6, 0.75] ) \u2013 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns: strategy_info ( dict ) \u2013 A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info ( list ) \u2013 A list of prices calculating using qunatile input into the APC of the date of interest. Source code in EC_tools/strategy.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def gen_data ( self , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , qunatile : list = [ 0.25 , 0.4 , 0.6 , 0.75 ]): \"\"\" A method that generate all the data needed for the strategy. The ouput of this functions contain all the quantity that will be and can be used in creating variation of this strategy. Parameters ---------- history_data_lag : list The history data of the lag days. apc_curve_lag : list The APC curve of the lag days. price_proxy : str, optional The column name to call for price approximation. It can be either \"Open\", \"High\", \"Low\", or \"Settle\". The default is 'Settle'. qunatile : list, optional 1D list that contains the quantile desitred. This function pass it into the APC of the day and calculate the relevant price. The default is [0.25,0.4,0.6,0.75]. Returns ------- strategy_info : dict A dictionary containing two key-value pairs. 'lag_list' is a list of quantiles of the lag days. The size of the list depends on the input size of history_data_lag and apc_curve_lag. 'rollingaverage' is the average of the quantiles in lag_list. It contain a singular float value. qunatile_info : list A list of prices calculating using qunatile input into the APC of the date of interest. \"\"\" lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } qunatile_info = list ( self . _curve_today_spline ( qunatile )) return strategy_info , qunatile_info","title":"gen_data"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy_22.run_cond","text":"A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters: data ( dict ) \u2013 strategy_info from gen_data. open_price ( float ) \u2013 The APC quantile value of the open price. total_lag_days ( int , default: 2 ) \u2013 The total number of lag days. The default is 2. apc_mid_Q ( float , default: 0.5 ) \u2013 The middle quantile of an APC. The default is 0.5. apc_trade_Qrange ( tuple ) \u2013 The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin ( TYPE ) \u2013 The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit ( TYPE ) \u2013 The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns: direction \u2013 The trading direction of the day. cond_info ( list ) \u2013 A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. Source code in EC_tools/strategy.py 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 def run_cond ( self , data : dict , open_price : float , total_lag_days : int = 2 , apc_mid_Q : float = 0.5 ): \"\"\" A method that run the condition elvaluation of this strategy. If the settlement price of the past two days is less (or more) than the apc_mid_Q quantile in their respective days of APC, plus the rolling average for the past five days settlement price qunatile being lower (or higher) than the apc_mid_Q, we deem that day to be a \"Buy\" (or \"Sell\") day. Parameters ---------- data : dict strategy_info from gen_data. open_price : float The APC quantile value of the open price. total_lag_days : int, optional The total number of lag days. The default is 2. apc_mid_Q : float, optional The middle quantile of an APC. The default is 0.5. apc_trade_Qrange : tuple, optional The trading quantile range. The default is (0.4,0.6). apc_trade_Qmargin : TYPE, optional The trading margin quantile range. The default is (0.1,0.9). apc_trade_Qlimit : TYPE, optional The limit range for trading. This is the stoploss quantile The default is (0.05,0.95). Returns ------- self.direction The trading direction of the day. cond_info : list A list of condiions info for the user. For this strategy, the format is the following: [NCONS, NROLL, Signal_NCONS, Signal_NROLL] Where NCONS is the number of lag days, NROLL is the number of lag days used to calculate the rollingaverage, Signal_NCONS is the trading signal using solely NCONS, and Signal_NROLL is the trading signal using solely NROLL. \"\"\" rollingaverage_q = data [ 'rollingaverage' ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] mid_Q_list = [ apc_mid_Q for i in range ( total_lag_days )] # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the last two # consecutive days of closing price lower than the signal median cond_buy_list_1 = list ( map ( lambda x , y : x < y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average lower than the median apc cond_buy_list_2 = [( rollingaverage_q < apc_mid_Q )] # (3) price at today's opening hour above the 0.1 quantile of today's apc cond_buy_list_3 = [( open_price >= apc_mid_Q )] # \"SELL\" condition # (1) Two consecutive days of closing price higher than the signal median cond_sell_list_1 = list ( map ( lambda x , y : x > y , lag_close_q_list , mid_Q_list )) # (2) rolling 5 days average higher than the median apc cond_sell_list_2 = [( rollingaverage_q > apc_mid_Q )] # (3) price at today's opening hour below the 0.9 quantile of today's apc cond_sell_list_3 = [( open_price <= apc_mid_Q )] # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCONS' : [ cond_buy_list_1 ], 'NROLL' : [ cond_buy_list_2 ]} #'OP_WITHIN': [cond_buy_list_3]} self . _sub_sell_cond_dict = { 'NCONS' : [ cond_sell_list_1 ], 'NROLL' : [ cond_sell_list_2 ]} #'OP_WITHIN': [cond_sell_list_3]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCONS , NROLL , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info","title":"run_cond"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMRStrategy_22.set_EES","text":"A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters: buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises: Exception \u2013 For invalid direction. It has to conform to the StrategyStatus Attributes. Returns: entry_price ( list ) \u2013 A list contain the price caculated by the APC given the buy_range input. exit_price ( list ) \u2013 A list contain the price caculated by the APC given the sell_range input. stop_loss ( float ) \u2013 A price caculated by the APC given the stop_loss input. Source code in EC_tools/strategy.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 def set_EES ( self , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 )): \"\"\" A method the set the Entry, Exit, Stop loss prices. This method read-in the direction attribute of the strategy and decide which set of EES value to be set. Parameters ---------- buy_range : tuple, optional A tuple that contain the desired quantile value range for buy action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional A tuple that contain the desired quantile value range for sell action. The format should be the following: ([lower_limit_entry, upper_limit_entry], [lower_limit_exit, upper_exit], stop_loss) The default is ([0.6,0.75],[0.25,0.4],0.95). Raises ------ Exception For invalid direction. It has to conform to the StrategyStatus Attributes. Returns ------- entry_price : list A list contain the price caculated by the APC given the buy_range input. exit_price : list A list contain the price caculated by the APC given the sell_range input. stop_loss : float A price caculated by the APC given the stop_loss input. \"\"\" if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ float ( self . _curve_today_spline ( buy_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( buy_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( buy_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.1 stop_loss = float ( self . _curve_today_spline ( buy_range [ 2 ])) elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ float ( self . _curve_today_spline ( sell_range [ 0 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 0 ][ 1 ]))] # (B) Exit price exit_price = [ float ( self . _curve_today_spline ( sell_range [ 1 ][ 0 ])), float ( self . _curve_today_spline ( sell_range [ 1 ][ 1 ]))] # (C) Stop loss at APC p=0.9 stop_loss = float ( self . _curve_today_spline ( sell_range [ 2 ])) elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss","title":"set_EES"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMonthlyStrategy","text":"Bases: Strategy Source code in EC_tools/strategy.py 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 class ArgusMonthlyStrategy ( Strategy ): def __init__ ( self , curve_monthly = np . arange ( 0.0025 , 0.9975 , 0.0025 ), curve_today = np . arange ( 0.0025 , 0.9975 , 0.0025 ), quant_list = np . arange ( 0.0025 , 0.9975 , 0.0025 )): super () . __init__ () self . _curve_monthly = curve_monthly self . _curve_today = curve_today self . _quant_list = quant_list self . _curve_monthly_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_monthly ) self . _curve_today_spline = mfunc . generic_spline ( self . _quant_list , self . _curve_today ) self . _sub_buy_cond_dict = dict () self . _sub_sell_cond_dict = dict () self . sub_cond_dict = { 'Buy' :[], 'Sell' :[], 'Neutral' : []} self . strategy_name = 'argus_monthly' def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList def gen_data ( self , daily_cumavg : float , prev_cum_n : float , history_data_lag : list , apc_curve_lag : list , price_proxy : str = 'Settle' , quantile : list = [ 0.05 , 0.10 , 0.35 , 0.50 , 0.65 , 0.90 , 0.95 ]): lag_price = history_data_lag [ price_proxy ] lag_list = [ mfunc . find_quant ( apc_curve_lag . iloc [ i ] . to_numpy ()[ - 1 - APC_LENGTH : - 1 ], self . _quant_list , lag_price . iloc [ i ]) for i in range ( len ( apc_curve_lag ))] lag_list . reverse () # Note that the list goes like this [lag1q,lag2q,...] # calculate the rolling average rollingaverage_q = np . average ( lag_list ) strategy_info = { \"daily_cumavg\" : daily_cumavg , \"prev_cum_n\" : prev_cum_n , 'lag_list' : lag_list , 'rollingaverage' : rollingaverage_q } quantile_info = list ( self . _curve_today_spline ( quantile )) return strategy_info , quantile_info def run_cond ( self , data : dict , total_lag_days : int = 2 , apc_range_trigger_buy : list = [ 0.10 , 0.35 ], apc_range_trigger_sell : list = [ 0.65 , 0.90 ]): lag1q = data [ 'lag_list' ][ 0 ] rollingaverage_q = data [ 'rollingaverage' ] daily_cumavg = data [ \"daily_cumavg\" ] prev_cum_n = data [ \"prev_cum_n\" ] lag_close_q_list = [ data [ 'lag_list' ][ i ] for i in range ( total_lag_days )] #mid_Q_list = [apc_mid_Q for i in range(total_lag_days)] quant_price_entry_lower_buy = self . _curve_monthly_spline ( apc_range_trigger_buy [ 0 ]) quant_price_entry_upper_buy = self . _curve_monthly_spline ( apc_range_trigger_buy [ 1 ]) quant_price_entry_lower_sell = self . _curve_monthly_spline ( apc_range_trigger_sell [ 0 ]) quant_price_entry_upper_sell = self . _curve_monthly_spline ( apc_range_trigger_sell [ 1 ]) # \"BUY\" condition # (1) create a list of Boolean value for evaluating if the # total_cum_avg is within the monthly APC: Q0.1 < total_cum_avg < Q0.35 cond_buy_list_1 = list ( map ( lambda x , low , up : low < x < up , [ daily_cumavg ], [ quant_price_entry_lower_buy ], [ quant_price_entry_upper_buy ])) print ( \"condition 1 Buy\" ) print ( quant_price_entry_lower_buy , '<' , daily_cumavg , '<' , quant_price_entry_upper_buy , cond_buy_list_1 ) # (2) The lag1q for the day before has to be lower than the entry lower bound # (2) rolling 5 days average lower than the daily apc entry upper bound cond_buy_list_2 = [( lag1q < 0.25 )] print ( \"condition 2 Buy\" ) print ( lag1q , '<' , 0.25 , lag1q < 0.25 ) cond_buy_list_3 = [( rollingaverage_q < 0.4 )] print ( \"condition 3 Buy\" ) print ( rollingaverage_q , '<' , 0.4 , rollingaverage_q < 0.4 ) # \"SELL\" condition # (1) create a list of Boolean value for evaluating if the # total_cum_avg is within the monthly APC: Q0.65 < total_cum_avg < Q0.9 cond_sell_list_1 = list ( map ( lambda x , low , up : low < x < up , [ daily_cumavg ], [ quant_price_entry_lower_sell ], [ quant_price_entry_upper_sell ])) print ( \"condition 1 Sell\" ) print ( quant_price_entry_lower_sell , '<' , daily_cumavg , '<' , quant_price_entry_upper_sell , cond_sell_list_1 ) # (2) price at today's opening hour below the 0.9 quantile of today's apc # (2) rolling 5 days average higher than the daily apc entry upper bound cond_sell_list_2 = [( lag1q > 0.75 )] print ( \"condition 2 Sell\" ) print ( lag1q , '>' , 0.75 , lag1q > 0.75 ) cond_sell_list_3 = [( rollingaverage_q > 0.6 )] print ( \"condition 3 Sell\" ) print ( rollingaverage_q , '>' , 0.6 , rollingaverage_q > 0.6 ) # save the condtion boolean value to the sub-condition dictionary self . _sub_buy_cond_dict = { 'NCUM_CONS' : [ cond_buy_list_1 ], 'NCONS' : [ cond_buy_list_2 ], 'NROLL' : [ cond_buy_list_3 ]} self . _sub_sell_cond_dict = { 'NCUM_CONS' : [ cond_sell_list_1 ], 'NCONS' : [ cond_sell_list_2 ], 'NROLL' : [ cond_sell_list_3 ]} # Store all sub-conditions into self . sub_cond_dict = { 'Buy' :[ sum ( self . _sub_buy_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ], 'Sell' :[ sum ( self . _sub_sell_cond_dict [ key ],[]) for key in self . _sub_buy_cond_dict ]} # flatten the sub-conditoion list and sotre them in the condition list self . flatten_sub_cond_dict () # Create the condtion info for bookkeeping NCUM_CONS , NCONS , NROLL = len ( self . _sub_buy_cond_dict [ 'NCUM_CONS' ]), \\ len ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]), \\ len ( data [ 'lag_list' ]) # Find the Boolean value for each buy conditions subgroup sub_buy_1 = all ( self . _sub_buy_cond_dict [ 'NCUM_CONS' ][ 0 ]) sub_buy_2 = all ( self . _sub_buy_cond_dict [ 'NCONS' ][ 0 ]) sub_buy_3 = all ( self . _sub_buy_cond_dict [ 'NROLL' ][ 0 ]) # Find the Boolean value for each Sell conditions subgroup sub_sell_1 = all ( self . _sub_sell_cond_dict [ 'NCUM_CONS' ][ 0 ]) sub_sell_2 = all ( self . _sub_sell_cond_dict [ 'NCONS' ][ 0 ]) sub_sell_3 = all ( self . _sub_sell_cond_dict [ 'NROLL' ][ 0 ]) # Construct condtion dictionaray for each condition cond_dict_1 = { 'Buy' : sub_buy_1 , 'Sell' : sub_sell_1 , 'Neutral' : not ( sub_buy_1 ^ sub_sell_1 )} cond_dict_2 = { 'Buy' : sub_buy_2 , 'Sell' : sub_sell_2 , 'Neutral' : not ( sub_buy_2 ^ sub_sell_2 )} cond_dict_3 = { 'Buy' : sub_buy_3 , 'Sell' : sub_sell_3 , 'Neutral' : not ( sub_buy_3 ^ sub_sell_3 )} # Degine the name for the Buy/Sell action for each condition subgroups Signal_NCUM_CONS = [ key for key in cond_dict_1 if cond_dict_1 [ key ] == True ][ 0 ] Signal_NCONS = [ key for key in cond_dict_2 if cond_dict_2 [ key ] == True ][ 0 ] Signal_NROLL = [ key for key in cond_dict_3 if cond_dict_3 [ key ] == True ][ 0 ] # Put the condition info in a list cond_info = [ NCUM_CONS , NCONS , NROLL , Signal_NCUM_CONS , Signal_NCONS , Signal_NROLL ] return self . direction , cond_info # ============================================================================= # # \"Entry condition\" These information are for the backtests # check_entry_buy = (q0_10 < today_cum_avg < q0_35) # Buy # check_entry_sell = (q0_65 < today_cum_avg < q0_90) # Sell # # Exit condition # check_exit_buy = (q0_50 < today_cum_avg < q0_90) # Buy # check_exit_sell = (q0_10 < today_cum_avg < q0_50) # Sell # # # Stoploss # check_stoploss_buy = (today_cum_avg < q0_05) # check_stoploss_sell = (today_cum_avg > q0_95) # ============================================================================= def set_EES ( self , data : dict , buy_range : tuple = ([ 0.10 , 0.35 ],[ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ],[ 0.10 , 0.50 ], 0.95 )): # buy_range = ([lower_bound_entry, upper_bound_entry], # [lower_bound_exit, upper_bound_exit], stoploss) prev_cum_avg = data [ \"daily_cumavg\" ] prev_cum_n = data [ \"prev_cum_n\" ] # A list of quantile price for buy and sell range quant_price_entry_lower_buy = self . _curve_monthly_spline ( buy_range [ 0 ][ 0 ]) quant_price_entry_upper_buy = self . _curve_monthly_spline ( buy_range [ 0 ][ 1 ]) quant_price_exit_lower_buy = self . _curve_monthly_spline ( buy_range [ 1 ][ 0 ]) quant_price_exit_upper_buy = self . _curve_monthly_spline ( buy_range [ 1 ][ 1 ]) quant_price_entry_lower_sell = self . _curve_monthly_spline ( sell_range [ 0 ][ 0 ]) quant_price_entry_upper_sell = self . _curve_monthly_spline ( sell_range [ 0 ][ 1 ]) quant_price_exit_lower_sell = self . _curve_monthly_spline ( sell_range [ 1 ][ 0 ]) quant_price_exit_upper_sell = self . _curve_monthly_spline ( sell_range [ 1 ][ 1 ]) quant_price_stoploss_buy = self . _curve_monthly_spline ( buy_range [ 2 ]) quant_price_stoploss_sell = self . _curve_monthly_spline ( sell_range [ 2 ]) # The actual price target # \"Buy\" target entry range buy_target_lower_entry = quant_price_entry_lower_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n buy_target_upper_entry = quant_price_entry_upper_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Buy\" target exit range buy_target_lower_exit = quant_price_exit_lower_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n buy_target_upper_exit = quant_price_exit_upper_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Buy\" target stoploss buy_stoploss_exit = quant_price_stoploss_buy * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Sell\" target entry range sell_target_lower_entry = quant_price_entry_lower_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n sell_target_upper_entry = quant_price_entry_upper_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Sell\" target exit range sell_target_lower_exit = quant_price_exit_lower_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n sell_target_upper_exit = quant_price_exit_upper_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n # \"Sell\" target Stoploss sell_stoploss_exit = quant_price_stoploss_sell * ( prev_cum_n + 1 ) - \\ prev_cum_avg * prev_cum_n if self . direction == SignalStatus . BUY : # (A) Entry region at price < APC p=0.4 and entry_price = [ buy_target_lower_entry , buy_target_upper_entry ] # (B) Exit price exit_price = [ buy_target_lower_exit , buy_target_upper_exit ] # (C) Stop loss at APC p=0.1 stop_loss = buy_stoploss_exit elif self . direction == SignalStatus . SELL : # (A) Entry region at price > APC p=0.6 and entry_price = [ sell_target_lower_entry , sell_target_upper_entry ] # (B) Exit price exit_price = [ sell_target_lower_exit , sell_target_upper_exit ] # (C) Stop loss at APC p=0.9 stop_loss = sell_stoploss_exit elif self . direction == SignalStatus . NEUTRAL : entry_price = [ \"NA\" , \"NA\" ] exit_price = [ \"NA\" , \"NA\" ] stop_loss = \"NA\" else : raise Exception ( 'Unaccepted input, condition needs to be either Buy, \\ Sell, or Neutral.' ) return entry_price , exit_price , stop_loss def apply_strategy ( self , history_data_lag : list , apc_curve_lag : list , daily_cumavg : float , prev_cum_n : float , quantile : list = [ 0.05 , 0.10 , 0.35 , 0.50 , 0.65 , 0.90 , 0.95 ], total_lag_days : int = 1 , buy_range : tuple = ([ 0.10 , 0.35 ],[ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ],[ 0.10 , 0.50 ], 0.95 )): strategy_info , quantile_info = self . gen_data ( daily_cumavg , prev_cum_n , history_data_lag , apc_curve_lag , quantile = quantile ) #open_price_quant = mfunc.find_quant(self._curve_today, # self._quant_list, open_price) direction , cond_info = self . run_cond ( strategy_info , total_lag_days = total_lag_days ) entry_price , exit_price , stop_loss = self . set_EES ( strategy_info , buy_range = buy_range , sell_range = sell_range ) if direction == SignalStatus . BUY : entry_price_val , exit_price_val = entry_price [ 1 ], exit_price [ 0 ] elif direction == SignalStatus . SELL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 1 ] elif direction == SignalStatus . NEUTRAL : entry_price_val , exit_price_val = entry_price [ 0 ], exit_price [ 0 ] # Bookkeeping area EES = [ entry_price [ 0 ], entry_price [ 1 ], exit_price [ 0 ], exit_price [ 1 ], stop_loss ] EES_val = [ entry_price_val , exit_price_val , stop_loss ] # Turn strategy_info from dict to list strategy_info_list = strategy_info [ 'lag_list' ] + [ strategy_info [ 'rollingaverage' ]] # put all the data in a singular list. This is to be added in the # data list in the loop #print(EES+ cond_info, strategy_info_list, quantile_info, [self.strategy_name]) #print(type(EES+ cond_info), type(strategy_info_list), type(quantile_info), type([self.strategy_name])) data = EES + cond_info + strategy_info_list + \\ quantile_info + EES_val + [ self . strategy_name ] return { 'data' : data , 'direction' : direction . value }","title":"ArgusMonthlyStrategy"},{"location":"EC_tools/strategy/#EC_tools.strategy.ArgusMonthlyStrategy.flatten_sub_cond_dict","text":"A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns: None. \u2013 Source code in EC_tools/strategy.py 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def flatten_sub_cond_dict ( self ) -> None : \"\"\" A method that turn a sub-condition-dictionary into a condition-dictionary and pass it to the Strategy parent class. This function assume the sub_cond_dict is only one layer deep, i.e. a structure like this: {'Buy': [[...], [...], [...]], 'Sell':...}. Structure like this is not allowed: {'Buy': [[...], [[...],[...]], [...]], 'Sell':...}. Returns ------- None. \"\"\" # a method that turn a sub_cond_dict into a cond_dict assuming the # subgroups are only one layer deep. for key in self . sub_cond_dict : lis = self . sub_cond_dict [ key ] flatList = sum ( lis , []) self . cond_dict [ key ] = flatList","title":"flatten_sub_cond_dict"},{"location":"EC_tools/strategy/#EC_tools.strategy.SignalStatus","text":"Bases: Enum A simple class that contains the avaliable status for signals. Source code in EC_tools/strategy.py 29 30 31 32 33 34 35 36 class SignalStatus ( Enum ): \"\"\" A simple class that contains the avaliable status for signals. \"\"\" BUY = \"Buy\" # When the position is added but not filled SELL = \"Sell\" # When the position is executed NEUTRAL = \"Neutral\" # When the position is cancelled","title":"SignalStatus"},{"location":"EC_tools/strategy/#EC_tools.strategy.Strategy","text":"Bases: Protocol A Strategy is defined by given specific inputs related to forecasting or past price data or other indicators that out put a specific instructions (e.g., Buy/Sell/Neutral or something more complex) for a back-testing system or a live trading alogirthm to execute. The trading instructions in question does not contain information about the style of trading (e.g., one entry per day, or more), It is solely informational on where you should buy/sell. Source code in EC_tools/strategy.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class Strategy ( Protocol ): \"\"\" A Strategy is defined by given specific inputs related to forecasting or past price data or other indicators that out put a specific instructions (e.g., Buy/Sell/Neutral or something more complex) for a back-testing system or a live trading alogirthm to execute. The trading instructions in question does not contain information about the style of trading (e.g., one entry per day, or more), It is solely informational on where you should buy/sell. \"\"\" def __init__ ( self ): self . _buy_cond = False self . _sell_cond = False self . _neutral_cond = True self . cond_dict = { \"Buy\" : [ False ], \"Sell\" : [ False ]} # make the default value of a strategy 'Neutral' self . _direction = SignalStatus . NEUTRAL @property def buy_cond ( self ): \"\"\" The overall boolean value of the Buy condition \"\"\" self . _buy_cond = all ( self . cond_dict [ 'Buy' ]) return self . _buy_cond @property def sell_cond ( self ): \"\"\" The overall boolean value of the Sell condition \"\"\" self . _sell_cond = all ( self . cond_dict [ 'Sell' ]) return self . _sell_cond @property def neutral_cond ( self ): \"\"\" The overall boolean value of the Neutral condition \"\"\" self . _neutral_cond = not ( self . buy_cond ^ self . sell_cond ) return self . _neutral_cond @property def direction ( self ): if self . buy_cond == True : self . _direction = SignalStatus . BUY if self . sell_cond == True : self . _direction = SignalStatus . SELL if self . neutral_cond == True : self . _direction = SignalStatus . NEUTRAL return self . _direction","title":"Strategy"},{"location":"EC_tools/strategy/#EC_tools.strategy.Strategy.buy_cond","text":"The overall boolean value of the Buy condition","title":"buy_cond"},{"location":"EC_tools/strategy/#EC_tools.strategy.Strategy.neutral_cond","text":"The overall boolean value of the Neutral condition","title":"neutral_cond"},{"location":"EC_tools/strategy/#EC_tools.strategy.Strategy.sell_cond","text":"The overall boolean value of the Sell condition","title":"sell_cond"},{"location":"EC_tools/trade/","text":"Trade Created on Fri May 10 00:16:28 2024 @author: dexter The Trade module contains relevant classes and functions that control trade actions, i.e., the trade decision logic. Trade class BiDirectionalTrade Bases: Trade Bi-Directional Trade (Hedging position). The idea is to open two position, both Buy and Sell at trade-open given a set of entry and exit prices. If the price moves past the entry point of either direction, we fill the Buy/Sell order and enter the position. When the exit value is hit, we exit and close the position. The entry and exit range can be asymmetrical. User can manually input the range they want for either trades. At the moment, this method is limited to trading one Buy or Sell position per day, i.e., the maximum number of trades per day is one Buy plus one Sell. This method also assume the Buy and Sell action are independent from each other, that is, the two trade can be calculated and executed in parallel. Source code in EC_tools/trade.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 class BiDirectionalTrade ( Trade ): \"\"\" Bi-Directional Trade (Hedging position). The idea is to open two position, both Buy and Sell at trade-open given a set of entry and exit prices. If the price moves past the entry point of either direction, we fill the Buy/Sell order and enter the position. When the exit value is hit, we exit and close the position. The entry and exit range can be asymmetrical. User can manually input the range they want for either trades. At the moment, this method is limited to trading one Buy or Sell position per day, i.e., the maximum number of trades per day is one Buy plus one Sell. This method also assume the Buy and Sell action are independent from each other, that is, the two trade can be calculated and executed in parallel. \"\"\" def __init__ ( self , portfolio ): super () . __init__ ( portfolio ) @staticmethod def choose_EES_values ( self , trunc_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" Same method as OneTradePerDay \"\"\" #print(self.portfolio) return OneTradePerDay ( self . _portfolio ) . choose_EES_values ( trunc_dict ) def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ) \\ -> list [ Position ]: \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , size , fee , open_time , trade_id ) def execute_positions ( self , EES_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . execute_positions ( EES_dict , pos_list , pos_type ) def run_trade ( self , day : pd . DataFrame , give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], target_exit : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], stop_exit : dict [ str , float ], open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None , trade_id : int = 0 ) -> \\ tuple [ dict , tuple , tuple , list , list ]: \"\"\" This method only look into the data points that crosses the threashold. Thus it is fast but it only perform simple testing. Comprehesive dynamic testing requires other functions Parameters ---------- EES_dict : dict A dictionary for all possible EES values. This assume you are running a crossover loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : dict The target entry price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions target_exit : dict The target exit price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions stop_exit : dict The stop loss price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" target_entry_buy = target_entry [ 'Buy' ] target_exit_buy = target_exit [ 'Buy' ] stop_exit_buy = stop_exit [ 'Buy' ] target_entry_sell = target_entry [ 'Sell' ] target_exit_sell = target_exit [ 'Sell' ] stop_exit_sell = stop_exit [ 'Sell' ] #Find the minute that the price crosses the EES values EES_dict_buy = read . find_minute_EES ( day , target_entry_buy , target_exit_buy , stop_exit_buy , open_hr = open_hr , close_hr = close_hr , direction = 'Buy' ) EES_dict_sell = read . find_minute_EES ( day , target_entry_sell , target_exit_sell , stop_exit_sell , open_hr = open_hr , close_hr = close_hr , direction = 'Sell' ) EES_buy_target_list = [ target_entry_buy , target_exit_buy , stop_exit_buy , EES_dict_buy [ 'close' ][ 1 ]] EES_sell_target_list = [ target_entry_sell , target_exit_sell , stop_exit_sell , EES_dict_sell [ 'close' ][ 1 ]] # Note that the trading for Buy and Sell directions are executed # independently (in Parallel). Therefore, the resulting Portfolio # pool and position pool are not going to be sorted perfectly by # entry time. trade_id_buy = 'Buy' + str ( trade_id ) trade_id_sell = 'Sell' + str ( trade_id ) # Buy pos_list_buy = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_buy_target_list , \\ pos_type = 'Long' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_buy ) trade_open_buy , trade_close_buy , \\ pos_list_buy , exec_pos_list_buy = self . execute_positions ( EES_dict_buy , pos_list_buy , pos_type = 'Long' ) # Sell pos_list_sell = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_sell_target_list , \\ pos_type = 'Short' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_sell ) trade_open_sell , trade_close_sell , \\ pos_list_sell , exec_pos_list_sell = self . execute_positions ( EES_dict_sell , pos_list_sell , pos_type = 'Short' ) # Now Bundle all the data together EES_dict , \\ trade_open , trade_close , \\ pos_dict , exec_pos_dict = dict (), dict (), dict (), dict (), dict () EES_dict [ 'Buy' ], EES_dict [ 'Sell' ] = EES_dict_buy , EES_dict_sell trade_open [ 'Buy' ], trade_open [ 'Sell' ] = trade_open_buy , trade_open_sell trade_close [ 'Buy' ], trade_close [ 'Sell' ] = trade_close_buy , trade_close_sell pos_dict [ 'Buy' ], pos_dict [ 'Sell' ] = pos_list_buy , pos_list_sell exec_pos_dict [ 'Buy' ], exec_pos_dict [ 'Sell' ] = exec_pos_list_buy , exec_pos_list_sell return EES_dict , trade_open , trade_close , pos_dict , exec_pos_dict choose_EES_values ( trunc_dict ) staticmethod Same method as OneTradePerDay Source code in EC_tools/trade.py 556 557 558 559 560 561 562 563 564 @staticmethod def choose_EES_values ( self , trunc_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" Same method as OneTradePerDay \"\"\" #print(self.portfolio) return OneTradePerDay ( self . _portfolio ) . choose_EES_values ( trunc_dict ) execute_positions ( EES_dict , pos_list , pos_type = 'Long' ) Same method as OneTradePerDay Source code in EC_tools/trade.py 589 590 591 592 593 594 595 596 597 598 599 def execute_positions ( self , EES_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . execute_positions ( EES_dict , pos_list , pos_type ) open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , size = 1 , fee = None , open_time = datetime . datetime . now (), trade_id = 0 ) Same method as OneTradePerDay Source code in EC_tools/trade.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ) \\ -> list [ Position ]: \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , size , fee , open_time , trade_id ) run_trade ( day , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = '0300' , close_hr = '2000' , direction = 'Buy' , fee = OIL_FUTURES_FEE , open_time = None , trade_id = 0 ) This method only look into the data points that crosses the threashold. Thus it is fast but it only perform simple testing. Comprehesive dynamic testing requires other functions Parameters: EES_dict ( dict ) \u2013 A dictionary for all possible EES values. This assume you are running a crossover loop. give_obj_name ( str ) \u2013 The name of the give_obj, e.g. 'USD'. get_obj_name ( str ) \u2013 The name of the get_obj, e.g. 'CLc1'. get_obj_quantity ( int or float ) \u2013 The quanity of get_obj you wish to order. target_entry ( dict ) \u2013 The target entry price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions target_exit ( dict ) \u2013 The target exit price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions stop_exit ( dict ) \u2013 The stop loss price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions open_hr ( str , default: '0300' ) \u2013 The opening hour of the trade close_hr ( str , default: '2000' ) \u2013 The closing hour of the trade direction ( str , default: 'Buy' ) \u2013 The default is \"Buy\" Returns: ( EES_dict , trade_open , trade_close , pos_list , exec_pos_list ) \u2013 Source code in EC_tools/trade.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 def run_trade ( self , day : pd . DataFrame , give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], target_exit : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], stop_exit : dict [ str , float ], open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None , trade_id : int = 0 ) -> \\ tuple [ dict , tuple , tuple , list , list ]: \"\"\" This method only look into the data points that crosses the threashold. Thus it is fast but it only perform simple testing. Comprehesive dynamic testing requires other functions Parameters ---------- EES_dict : dict A dictionary for all possible EES values. This assume you are running a crossover loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : dict The target entry price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions target_exit : dict The target exit price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions stop_exit : dict The stop loss price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" target_entry_buy = target_entry [ 'Buy' ] target_exit_buy = target_exit [ 'Buy' ] stop_exit_buy = stop_exit [ 'Buy' ] target_entry_sell = target_entry [ 'Sell' ] target_exit_sell = target_exit [ 'Sell' ] stop_exit_sell = stop_exit [ 'Sell' ] #Find the minute that the price crosses the EES values EES_dict_buy = read . find_minute_EES ( day , target_entry_buy , target_exit_buy , stop_exit_buy , open_hr = open_hr , close_hr = close_hr , direction = 'Buy' ) EES_dict_sell = read . find_minute_EES ( day , target_entry_sell , target_exit_sell , stop_exit_sell , open_hr = open_hr , close_hr = close_hr , direction = 'Sell' ) EES_buy_target_list = [ target_entry_buy , target_exit_buy , stop_exit_buy , EES_dict_buy [ 'close' ][ 1 ]] EES_sell_target_list = [ target_entry_sell , target_exit_sell , stop_exit_sell , EES_dict_sell [ 'close' ][ 1 ]] # Note that the trading for Buy and Sell directions are executed # independently (in Parallel). Therefore, the resulting Portfolio # pool and position pool are not going to be sorted perfectly by # entry time. trade_id_buy = 'Buy' + str ( trade_id ) trade_id_sell = 'Sell' + str ( trade_id ) # Buy pos_list_buy = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_buy_target_list , \\ pos_type = 'Long' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_buy ) trade_open_buy , trade_close_buy , \\ pos_list_buy , exec_pos_list_buy = self . execute_positions ( EES_dict_buy , pos_list_buy , pos_type = 'Long' ) # Sell pos_list_sell = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_sell_target_list , \\ pos_type = 'Short' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_sell ) trade_open_sell , trade_close_sell , \\ pos_list_sell , exec_pos_list_sell = self . execute_positions ( EES_dict_sell , pos_list_sell , pos_type = 'Short' ) # Now Bundle all the data together EES_dict , \\ trade_open , trade_close , \\ pos_dict , exec_pos_dict = dict (), dict (), dict (), dict (), dict () EES_dict [ 'Buy' ], EES_dict [ 'Sell' ] = EES_dict_buy , EES_dict_sell trade_open [ 'Buy' ], trade_open [ 'Sell' ] = trade_open_buy , trade_open_sell trade_close [ 'Buy' ], trade_close [ 'Sell' ] = trade_close_buy , trade_close_sell pos_dict [ 'Buy' ], pos_dict [ 'Sell' ] = pos_list_buy , pos_list_sell exec_pos_dict [ 'Buy' ], exec_pos_dict [ 'Sell' ] = exec_pos_list_buy , exec_pos_list_sell return EES_dict , trade_open , trade_close , pos_dict , exec_pos_dict OneTradePerDay Bases: Trade A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. Source code in EC_tools/trade.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 class OneTradePerDay ( Trade ): \"\"\" A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. \"\"\" def __init__ ( self , portfolio , trade_id : int = 0 ): super () . __init__ ( portfolio ) self . trade_id = trade_id @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"pos_list\", pos_list) return pos_list def execute_positions ( self , trunc_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # Unpack inputs entry_pos , exit_pos , stop_pos , close_pos = pos_list [ 0 ], pos_list [ 1 ], \\ pos_list [ 2 ], pos_list [ 3 ] # Search for the appropiate time for entry, exit, stop loss, # and close time for the trade entry_pt , exit_pt , stop_pt , close_pt = self . choose_EES_values ( trunc_dict ) # initialise trade_open and trade_close time and prices trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) opening_pos , closing_pos = None , None # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] # Run diagnosis to decide which outcome it is for the day # Case 1: No trade because entry is not hit if entry_pt == ( np . nan , np . nan ): #print(\"No trade.\") # Cancel all order positions ExecutePosition ( entry_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( stop_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) return trade_open , trade_close , pos_list , exec_pos_list # Case 2: An exit is hit, normal exit elif entry_pt and exit_pt != ( np . nan , np . nan ): #print(\"Noraml exit.\") trade_open , trade_close = entry_pt , exit_pt opening_pos , closing_pos = entry_pos , exit_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( exit_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 3: stop loss elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): #print('Stop loss.') trade_open , trade_close = entry_pt , stop_pt opening_pos , closing_pos = entry_pos , stop_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( stop_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 4: Neither an exit or stop loss is hit, exit position at close time elif exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print(\"Sell at close.\") trade_open , trade_close = entry_pt , close_pt opening_pos , closing_pos = entry_pos , close_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( close_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # change the price for the open position opening_pos . price = entry_pt [ 1 ] #print('entry_pt[1]', entry_pt[1]) #print('exit_pt[1]', exit_pt[1]) #print('stop_pt[1]', stop_pt[1]) #print('close_pt[1]', close_pt[1]) #print(\"After price adjustment\", opening_pos, closing_pos) # Execute the positions ExecutePosition ( opening_pos ) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) ExecutePosition ( closing_pos ) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"exec_pos_list\", exec_pos_list) for pos in pos_list : # Add position in the position book self . _portfolio . _position_pool . append ( copy . copy ( pos )) return trade_open , trade_close , pos_list , exec_pos_list def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_list = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) #trade_id= self.trade_id) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_list , exec_pos_list = self . execute_positions ( trunc_dict , pos_list , pos_type = pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_list , exec_pos_list choose_EES_values ( EES_dict ) staticmethod A method to find the appropiate EES values of the day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters: EES_dict ( dict ) \u2013 A dictionary for all possible EES values. Returns: entry_pt ( tuple ) \u2013 The time and price of the entry moment. exit_pt ( tuple ) \u2013 The time and price of the exit moment. stop_pt ( tuple ) \u2013 The time and price of the stop loss moment. close_pt ( tuple ) \u2013 The time and price of the close hour exit moment. Source code in EC_tools/trade.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt execute_positions ( trunc_dict , pos_list , pos_type = 'Long' ) A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters: trunc_dict ( dict ) \u2013 A truncation dictionary for all possible EES values. pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type ( str , default: 'Long' ) \u2013 The type of position. The default is \"Long\". Returns: trade_open ( 2-elements tuple ) \u2013 The trade open time and price trade_close ( 2-elements tuple ) \u2013 The trade close time and price pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list ( list ) \u2013 The [opening_pos, closing_pos] . Source code in EC_tools/trade.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 def execute_positions ( self , trunc_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # Unpack inputs entry_pos , exit_pos , stop_pos , close_pos = pos_list [ 0 ], pos_list [ 1 ], \\ pos_list [ 2 ], pos_list [ 3 ] # Search for the appropiate time for entry, exit, stop loss, # and close time for the trade entry_pt , exit_pt , stop_pt , close_pt = self . choose_EES_values ( trunc_dict ) # initialise trade_open and trade_close time and prices trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) opening_pos , closing_pos = None , None # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] # Run diagnosis to decide which outcome it is for the day # Case 1: No trade because entry is not hit if entry_pt == ( np . nan , np . nan ): #print(\"No trade.\") # Cancel all order positions ExecutePosition ( entry_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( stop_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) return trade_open , trade_close , pos_list , exec_pos_list # Case 2: An exit is hit, normal exit elif entry_pt and exit_pt != ( np . nan , np . nan ): #print(\"Noraml exit.\") trade_open , trade_close = entry_pt , exit_pt opening_pos , closing_pos = entry_pos , exit_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( exit_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 3: stop loss elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): #print('Stop loss.') trade_open , trade_close = entry_pt , stop_pt opening_pos , closing_pos = entry_pos , stop_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( stop_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 4: Neither an exit or stop loss is hit, exit position at close time elif exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print(\"Sell at close.\") trade_open , trade_close = entry_pt , close_pt opening_pos , closing_pos = entry_pos , close_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( close_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # change the price for the open position opening_pos . price = entry_pt [ 1 ] #print('entry_pt[1]', entry_pt[1]) #print('exit_pt[1]', exit_pt[1]) #print('stop_pt[1]', stop_pt[1]) #print('close_pt[1]', close_pt[1]) #print(\"After price adjustment\", opening_pos, closing_pos) # Execute the positions ExecutePosition ( opening_pos ) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) ExecutePosition ( closing_pos ) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"exec_pos_list\", exec_pos_list) for pos in pos_list : # Add position in the position book self . _portfolio . _position_pool . append ( copy . copy ( pos )) return trade_open , trade_close , pos_list , exec_pos_list open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , size = 1 , fee = None , open_time = datetime . datetime . now ()) A method to open the entry, exit, stop, and close positions. Parameters: give_obj_name ( str ) \u2013 The name of the give object. get_obj_name ( str ) \u2013 The name of the get object. get_obj_quantity ( float ) \u2013 The quantity of the get object. EES_target_list ( list ) \u2013 A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type ( str ) \u2013 The type of position to be opened. Returns: pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. Source code in EC_tools/trade.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"pos_list\", pos_list) return pos_list run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = '0300' , close_hr = '2000' , direction = 'Buy' , fee = OIL_FUTURES_FEE , open_time = None ) Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters: trunc_dict ( dict ) \u2013 Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name ( str ) \u2013 The name of the give_obj, e.g. 'USD'. get_obj_name ( str ) \u2013 The name of the get_obj, e.g. 'CLc1'. get_obj_quantity ( int or float ) \u2013 The quanity of get_obj you wish to order. target_entry ( float ) \u2013 The target entry time and price. target_exit ( float ) \u2013 The exit entry time and price. stop_exit ( float ) \u2013 The stop loss time and price. open_hr ( str , default: '0300' ) \u2013 The opening hour of the trade close_hr ( str , default: '2000' ) \u2013 The closing hour of the trade direction ( str , default: 'Buy' ) \u2013 The default is \"Buy\" Returns: ( EES_dict , trade_open , trade_close , pos_list , exec_pos_list ) \u2013 Source code in EC_tools/trade.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_list = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) #trade_id= self.trade_id) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_list , exec_pos_list = self . execute_positions ( trunc_dict , pos_list , pos_type = pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_list , exec_pos_list OneTradePerDay_2 Bases: Trade A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. Source code in EC_tools/trade.py 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 class OneTradePerDay_2 ( Trade ): \"\"\" A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. \"\"\" def __init__ ( self , portfolio : Portfolio , trade_id : int = 0 ): super () . __init__ ( portfolio ) self . trade_id = trade_id self . pos_dict = dict () self . exec_pos_dict = dict () self . extra_pos_dict = dict () self . extra_exec_pos_dict = dict () self . key_pos_dict = None self . extra_key_pos_dict = None self . EES_type = None self . EES_para_num = 1 def store_to_position_pool ( self , key_dict : dict , pos_dict : dict , exec_pos_dict : dict ) -> None : # Choose whether to save all positions or just to filled ones. if self . save_only_exec_pos : key_dict = exec_pos_dict else : key_dict = pos_dict # Add position in the position book for pos in list ( key_dict . values ()): self . _portfolio . _position_pool . append ( copy . copy ( pos )) @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the @day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , pos_dict : dict , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) # Store the positions in the position dictionary pos_dict pos_dict [ 'entry_pos' ] = entry_pos pos_dict [ 'exit_pos' ] = exit_pos pos_dict [ 'stop_pos' ] = stop_pos if self . close_exit_or_not == True : close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_dict [ 'close_pos' ] = close_pos return pos_dict def choose_positions ( self , trunc_dict : dict , pos_dict : dict , exec_pos_dict : dict ): print ( \"choose_positions\" ) # Search for the appropiate time for entry, exit, stop loss, # and close time for the trade entry_pt , exit_pt , stop_pt , close_pt = self . choose_EES_values ( trunc_dict ) # initialise trade_open and trade_close time and prices trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) opening_pos , closing_pos = None , None # pack the outputs objects into dict exec_pos_dict [ 'opening_pos' ] = opening_pos exec_pos_dict [ 'closing_pos' ] = closing_pos # Run diagnosis to decide which outcome it is for the day # Case 1: No trade because entry is not hit if entry_pt == ( np . nan , np . nan ): #print(\"No trade.\") # Cancel all order positions in a loop for pos in list ( pos_dict . values ()): ExecutePosition ( pos ) . cancel_pos ( void_time = close_pt [ 0 ]) return trade_open , trade_close # Case 2: An exit is hit, normal exit elif entry_pt and exit_pt != ( np . nan , np . nan ): #print(\"Noraml exit.\") trade_open , trade_close = entry_pt , exit_pt opening_pos , closing_pos = pos_dict [ 'entry_pos' ], pos_dict [ 'exit_pos' ] # change the closing price closing_pos . price = round ( exit_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( pos_dict [ 'stop_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) if self . close_exit_or_not : ExecutePosition ( pos_dict [ 'close_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 3: stop loss elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): #print('Stop loss.') trade_open , trade_close = entry_pt , stop_pt opening_pos , closing_pos = pos_dict [ 'entry_pos' ], pos_dict [ 'stop_pos' ] #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( stop_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( pos_dict [ 'exit_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) if self . close_exit_or_not : ExecutePosition ( pos_dict [ 'close_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 4: Neither an exit or stop loss is hit, exit position at close time elif exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print(\"Sell at close.\") trade_open = entry_pt opening_pos = pos_dict [ 'entry_pos' ] #print(\"Before price adjustment\", opening_pos, closing_pos) # Cancel all order positions ExecutePosition ( pos_dict [ 'stop_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( pos_dict [ 'exit_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) if self . close_exit_or_not : trade_close = close_pt closing_pos = pos_dict [ 'close_pos' ] # change the closing price closing_pos . price = round ( close_pt [ 1 ], 9 ) # pack the outputs objects into dict exec_pos_dict [ 'opening_pos' ] = opening_pos exec_pos_dict [ 'closing_pos' ] = closing_pos return trade_open , trade_close def execute_positions ( self , trunc_dict : dict , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' #print(pos_dict.values(), type(pos_dict.values())) trade_open , trade_close = self . choose_positions ( trunc_dict , self . pos_dict , self . exec_pos_dict ) # Execute the open position if self . exec_pos_dict [ 'opening_pos' ] != None : self . exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . exec_pos_dict [ 'opening_pos' ]) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) # Execute the closing position if self . exec_pos_dict [ 'closing_pos' ] != None : #print(\"closing_pos_testest_Before\",closing_pos) #print(\"closing_pos_testest\",self.pos_dict['exit_pos']) ExecutePosition ( self . exec_pos_dict [ 'closing_pos' ]) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) ##print(\"closing_pos_testest_After\",closing_pos) #print(\"closing_pos_testest\",pos_dict['exit_pos']) self . store_to_position_pool ( key_dict = self . key_pos_dict , pos_dict = self . pos_dict , exec_pos_dict = self . exec_pos_dict ) return trade_open , trade_close , self . pos_dict , self . exec_pos_dict def execute_extra_positions ( self , trunc_dict : dict , extra_pos_type : str = \"Long\" ): # This method does not require entry because we already have something # Assume you already have some thing in the Portfolio and want to unload them # The function of execute_extra_positions is connected to execute_positions # If the conditions of execute_positions is triggered, and if auto_unload_all # is turned on, this function will unload if extra_pos_type == 'Long' : # For extra position, Long-Buy is omitted, this variable does not matter pos_type1 = 'Long-Buy' # Only Long-Sell is done to unload existing assets pos_type2 = 'Long-Sell' elif extra_pos_type == 'Short' : # For extra position in Short, the first action is to sell your # extra assets, thus it is a 'Long-Sell' pos_type1 = 'Long-Sell' # The second action is to Buyback. But because there is no debt # involved, it is a 'Long-Buy', instead of 'Short-Buyback'. # Alternatively, because this is autounload all, the second position is # irrelevant pos_type2 = 'Long-Buy' # # load all data from trunc_dict and choose opening_pos and closing_pos trade_open , trade_close = self . choose_positions ( trunc_dict , self . extra_pos_dict , self . extra_exec_pos_dict ) print ( \"pos_type1, pos_type2\" , pos_type1 , pos_type2 ) # For regular 'Long', the entry position is cancelled if extra_pos_type == 'Long' and \\ self . extra_exec_pos_dict [ 'opening_pos' ] != None : # cancel the open position self . extra_exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . extra_exec_pos_dict [ 'opening_pos' ]) . cancel_pos ( \\ void_time = trade_open [ 0 ]) elif extra_pos_type == 'Short' and \\ self . extra_exec_pos_dict [ 'opening_pos' ] != None : # Execute the open position self . extra_exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . extra_exec_pos_dict [ 'opening_pos' ]) . fill_pos ( \\ fill_time = trade_open [ 0 ], pos_type = pos_type1 ) # define the closing position and execute it if we set it to auto close if extra_pos_type == 'Long' and \\ self . extra_exec_pos_dict [ 'closing_pos' ] != None : # Execute the closing position ExecutePosition ( self . extra_exec_pos_dict [ 'closing_pos' ]) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) elif extra_pos_type == 'Short' and \\ self . extra_exec_pos_dict [ 'closing_pos' ] != None : # Execute the closing position ExecutePosition ( self . extra_exec_pos_dict [ 'closing_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) self . store_to_position_pool ( key_dict = self . extra_key_pos_dict , pos_dict = self . extra_pos_dict , exec_pos_dict = self . extra_exec_pos_dict ) return trade_open , trade_close , \\ self . extra_pos_dict , self . extra_exec_pos_dict def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_dict = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) if self . auto_unload_all == True : extra_quantity = self . _portfolio . _remainder_dict [ get_obj_name ] extra_pos_dict = self . open_positions ( give_obj_name , get_obj_name , extra_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . extra_pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_dict , exec_pos_dict = self . execute_positions ( trunc_dict , pos_type = pos_type ) if self . auto_unload_all == True : extra_trade_open , extra_trade_close , \\ extra_pos_dict , extra_exec_pos_dict = self . execute_extra_positions ( \\ trunc_dict , extra_pos_type = \\ pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_dict , exec_pos_dict choose_EES_values ( EES_dict ) staticmethod A method to find the appropiate EES values of the @day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters: EES_dict ( dict ) \u2013 A dictionary for all possible EES values. Returns: entry_pt ( tuple ) \u2013 The time and price of the entry moment. exit_pt ( tuple ) \u2013 The time and price of the exit moment. stop_pt ( tuple ) \u2013 The time and price of the stop loss moment. close_pt ( tuple ) \u2013 The time and price of the close hour exit moment. Source code in EC_tools/trade.py 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the @day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt execute_positions ( trunc_dict , pos_type = 'Long' ) A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters: trunc_dict ( dict ) \u2013 A truncation dictionary for all possible EES values. pos_dict ( dict ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type ( str , default: 'Long' ) \u2013 The type of position. The default is \"Long\". Returns: trade_open ( 2-elements tuple ) \u2013 The trade open time and price trade_close ( 2-elements tuple ) \u2013 The trade close time and price pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list ( list ) \u2013 The [opening_pos, closing_pos] . Source code in EC_tools/trade.py 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 def execute_positions ( self , trunc_dict : dict , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' #print(pos_dict.values(), type(pos_dict.values())) trade_open , trade_close = self . choose_positions ( trunc_dict , self . pos_dict , self . exec_pos_dict ) # Execute the open position if self . exec_pos_dict [ 'opening_pos' ] != None : self . exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . exec_pos_dict [ 'opening_pos' ]) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) # Execute the closing position if self . exec_pos_dict [ 'closing_pos' ] != None : #print(\"closing_pos_testest_Before\",closing_pos) #print(\"closing_pos_testest\",self.pos_dict['exit_pos']) ExecutePosition ( self . exec_pos_dict [ 'closing_pos' ]) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) ##print(\"closing_pos_testest_After\",closing_pos) #print(\"closing_pos_testest\",pos_dict['exit_pos']) self . store_to_position_pool ( key_dict = self . key_pos_dict , pos_dict = self . pos_dict , exec_pos_dict = self . exec_pos_dict ) return trade_open , trade_close , self . pos_dict , self . exec_pos_dict open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , pos_dict , size = 1 , fee = None , open_time = datetime . datetime . now ()) A method to open the entry, exit, stop, and close positions. Parameters: give_obj_name ( str ) \u2013 The name of the give object. get_obj_name ( str ) \u2013 The name of the get object. get_obj_quantity ( float ) \u2013 The quantity of the get object. EES_target_list ( list ) \u2013 A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type ( str ) \u2013 The type of position to be opened. Returns: pos_dict ( dict ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. Source code in EC_tools/trade.py 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , pos_dict : dict , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) # Store the positions in the position dictionary pos_dict pos_dict [ 'entry_pos' ] = entry_pos pos_dict [ 'exit_pos' ] = exit_pos pos_dict [ 'stop_pos' ] = stop_pos if self . close_exit_or_not == True : close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_dict [ 'close_pos' ] = close_pos return pos_dict run_trade ( trunc_dict , give_obj_name , get_obj_name , get_obj_quantity , target_entry , target_exit , stop_exit , open_hr = '0300' , close_hr = '2000' , direction = 'Buy' , fee = OIL_FUTURES_FEE , open_time = None ) Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters: trunc_dict ( dict ) \u2013 Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name ( str ) \u2013 The name of the give_obj, e.g. 'USD'. get_obj_name ( str ) \u2013 The name of the get_obj, e.g. 'CLc1'. get_obj_quantity ( int or float ) \u2013 The quanity of get_obj you wish to order. target_entry ( float ) \u2013 The target entry time and price. target_exit ( float ) \u2013 The exit entry time and price. stop_exit ( float ) \u2013 The stop loss time and price. open_hr ( str , default: '0300' ) \u2013 The opening hour of the trade close_hr ( str , default: '2000' ) \u2013 The closing hour of the trade direction ( str , default: 'Buy' ) \u2013 The default is \"Buy\" Returns: ( EES_dict , trade_open , trade_close , pos_list , exec_pos_list ) \u2013 Source code in EC_tools/trade.py 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_dict = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) if self . auto_unload_all == True : extra_quantity = self . _portfolio . _remainder_dict [ get_obj_name ] extra_pos_dict = self . open_positions ( give_obj_name , get_obj_name , extra_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . extra_pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_dict , exec_pos_dict = self . execute_positions ( trunc_dict , pos_type = pos_type ) if self . auto_unload_all == True : extra_trade_open , extra_trade_close , \\ extra_pos_dict , extra_exec_pos_dict = self . execute_extra_positions ( \\ trunc_dict , extra_pos_type = \\ pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_dict , exec_pos_dict Trade Bases: Protocol Parent class for all trading strategy. It controls the setting of a particular Trade class. Universal functions are written here. Source code in EC_tools/trade.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class Trade ( Protocol ): \"\"\" Parent class for all trading strategy. It controls the setting of a particular Trade class. Universal functions are written here. \"\"\" def __init__ ( self , portfolio : Portfolio , close_exit_or_not : bool = True , save_only_exec_pos : bool = False , auto_unload_all : bool = False ): self . _portfolio = portfolio self . _close_exit_or_not = close_exit_or_not self . _save_only_exec_pos = save_only_exec_pos self . _auto_unload_all = auto_unload_all @property def close_exit_or_not ( self ): return self . _close_exit_or_not @property def save_only_exec_pos ( self ): return self . _save_only_exec_pos @property def auto_unload_all ( self ): return self . _auto_unload_all @close_exit_or_not . setter def close_exit_or_not ( self , bool_val : bool ) -> None : self . _close_exit_or_not = bool_val @save_only_exec_pos . setter def save_only_exec_pos ( self , bool_val : bool ) -> None : self . _save_only_exec_pos = bool_val @auto_unload_all . setter def auto_unload_all ( self , bool_val : bool ): self . _auto_unload_all = bool_val def add_position ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : str , target_price : float , size : int = 1 , fee : int | float = None , pos_type : str = 'Long' , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ): \"\"\" A simple function that make the process of creating a position easier. It takes the name of the give_obj and get_obj, as well as the desired quantity of get_obj and target price, to create the Asset objects and Position object. The function automatically calculate how much give_obj you are going to spend to purchase it. It assume you have enough within your portfolio. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. target_price : float An initial target price for the position. It is subject to slight changes during the backtest. Returns ------- pos : Position object The trade opsition . \"\"\" get_obj_unit = ASSET_DICT [ get_obj_name ][ 'unit' ] get_obj_type = ASSET_DICT [ get_obj_name ][ 'asset_type' ] give_obj_unit = ASSET_DICT [ give_obj_name ][ 'unit' ] give_obj_type = ASSET_DICT [ give_obj_name ][ 'asset_type' ] # get_obj, asset get_obj = { 'name' : get_obj_name , 'quantity' : get_obj_quantity , 'unit' : get_obj_unit , 'asset_type' : get_obj_type , 'misc' : {}} # give_obj, cash give_obj = { 'name' : give_obj_name , 'quantity' : target_price * get_obj_quantity * size , 'unit' : give_obj_unit , 'asset_type' : give_obj_type , 'misc' :{}} #print(\"before add fee\", fee, get_obj_quantity) if type ( fee ) == dict : new_fee = fee . copy () new_fee [ 'quantity' ] = fee [ 'quantity' ] * get_obj_quantity elif fee == None : new_fee = None # Create a position pos = Position ( give_obj , get_obj , target_price , portfolio = self . _portfolio , size = size , fee = new_fee , pos_type = pos_type , open_time = open_time , pos_id = trade_id ) return pos add_position ( give_obj_name , get_obj_name , get_obj_quantity , target_price , size = 1 , fee = None , pos_type = 'Long' , open_time = datetime . datetime . now (), trade_id = 0 ) A simple function that make the process of creating a position easier. It takes the name of the give_obj and get_obj, as well as the desired quantity of get_obj and target price, to create the Asset objects and Position object. The function automatically calculate how much give_obj you are going to spend to purchase it. It assume you have enough within your portfolio. Parameters: give_obj_name ( str ) \u2013 The name of the give object. get_obj_name ( str ) \u2013 The name of the get object. get_obj_quantity ( float ) \u2013 The quantity of the get object. target_price ( float ) \u2013 An initial target price for the position. It is subject to slight changes during the backtest. Returns: pos ( Position object ) \u2013 The trade opsition . Source code in EC_tools/trade.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def add_position ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : str , target_price : float , size : int = 1 , fee : int | float = None , pos_type : str = 'Long' , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ): \"\"\" A simple function that make the process of creating a position easier. It takes the name of the give_obj and get_obj, as well as the desired quantity of get_obj and target price, to create the Asset objects and Position object. The function automatically calculate how much give_obj you are going to spend to purchase it. It assume you have enough within your portfolio. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. target_price : float An initial target price for the position. It is subject to slight changes during the backtest. Returns ------- pos : Position object The trade opsition . \"\"\" get_obj_unit = ASSET_DICT [ get_obj_name ][ 'unit' ] get_obj_type = ASSET_DICT [ get_obj_name ][ 'asset_type' ] give_obj_unit = ASSET_DICT [ give_obj_name ][ 'unit' ] give_obj_type = ASSET_DICT [ give_obj_name ][ 'asset_type' ] # get_obj, asset get_obj = { 'name' : get_obj_name , 'quantity' : get_obj_quantity , 'unit' : get_obj_unit , 'asset_type' : get_obj_type , 'misc' : {}} # give_obj, cash give_obj = { 'name' : give_obj_name , 'quantity' : target_price * get_obj_quantity * size , 'unit' : give_obj_unit , 'asset_type' : give_obj_type , 'misc' :{}} #print(\"before add fee\", fee, get_obj_quantity) if type ( fee ) == dict : new_fee = fee . copy () new_fee [ 'quantity' ] = fee [ 'quantity' ] * get_obj_quantity elif fee == None : new_fee = None # Create a position pos = Position ( give_obj , get_obj , target_price , portfolio = self . _portfolio , size = size , fee = new_fee , pos_type = pos_type , open_time = open_time , pos_id = trade_id ) return pos","title":"trade"},{"location":"EC_tools/trade/#trade","text":"Created on Fri May 10 00:16:28 2024 @author: dexter The Trade module contains relevant classes and functions that control trade actions, i.e., the trade decision logic. Trade class","title":"Trade"},{"location":"EC_tools/trade/#EC_tools.trade.BiDirectionalTrade","text":"Bases: Trade Bi-Directional Trade (Hedging position). The idea is to open two position, both Buy and Sell at trade-open given a set of entry and exit prices. If the price moves past the entry point of either direction, we fill the Buy/Sell order and enter the position. When the exit value is hit, we exit and close the position. The entry and exit range can be asymmetrical. User can manually input the range they want for either trades. At the moment, this method is limited to trading one Buy or Sell position per day, i.e., the maximum number of trades per day is one Buy plus one Sell. This method also assume the Buy and Sell action are independent from each other, that is, the two trade can be calculated and executed in parallel. Source code in EC_tools/trade.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 class BiDirectionalTrade ( Trade ): \"\"\" Bi-Directional Trade (Hedging position). The idea is to open two position, both Buy and Sell at trade-open given a set of entry and exit prices. If the price moves past the entry point of either direction, we fill the Buy/Sell order and enter the position. When the exit value is hit, we exit and close the position. The entry and exit range can be asymmetrical. User can manually input the range they want for either trades. At the moment, this method is limited to trading one Buy or Sell position per day, i.e., the maximum number of trades per day is one Buy plus one Sell. This method also assume the Buy and Sell action are independent from each other, that is, the two trade can be calculated and executed in parallel. \"\"\" def __init__ ( self , portfolio ): super () . __init__ ( portfolio ) @staticmethod def choose_EES_values ( self , trunc_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" Same method as OneTradePerDay \"\"\" #print(self.portfolio) return OneTradePerDay ( self . _portfolio ) . choose_EES_values ( trunc_dict ) def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ) \\ -> list [ Position ]: \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , size , fee , open_time , trade_id ) def execute_positions ( self , EES_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . execute_positions ( EES_dict , pos_list , pos_type ) def run_trade ( self , day : pd . DataFrame , give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], target_exit : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], stop_exit : dict [ str , float ], open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None , trade_id : int = 0 ) -> \\ tuple [ dict , tuple , tuple , list , list ]: \"\"\" This method only look into the data points that crosses the threashold. Thus it is fast but it only perform simple testing. Comprehesive dynamic testing requires other functions Parameters ---------- EES_dict : dict A dictionary for all possible EES values. This assume you are running a crossover loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : dict The target entry price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions target_exit : dict The target exit price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions stop_exit : dict The stop loss price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" target_entry_buy = target_entry [ 'Buy' ] target_exit_buy = target_exit [ 'Buy' ] stop_exit_buy = stop_exit [ 'Buy' ] target_entry_sell = target_entry [ 'Sell' ] target_exit_sell = target_exit [ 'Sell' ] stop_exit_sell = stop_exit [ 'Sell' ] #Find the minute that the price crosses the EES values EES_dict_buy = read . find_minute_EES ( day , target_entry_buy , target_exit_buy , stop_exit_buy , open_hr = open_hr , close_hr = close_hr , direction = 'Buy' ) EES_dict_sell = read . find_minute_EES ( day , target_entry_sell , target_exit_sell , stop_exit_sell , open_hr = open_hr , close_hr = close_hr , direction = 'Sell' ) EES_buy_target_list = [ target_entry_buy , target_exit_buy , stop_exit_buy , EES_dict_buy [ 'close' ][ 1 ]] EES_sell_target_list = [ target_entry_sell , target_exit_sell , stop_exit_sell , EES_dict_sell [ 'close' ][ 1 ]] # Note that the trading for Buy and Sell directions are executed # independently (in Parallel). Therefore, the resulting Portfolio # pool and position pool are not going to be sorted perfectly by # entry time. trade_id_buy = 'Buy' + str ( trade_id ) trade_id_sell = 'Sell' + str ( trade_id ) # Buy pos_list_buy = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_buy_target_list , \\ pos_type = 'Long' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_buy ) trade_open_buy , trade_close_buy , \\ pos_list_buy , exec_pos_list_buy = self . execute_positions ( EES_dict_buy , pos_list_buy , pos_type = 'Long' ) # Sell pos_list_sell = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_sell_target_list , \\ pos_type = 'Short' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_sell ) trade_open_sell , trade_close_sell , \\ pos_list_sell , exec_pos_list_sell = self . execute_positions ( EES_dict_sell , pos_list_sell , pos_type = 'Short' ) # Now Bundle all the data together EES_dict , \\ trade_open , trade_close , \\ pos_dict , exec_pos_dict = dict (), dict (), dict (), dict (), dict () EES_dict [ 'Buy' ], EES_dict [ 'Sell' ] = EES_dict_buy , EES_dict_sell trade_open [ 'Buy' ], trade_open [ 'Sell' ] = trade_open_buy , trade_open_sell trade_close [ 'Buy' ], trade_close [ 'Sell' ] = trade_close_buy , trade_close_sell pos_dict [ 'Buy' ], pos_dict [ 'Sell' ] = pos_list_buy , pos_list_sell exec_pos_dict [ 'Buy' ], exec_pos_dict [ 'Sell' ] = exec_pos_list_buy , exec_pos_list_sell return EES_dict , trade_open , trade_close , pos_dict , exec_pos_dict","title":"BiDirectionalTrade"},{"location":"EC_tools/trade/#EC_tools.trade.BiDirectionalTrade.choose_EES_values","text":"Same method as OneTradePerDay Source code in EC_tools/trade.py 556 557 558 559 560 561 562 563 564 @staticmethod def choose_EES_values ( self , trunc_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" Same method as OneTradePerDay \"\"\" #print(self.portfolio) return OneTradePerDay ( self . _portfolio ) . choose_EES_values ( trunc_dict )","title":"choose_EES_values"},{"location":"EC_tools/trade/#EC_tools.trade.BiDirectionalTrade.execute_positions","text":"Same method as OneTradePerDay Source code in EC_tools/trade.py 589 590 591 592 593 594 595 596 597 598 599 def execute_positions ( self , EES_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . execute_positions ( EES_dict , pos_list , pos_type )","title":"execute_positions"},{"location":"EC_tools/trade/#EC_tools.trade.BiDirectionalTrade.open_positions","text":"Same method as OneTradePerDay Source code in EC_tools/trade.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ) \\ -> list [ Position ]: \"\"\" Same method as OneTradePerDay \"\"\" return OneTradePerDay ( self . _portfolio ) . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type , size , fee , open_time , trade_id )","title":"open_positions"},{"location":"EC_tools/trade/#EC_tools.trade.BiDirectionalTrade.run_trade","text":"This method only look into the data points that crosses the threashold. Thus it is fast but it only perform simple testing. Comprehesive dynamic testing requires other functions Parameters: EES_dict ( dict ) \u2013 A dictionary for all possible EES values. This assume you are running a crossover loop. give_obj_name ( str ) \u2013 The name of the give_obj, e.g. 'USD'. get_obj_name ( str ) \u2013 The name of the get_obj, e.g. 'CLc1'. get_obj_quantity ( int or float ) \u2013 The quanity of get_obj you wish to order. target_entry ( dict ) \u2013 The target entry price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions target_exit ( dict ) \u2013 The target exit price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions stop_exit ( dict ) \u2013 The stop loss price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions open_hr ( str , default: '0300' ) \u2013 The opening hour of the trade close_hr ( str , default: '2000' ) \u2013 The closing hour of the trade direction ( str , default: 'Buy' ) \u2013 The default is \"Buy\" Returns: ( EES_dict , trade_open , trade_close , pos_list , exec_pos_list ) \u2013 Source code in EC_tools/trade.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 def run_trade ( self , day : pd . DataFrame , give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], target_exit : dict [ str , float ] | \\ dict [ str , list [ float ] | \\ tuple [ float ]], stop_exit : dict [ str , float ], open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None , trade_id : int = 0 ) -> \\ tuple [ dict , tuple , tuple , list , list ]: \"\"\" This method only look into the data points that crosses the threashold. Thus it is fast but it only perform simple testing. Comprehesive dynamic testing requires other functions Parameters ---------- EES_dict : dict A dictionary for all possible EES values. This assume you are running a crossover loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : dict The target entry price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions target_exit : dict The target exit price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions stop_exit : dict The stop loss price in the form of dict. The keys are \"Buy\" and \"Sell\" to indicating the prices for the two directions open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" target_entry_buy = target_entry [ 'Buy' ] target_exit_buy = target_exit [ 'Buy' ] stop_exit_buy = stop_exit [ 'Buy' ] target_entry_sell = target_entry [ 'Sell' ] target_exit_sell = target_exit [ 'Sell' ] stop_exit_sell = stop_exit [ 'Sell' ] #Find the minute that the price crosses the EES values EES_dict_buy = read . find_minute_EES ( day , target_entry_buy , target_exit_buy , stop_exit_buy , open_hr = open_hr , close_hr = close_hr , direction = 'Buy' ) EES_dict_sell = read . find_minute_EES ( day , target_entry_sell , target_exit_sell , stop_exit_sell , open_hr = open_hr , close_hr = close_hr , direction = 'Sell' ) EES_buy_target_list = [ target_entry_buy , target_exit_buy , stop_exit_buy , EES_dict_buy [ 'close' ][ 1 ]] EES_sell_target_list = [ target_entry_sell , target_exit_sell , stop_exit_sell , EES_dict_sell [ 'close' ][ 1 ]] # Note that the trading for Buy and Sell directions are executed # independently (in Parallel). Therefore, the resulting Portfolio # pool and position pool are not going to be sorted perfectly by # entry time. trade_id_buy = 'Buy' + str ( trade_id ) trade_id_sell = 'Sell' + str ( trade_id ) # Buy pos_list_buy = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_buy_target_list , \\ pos_type = 'Long' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_buy ) trade_open_buy , trade_close_buy , \\ pos_list_buy , exec_pos_list_buy = self . execute_positions ( EES_dict_buy , pos_list_buy , pos_type = 'Long' ) # Sell pos_list_sell = self . open_positions ( give_obj_name , get_obj_name , \\ get_obj_quantity , EES_sell_target_list , \\ pos_type = 'Short' , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time , trade_id = trade_id_sell ) trade_open_sell , trade_close_sell , \\ pos_list_sell , exec_pos_list_sell = self . execute_positions ( EES_dict_sell , pos_list_sell , pos_type = 'Short' ) # Now Bundle all the data together EES_dict , \\ trade_open , trade_close , \\ pos_dict , exec_pos_dict = dict (), dict (), dict (), dict (), dict () EES_dict [ 'Buy' ], EES_dict [ 'Sell' ] = EES_dict_buy , EES_dict_sell trade_open [ 'Buy' ], trade_open [ 'Sell' ] = trade_open_buy , trade_open_sell trade_close [ 'Buy' ], trade_close [ 'Sell' ] = trade_close_buy , trade_close_sell pos_dict [ 'Buy' ], pos_dict [ 'Sell' ] = pos_list_buy , pos_list_sell exec_pos_dict [ 'Buy' ], exec_pos_dict [ 'Sell' ] = exec_pos_list_buy , exec_pos_list_sell return EES_dict , trade_open , trade_close , pos_dict , exec_pos_dict","title":"run_trade"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay","text":"Bases: Trade A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. Source code in EC_tools/trade.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 class OneTradePerDay ( Trade ): \"\"\" A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. \"\"\" def __init__ ( self , portfolio , trade_id : int = 0 ): super () . __init__ ( portfolio ) self . trade_id = trade_id @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"pos_list\", pos_list) return pos_list def execute_positions ( self , trunc_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # Unpack inputs entry_pos , exit_pos , stop_pos , close_pos = pos_list [ 0 ], pos_list [ 1 ], \\ pos_list [ 2 ], pos_list [ 3 ] # Search for the appropiate time for entry, exit, stop loss, # and close time for the trade entry_pt , exit_pt , stop_pt , close_pt = self . choose_EES_values ( trunc_dict ) # initialise trade_open and trade_close time and prices trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) opening_pos , closing_pos = None , None # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] # Run diagnosis to decide which outcome it is for the day # Case 1: No trade because entry is not hit if entry_pt == ( np . nan , np . nan ): #print(\"No trade.\") # Cancel all order positions ExecutePosition ( entry_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( stop_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) return trade_open , trade_close , pos_list , exec_pos_list # Case 2: An exit is hit, normal exit elif entry_pt and exit_pt != ( np . nan , np . nan ): #print(\"Noraml exit.\") trade_open , trade_close = entry_pt , exit_pt opening_pos , closing_pos = entry_pos , exit_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( exit_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 3: stop loss elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): #print('Stop loss.') trade_open , trade_close = entry_pt , stop_pt opening_pos , closing_pos = entry_pos , stop_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( stop_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 4: Neither an exit or stop loss is hit, exit position at close time elif exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print(\"Sell at close.\") trade_open , trade_close = entry_pt , close_pt opening_pos , closing_pos = entry_pos , close_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( close_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # change the price for the open position opening_pos . price = entry_pt [ 1 ] #print('entry_pt[1]', entry_pt[1]) #print('exit_pt[1]', exit_pt[1]) #print('stop_pt[1]', stop_pt[1]) #print('close_pt[1]', close_pt[1]) #print(\"After price adjustment\", opening_pos, closing_pos) # Execute the positions ExecutePosition ( opening_pos ) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) ExecutePosition ( closing_pos ) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"exec_pos_list\", exec_pos_list) for pos in pos_list : # Add position in the position book self . _portfolio . _position_pool . append ( copy . copy ( pos )) return trade_open , trade_close , pos_list , exec_pos_list def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_list = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) #trade_id= self.trade_id) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_list , exec_pos_list = self . execute_positions ( trunc_dict , pos_list , pos_type = pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_list , exec_pos_list","title":"OneTradePerDay"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay.choose_EES_values","text":"A method to find the appropiate EES values of the day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters: EES_dict ( dict ) \u2013 A dictionary for all possible EES values. Returns: entry_pt ( tuple ) \u2013 The time and price of the entry moment. exit_pt ( tuple ) \u2013 The time and price of the exit moment. stop_pt ( tuple ) \u2013 The time and price of the stop loss moment. close_pt ( tuple ) \u2013 The time and price of the close hour exit moment. Source code in EC_tools/trade.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt","title":"choose_EES_values"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay.execute_positions","text":"A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters: trunc_dict ( dict ) \u2013 A truncation dictionary for all possible EES values. pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type ( str , default: 'Long' ) \u2013 The type of position. The default is \"Long\". Returns: trade_open ( 2-elements tuple ) \u2013 The trade open time and price trade_close ( 2-elements tuple ) \u2013 The trade close time and price pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list ( list ) \u2013 The [opening_pos, closing_pos] . Source code in EC_tools/trade.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 def execute_positions ( self , trunc_dict : dict , pos_list : list , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # Unpack inputs entry_pos , exit_pos , stop_pos , close_pos = pos_list [ 0 ], pos_list [ 1 ], \\ pos_list [ 2 ], pos_list [ 3 ] # Search for the appropiate time for entry, exit, stop loss, # and close time for the trade entry_pt , exit_pt , stop_pt , close_pt = self . choose_EES_values ( trunc_dict ) # initialise trade_open and trade_close time and prices trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) opening_pos , closing_pos = None , None # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] # Run diagnosis to decide which outcome it is for the day # Case 1: No trade because entry is not hit if entry_pt == ( np . nan , np . nan ): #print(\"No trade.\") # Cancel all order positions ExecutePosition ( entry_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( stop_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = close_pt [ 0 ]) return trade_open , trade_close , pos_list , exec_pos_list # Case 2: An exit is hit, normal exit elif entry_pt and exit_pt != ( np . nan , np . nan ): #print(\"Noraml exit.\") trade_open , trade_close = entry_pt , exit_pt opening_pos , closing_pos = entry_pos , exit_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( exit_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 3: stop loss elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): #print('Stop loss.') trade_open , trade_close = entry_pt , stop_pt opening_pos , closing_pos = entry_pos , stop_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( stop_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( close_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 4: Neither an exit or stop loss is hit, exit position at close time elif exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print(\"Sell at close.\") trade_open , trade_close = entry_pt , close_pt opening_pos , closing_pos = entry_pos , close_pos #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( close_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( stop_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( exit_pos ) . cancel_pos ( void_time = trade_close [ 0 ]) # change the price for the open position opening_pos . price = entry_pt [ 1 ] #print('entry_pt[1]', entry_pt[1]) #print('exit_pt[1]', exit_pt[1]) #print('stop_pt[1]', stop_pt[1]) #print('close_pt[1]', close_pt[1]) #print(\"After price adjustment\", opening_pos, closing_pos) # Execute the positions ExecutePosition ( opening_pos ) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) ExecutePosition ( closing_pos ) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) # pack the outputs objects into lists exec_pos_list = [ opening_pos , closing_pos ] pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"exec_pos_list\", exec_pos_list) for pos in pos_list : # Add position in the position book self . _portfolio . _position_pool . append ( copy . copy ( pos )) return trade_open , trade_close , pos_list , exec_pos_list","title":"execute_positions"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay.open_positions","text":"A method to open the entry, exit, stop, and close positions. Parameters: give_obj_name ( str ) \u2013 The name of the give object. get_obj_name ( str ) \u2013 The name of the get object. get_obj_quantity ( float ) \u2013 The quantity of the get object. EES_target_list ( list ) \u2013 A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type ( str ) \u2013 The type of position to be opened. Returns: pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. Source code in EC_tools/trade.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_list = [ entry_pos , exit_pos , stop_pos , close_pos ] #print(\"pos_list\", pos_list) return pos_list","title":"open_positions"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay.run_trade","text":"Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters: trunc_dict ( dict ) \u2013 Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name ( str ) \u2013 The name of the give_obj, e.g. 'USD'. get_obj_name ( str ) \u2013 The name of the get_obj, e.g. 'CLc1'. get_obj_quantity ( int or float ) \u2013 The quanity of get_obj you wish to order. target_entry ( float ) \u2013 The target entry time and price. target_exit ( float ) \u2013 The exit entry time and price. stop_exit ( float ) \u2013 The stop loss time and price. open_hr ( str , default: '0300' ) \u2013 The opening hour of the trade close_hr ( str , default: '2000' ) \u2013 The closing hour of the trade direction ( str , default: 'Buy' ) \u2013 The default is \"Buy\" Returns: ( EES_dict , trade_open , trade_close , pos_list , exec_pos_list ) \u2013 Source code in EC_tools/trade.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_list = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) #trade_id= self.trade_id) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_list , exec_pos_list = self . execute_positions ( trunc_dict , pos_list , pos_type = pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_list , exec_pos_list","title":"run_trade"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay_2","text":"Bases: Trade A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. Source code in EC_tools/trade.py 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 class OneTradePerDay_2 ( Trade ): \"\"\" A class that perform one trade per day, the simplest form of trading. Four possible outcomes: 1) Find the earliest entry point in the price action chart, 2) exit the position as soon as the price it the target entry. 3) If the price hit the stop loss first, exit at stop loass. 4) If netiher the target exit nor the stop loss is hit, exit the trade at the closing hour. \"\"\" def __init__ ( self , portfolio : Portfolio , trade_id : int = 0 ): super () . __init__ ( portfolio ) self . trade_id = trade_id self . pos_dict = dict () self . exec_pos_dict = dict () self . extra_pos_dict = dict () self . extra_exec_pos_dict = dict () self . key_pos_dict = None self . extra_key_pos_dict = None self . EES_type = None self . EES_para_num = 1 def store_to_position_pool ( self , key_dict : dict , pos_dict : dict , exec_pos_dict : dict ) -> None : # Choose whether to save all positions or just to filled ones. if self . save_only_exec_pos : key_dict = exec_pos_dict else : key_dict = pos_dict # Add position in the position book for pos in list ( key_dict . values ()): self . _portfolio . _position_pool . append ( copy . copy ( pos )) @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the @day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , pos_dict : dict , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) # Store the positions in the position dictionary pos_dict pos_dict [ 'entry_pos' ] = entry_pos pos_dict [ 'exit_pos' ] = exit_pos pos_dict [ 'stop_pos' ] = stop_pos if self . close_exit_or_not == True : close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_dict [ 'close_pos' ] = close_pos return pos_dict def choose_positions ( self , trunc_dict : dict , pos_dict : dict , exec_pos_dict : dict ): print ( \"choose_positions\" ) # Search for the appropiate time for entry, exit, stop loss, # and close time for the trade entry_pt , exit_pt , stop_pt , close_pt = self . choose_EES_values ( trunc_dict ) # initialise trade_open and trade_close time and prices trade_open , trade_close = ( np . nan , np . nan ), ( np . nan , np . nan ) opening_pos , closing_pos = None , None # pack the outputs objects into dict exec_pos_dict [ 'opening_pos' ] = opening_pos exec_pos_dict [ 'closing_pos' ] = closing_pos # Run diagnosis to decide which outcome it is for the day # Case 1: No trade because entry is not hit if entry_pt == ( np . nan , np . nan ): #print(\"No trade.\") # Cancel all order positions in a loop for pos in list ( pos_dict . values ()): ExecutePosition ( pos ) . cancel_pos ( void_time = close_pt [ 0 ]) return trade_open , trade_close # Case 2: An exit is hit, normal exit elif entry_pt and exit_pt != ( np . nan , np . nan ): #print(\"Noraml exit.\") trade_open , trade_close = entry_pt , exit_pt opening_pos , closing_pos = pos_dict [ 'entry_pos' ], pos_dict [ 'exit_pos' ] # change the closing price closing_pos . price = round ( exit_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( pos_dict [ 'stop_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) if self . close_exit_or_not : ExecutePosition ( pos_dict [ 'close_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 3: stop loss elif exit_pt == ( np . nan , np . nan ) and stop_pt != ( np . nan , np . nan ): #print('Stop loss.') trade_open , trade_close = entry_pt , stop_pt opening_pos , closing_pos = pos_dict [ 'entry_pos' ], pos_dict [ 'stop_pos' ] #print(\"Before price adjustment\", opening_pos, closing_pos) # change the closing price closing_pos . price = round ( stop_pt [ 1 ], 9 ) # Cancel all order positions ExecutePosition ( pos_dict [ 'exit_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) if self . close_exit_or_not : ExecutePosition ( pos_dict [ 'close_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) # Case 4: Neither an exit or stop loss is hit, exit position at close time elif exit_pt == ( np . nan , np . nan ) and stop_pt == ( np . nan , np . nan ): #print(\"Sell at close.\") trade_open = entry_pt opening_pos = pos_dict [ 'entry_pos' ] #print(\"Before price adjustment\", opening_pos, closing_pos) # Cancel all order positions ExecutePosition ( pos_dict [ 'stop_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) ExecutePosition ( pos_dict [ 'exit_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) if self . close_exit_or_not : trade_close = close_pt closing_pos = pos_dict [ 'close_pos' ] # change the closing price closing_pos . price = round ( close_pt [ 1 ], 9 ) # pack the outputs objects into dict exec_pos_dict [ 'opening_pos' ] = opening_pos exec_pos_dict [ 'closing_pos' ] = closing_pos return trade_open , trade_close def execute_positions ( self , trunc_dict : dict , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' #print(pos_dict.values(), type(pos_dict.values())) trade_open , trade_close = self . choose_positions ( trunc_dict , self . pos_dict , self . exec_pos_dict ) # Execute the open position if self . exec_pos_dict [ 'opening_pos' ] != None : self . exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . exec_pos_dict [ 'opening_pos' ]) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) # Execute the closing position if self . exec_pos_dict [ 'closing_pos' ] != None : #print(\"closing_pos_testest_Before\",closing_pos) #print(\"closing_pos_testest\",self.pos_dict['exit_pos']) ExecutePosition ( self . exec_pos_dict [ 'closing_pos' ]) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) ##print(\"closing_pos_testest_After\",closing_pos) #print(\"closing_pos_testest\",pos_dict['exit_pos']) self . store_to_position_pool ( key_dict = self . key_pos_dict , pos_dict = self . pos_dict , exec_pos_dict = self . exec_pos_dict ) return trade_open , trade_close , self . pos_dict , self . exec_pos_dict def execute_extra_positions ( self , trunc_dict : dict , extra_pos_type : str = \"Long\" ): # This method does not require entry because we already have something # Assume you already have some thing in the Portfolio and want to unload them # The function of execute_extra_positions is connected to execute_positions # If the conditions of execute_positions is triggered, and if auto_unload_all # is turned on, this function will unload if extra_pos_type == 'Long' : # For extra position, Long-Buy is omitted, this variable does not matter pos_type1 = 'Long-Buy' # Only Long-Sell is done to unload existing assets pos_type2 = 'Long-Sell' elif extra_pos_type == 'Short' : # For extra position in Short, the first action is to sell your # extra assets, thus it is a 'Long-Sell' pos_type1 = 'Long-Sell' # The second action is to Buyback. But because there is no debt # involved, it is a 'Long-Buy', instead of 'Short-Buyback'. # Alternatively, because this is autounload all, the second position is # irrelevant pos_type2 = 'Long-Buy' # # load all data from trunc_dict and choose opening_pos and closing_pos trade_open , trade_close = self . choose_positions ( trunc_dict , self . extra_pos_dict , self . extra_exec_pos_dict ) print ( \"pos_type1, pos_type2\" , pos_type1 , pos_type2 ) # For regular 'Long', the entry position is cancelled if extra_pos_type == 'Long' and \\ self . extra_exec_pos_dict [ 'opening_pos' ] != None : # cancel the open position self . extra_exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . extra_exec_pos_dict [ 'opening_pos' ]) . cancel_pos ( \\ void_time = trade_open [ 0 ]) elif extra_pos_type == 'Short' and \\ self . extra_exec_pos_dict [ 'opening_pos' ] != None : # Execute the open position self . extra_exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . extra_exec_pos_dict [ 'opening_pos' ]) . fill_pos ( \\ fill_time = trade_open [ 0 ], pos_type = pos_type1 ) # define the closing position and execute it if we set it to auto close if extra_pos_type == 'Long' and \\ self . extra_exec_pos_dict [ 'closing_pos' ] != None : # Execute the closing position ExecutePosition ( self . extra_exec_pos_dict [ 'closing_pos' ]) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) elif extra_pos_type == 'Short' and \\ self . extra_exec_pos_dict [ 'closing_pos' ] != None : # Execute the closing position ExecutePosition ( self . extra_exec_pos_dict [ 'closing_pos' ]) . cancel_pos ( void_time = trade_close [ 0 ]) self . store_to_position_pool ( key_dict = self . extra_key_pos_dict , pos_dict = self . extra_pos_dict , exec_pos_dict = self . extra_exec_pos_dict ) return trade_open , trade_close , \\ self . extra_pos_dict , self . extra_exec_pos_dict def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_dict = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) if self . auto_unload_all == True : extra_quantity = self . _portfolio . _remainder_dict [ get_obj_name ] extra_pos_dict = self . open_positions ( give_obj_name , get_obj_name , extra_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . extra_pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_dict , exec_pos_dict = self . execute_positions ( trunc_dict , pos_type = pos_type ) if self . auto_unload_all == True : extra_trade_open , extra_trade_close , \\ extra_pos_dict , extra_exec_pos_dict = self . execute_extra_positions ( \\ trunc_dict , extra_pos_type = \\ pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_dict , exec_pos_dict","title":"OneTradePerDay_2"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay_2.choose_EES_values","text":"A method to find the appropiate EES values of the @day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters: EES_dict ( dict ) \u2013 A dictionary for all possible EES values. Returns: entry_pt ( tuple ) \u2013 The time and price of the entry moment. exit_pt ( tuple ) \u2013 The time and price of the exit moment. stop_pt ( tuple ) \u2013 The time and price of the stop loss moment. close_pt ( tuple ) \u2013 The time and price of the close hour exit moment. Source code in EC_tools/trade.py 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 @staticmethod def choose_EES_values ( EES_dict : dict ) -> tuple [ tuple , tuple , tuple , tuple ]: \"\"\" A method to find the appropiate EES values of the @day. In the case of one trade per day, we only search for the earliest exit and stop loss price after entry price was hit. You may supply either a EES_dict from Parameters ---------- EES_dict : dict A dictionary for all possible EES values. Returns ------- entry_pt : tuple The time and price of the entry moment. exit_pt : tuple The time and price of the exit moment. stop_pt : tuple The time and price of the stop loss moment. close_pt : tuple The time and price of the close hour exit moment. \"\"\" # A method that search for correct EES points from a EES_dict # initialise entry_pt , exit_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) stop_pt , close_pt = ( np . nan , np . nan ), ( np . nan , np . nan ) earliest_exit , earliest_stop = exit_pt , stop_pt # closr_pt always exist so we do it outside of the switch cases close_pt = EES_dict [ 'close' ] # To get the correct EES and close time and price if len ( EES_dict [ 'entry' ]) == 0 : # entry price not hit. No trade that day. pass else : # choose the entry point entry_pt = EES_dict [ 'entry' ][ 0 ] if len ( EES_dict [ 'exit' ]) > 0 : # Find exit point candidates for i , exit_cand in enumerate ( EES_dict [ 'exit' ]): if exit_cand [ 0 ] > entry_pt [ 0 ]: earliest_exit = exit_cand #print('earliest_exit', earliest_exit) break if len ( EES_dict [ 'stop' ]) > 0 : # Finde stop loss point candidates for i , stop_cand in enumerate ( EES_dict [ 'stop' ]): if stop_cand [ 0 ] > entry_pt [ 0 ]: earliest_stop = stop_cand #print('earliest_stop', earliest_stop) break # put in the new exit and stop exit_pt = earliest_exit stop_pt = earliest_stop return entry_pt , exit_pt , stop_pt , close_pt","title":"choose_EES_values"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay_2.execute_positions","text":"A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters: trunc_dict ( dict ) \u2013 A truncation dictionary for all possible EES values. pos_dict ( dict ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type ( str , default: 'Long' ) \u2013 The type of position. The default is \"Long\". Returns: trade_open ( 2-elements tuple ) \u2013 The trade open time and price trade_close ( 2-elements tuple ) \u2013 The trade close time and price pos_list ( list ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list ( list ) \u2013 The [opening_pos, closing_pos] . Source code in EC_tools/trade.py 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 def execute_positions ( self , trunc_dict : dict , pos_type : str = \"Long\" ): \"\"\" A method that execute the a list posiiton given a EES_dict. It search the EES_dict the find the appropiate entry, exit, stop loss, and close time for the trade. Parameters ---------- trunc_dict : dict A truncation dictionary for all possible EES values. pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. pos_type : str, optional The type of position. The default is \"Long\". Returns ------- trade_open : 2-elements tuple The trade open time and price trade_close : 2-elements tuple The trade close time and price pos_list : list The position list: [entry_pos, exit_pos, stop_pos, close_pos]. exec_pos_list : list The [opening_pos, closing_pos] . \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' #print(pos_dict.values(), type(pos_dict.values())) trade_open , trade_close = self . choose_positions ( trunc_dict , self . pos_dict , self . exec_pos_dict ) # Execute the open position if self . exec_pos_dict [ 'opening_pos' ] != None : self . exec_pos_dict [ 'opening_pos' ] . price = trade_open [ 1 ] ExecutePosition ( self . exec_pos_dict [ 'opening_pos' ]) . fill_pos ( fill_time = trade_open [ 0 ], pos_type = pos_type1 ) # Execute the closing position if self . exec_pos_dict [ 'closing_pos' ] != None : #print(\"closing_pos_testest_Before\",closing_pos) #print(\"closing_pos_testest\",self.pos_dict['exit_pos']) ExecutePosition ( self . exec_pos_dict [ 'closing_pos' ]) . fill_pos ( fill_time = trade_close [ 0 ], pos_type = pos_type2 ) ##print(\"closing_pos_testest_After\",closing_pos) #print(\"closing_pos_testest\",pos_dict['exit_pos']) self . store_to_position_pool ( key_dict = self . key_pos_dict , pos_dict = self . pos_dict , exec_pos_dict = self . exec_pos_dict ) return trade_open , trade_close , self . pos_dict , self . exec_pos_dict","title":"execute_positions"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay_2.open_positions","text":"A method to open the entry, exit, stop, and close positions. Parameters: give_obj_name ( str ) \u2013 The name of the give object. get_obj_name ( str ) \u2013 The name of the get object. get_obj_quantity ( float ) \u2013 The quantity of the get object. EES_target_list ( list ) \u2013 A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type ( str ) \u2013 The type of position to be opened. Returns: pos_dict ( dict ) \u2013 The position list: [entry_pos, exit_pos, stop_pos, close_pos]. Source code in EC_tools/trade.py 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 def open_positions ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : int | float , EES_target_list : list , pos_type : str , pos_dict : dict , size : int | float = 1 , fee : dict = None , open_time : datetime . datetime = datetime . datetime . now ()) \\ -> list [ Position ]: \"\"\" A method to open the entry, exit, stop, and close positions. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. EES_target_list : list A list of target EES values [entry_price, exit_price, stop_price, close_price]. pos_type : str The type of position to be opened. Returns ------- pos_dict : dict The position list: [entry_pos, exit_pos, stop_pos, close_pos]. \"\"\" if pos_type == 'Long' : pos_type1 = 'Long-Buy' pos_type2 = 'Long-Sell' elif pos_type == 'Short' : pos_type1 = 'Short-Borrow' pos_type2 = 'Short-Buyback' # a method that execute the one trade per day based on the cases of the EES entry_price , exit_price = EES_target_list [ 0 ], EES_target_list [ 1 ] stop_price , close_price = EES_target_list [ 2 ], EES_target_list [ 3 ] #### Collapse all these into an add_position function # Make positions for initial price estimation entry_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , entry_price , size = size , fee = None , pos_type = pos_type1 , open_time = open_time , trade_id = self . trade_id ) exit_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , exit_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) stop_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , stop_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) # Store the positions in the position dictionary pos_dict pos_dict [ 'entry_pos' ] = entry_pos pos_dict [ 'exit_pos' ] = exit_pos pos_dict [ 'stop_pos' ] = stop_pos if self . close_exit_or_not == True : close_pos = super () . add_position ( give_obj_name , get_obj_name , get_obj_quantity , close_price , size = size , fee = fee , pos_type = pos_type2 , open_time = open_time , trade_id = self . trade_id ) pos_dict [ 'close_pos' ] = close_pos return pos_dict","title":"open_positions"},{"location":"EC_tools/trade/#EC_tools.trade.OneTradePerDay_2.run_trade","text":"Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters: trunc_dict ( dict ) \u2013 Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name ( str ) \u2013 The name of the give_obj, e.g. 'USD'. get_obj_name ( str ) \u2013 The name of the get_obj, e.g. 'CLc1'. get_obj_quantity ( int or float ) \u2013 The quanity of get_obj you wish to order. target_entry ( float ) \u2013 The target entry time and price. target_exit ( float ) \u2013 The exit entry time and price. stop_exit ( float ) \u2013 The stop loss time and price. open_hr ( str , default: '0300' ) \u2013 The opening hour of the trade close_hr ( str , default: '2000' ) \u2013 The closing hour of the trade direction ( str , default: 'Buy' ) \u2013 The default is \"Buy\" Returns: ( EES_dict , trade_open , trade_close , pos_list , exec_pos_list ) \u2013 Source code in EC_tools/trade.py 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 def run_trade ( self , trunc_dict : dict , #day: pd.DataFrame, give_obj_name : str , get_obj_name : str , get_obj_quantity : float | int , target_entry : float , target_exit : float , stop_exit : float , open_hr : str = \"0300\" , close_hr : str = \"2000\" , direction : str = \"Buy\" , fee : dict = OIL_FUTURES_FEE , open_time : datetime . datetime = None ) -> \\ tuple [ tuple , tuple , list , list ]: \"\"\" Note that run_trade method is agnoistic to the loop type, i.e., You can use LoopType.CROSSOVER, LoopType.RANGE, or LoopType.FULL Parameters ---------- trunc_dict : dict Truncation dictionary. It contains the relevant points selected by some given EES values or EES ranges. This assume you are running a crossover or range loop. give_obj_name : str The name of the give_obj, e.g. 'USD'. get_obj_name : str The name of the get_obj, e.g. 'CLc1'. get_obj_quantity : int or float The quanity of get_obj you wish to order. target_entry : float The target entry time and price. target_exit : float The exit entry time and price. stop_exit : float The stop loss time and price. open_hr : str The opening hour of the trade close_hr : str The closing hour of the trade direction : str The default is \"Buy\" Returns ------- EES_dict, trade_open, trade_close, pos_list, exec_pos_list \"\"\" #Find the minute that the price crosses the EES values # Input the position type if direction == 'Buy' : pos_type = 'Long' elif direction == 'Sell' : pos_type = 'Short' # Note that this is not the EES_dict object from find_minute_EES. # This is just an initial estimation of the EES values for the # open_position function in the begining of the day. As the positions # are executed, the prices will change according to the data. EES_target_list = [ target_entry , target_exit , stop_exit , trunc_dict [ 'close' ][ 1 ]] # run the trade via position module pos_dict = self . open_positions ( give_obj_name , get_obj_name , get_obj_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) if self . auto_unload_all == True : extra_quantity = self . _portfolio . _remainder_dict [ get_obj_name ] extra_pos_dict = self . open_positions ( give_obj_name , get_obj_name , extra_quantity , EES_target_list , pos_type = pos_type , pos_dict = self . extra_pos_dict , size = SIZE_DICT [ get_obj_name ], fee = fee , open_time = open_time ) # Execute the positions. As the function is ran, it chooses the # appropiate EES values based on the choose_EES_values method of # this class trade_open , trade_close , \\ pos_dict , exec_pos_dict = self . execute_positions ( trunc_dict , pos_type = pos_type ) if self . auto_unload_all == True : extra_trade_open , extra_trade_close , \\ extra_pos_dict , extra_exec_pos_dict = self . execute_extra_positions ( \\ trunc_dict , extra_pos_type = \\ pos_type ) # the search function for entry and exit time should be completely # sepearate to the trading actions return trade_open , trade_close , pos_dict , exec_pos_dict","title":"run_trade"},{"location":"EC_tools/trade/#EC_tools.trade.Trade","text":"Bases: Protocol Parent class for all trading strategy. It controls the setting of a particular Trade class. Universal functions are written here. Source code in EC_tools/trade.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class Trade ( Protocol ): \"\"\" Parent class for all trading strategy. It controls the setting of a particular Trade class. Universal functions are written here. \"\"\" def __init__ ( self , portfolio : Portfolio , close_exit_or_not : bool = True , save_only_exec_pos : bool = False , auto_unload_all : bool = False ): self . _portfolio = portfolio self . _close_exit_or_not = close_exit_or_not self . _save_only_exec_pos = save_only_exec_pos self . _auto_unload_all = auto_unload_all @property def close_exit_or_not ( self ): return self . _close_exit_or_not @property def save_only_exec_pos ( self ): return self . _save_only_exec_pos @property def auto_unload_all ( self ): return self . _auto_unload_all @close_exit_or_not . setter def close_exit_or_not ( self , bool_val : bool ) -> None : self . _close_exit_or_not = bool_val @save_only_exec_pos . setter def save_only_exec_pos ( self , bool_val : bool ) -> None : self . _save_only_exec_pos = bool_val @auto_unload_all . setter def auto_unload_all ( self , bool_val : bool ): self . _auto_unload_all = bool_val def add_position ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : str , target_price : float , size : int = 1 , fee : int | float = None , pos_type : str = 'Long' , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ): \"\"\" A simple function that make the process of creating a position easier. It takes the name of the give_obj and get_obj, as well as the desired quantity of get_obj and target price, to create the Asset objects and Position object. The function automatically calculate how much give_obj you are going to spend to purchase it. It assume you have enough within your portfolio. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. target_price : float An initial target price for the position. It is subject to slight changes during the backtest. Returns ------- pos : Position object The trade opsition . \"\"\" get_obj_unit = ASSET_DICT [ get_obj_name ][ 'unit' ] get_obj_type = ASSET_DICT [ get_obj_name ][ 'asset_type' ] give_obj_unit = ASSET_DICT [ give_obj_name ][ 'unit' ] give_obj_type = ASSET_DICT [ give_obj_name ][ 'asset_type' ] # get_obj, asset get_obj = { 'name' : get_obj_name , 'quantity' : get_obj_quantity , 'unit' : get_obj_unit , 'asset_type' : get_obj_type , 'misc' : {}} # give_obj, cash give_obj = { 'name' : give_obj_name , 'quantity' : target_price * get_obj_quantity * size , 'unit' : give_obj_unit , 'asset_type' : give_obj_type , 'misc' :{}} #print(\"before add fee\", fee, get_obj_quantity) if type ( fee ) == dict : new_fee = fee . copy () new_fee [ 'quantity' ] = fee [ 'quantity' ] * get_obj_quantity elif fee == None : new_fee = None # Create a position pos = Position ( give_obj , get_obj , target_price , portfolio = self . _portfolio , size = size , fee = new_fee , pos_type = pos_type , open_time = open_time , pos_id = trade_id ) return pos","title":"Trade"},{"location":"EC_tools/trade/#EC_tools.trade.Trade.add_position","text":"A simple function that make the process of creating a position easier. It takes the name of the give_obj and get_obj, as well as the desired quantity of get_obj and target price, to create the Asset objects and Position object. The function automatically calculate how much give_obj you are going to spend to purchase it. It assume you have enough within your portfolio. Parameters: give_obj_name ( str ) \u2013 The name of the give object. get_obj_name ( str ) \u2013 The name of the get object. get_obj_quantity ( float ) \u2013 The quantity of the get object. target_price ( float ) \u2013 An initial target price for the position. It is subject to slight changes during the backtest. Returns: pos ( Position object ) \u2013 The trade opsition . Source code in EC_tools/trade.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def add_position ( self , give_obj_name : str , get_obj_name : str , get_obj_quantity : str , target_price : float , size : int = 1 , fee : int | float = None , pos_type : str = 'Long' , open_time : datetime . datetime = datetime . datetime . now (), trade_id : int = 0 ): \"\"\" A simple function that make the process of creating a position easier. It takes the name of the give_obj and get_obj, as well as the desired quantity of get_obj and target price, to create the Asset objects and Position object. The function automatically calculate how much give_obj you are going to spend to purchase it. It assume you have enough within your portfolio. Parameters ---------- give_obj_name : str The name of the give object. get_obj_name : str The name of the get object. get_obj_quantity : float The quantity of the get object. target_price : float An initial target price for the position. It is subject to slight changes during the backtest. Returns ------- pos : Position object The trade opsition . \"\"\" get_obj_unit = ASSET_DICT [ get_obj_name ][ 'unit' ] get_obj_type = ASSET_DICT [ get_obj_name ][ 'asset_type' ] give_obj_unit = ASSET_DICT [ give_obj_name ][ 'unit' ] give_obj_type = ASSET_DICT [ give_obj_name ][ 'asset_type' ] # get_obj, asset get_obj = { 'name' : get_obj_name , 'quantity' : get_obj_quantity , 'unit' : get_obj_unit , 'asset_type' : get_obj_type , 'misc' : {}} # give_obj, cash give_obj = { 'name' : give_obj_name , 'quantity' : target_price * get_obj_quantity * size , 'unit' : give_obj_unit , 'asset_type' : give_obj_type , 'misc' :{}} #print(\"before add fee\", fee, get_obj_quantity) if type ( fee ) == dict : new_fee = fee . copy () new_fee [ 'quantity' ] = fee [ 'quantity' ] * get_obj_quantity elif fee == None : new_fee = None # Create a position pos = Position ( give_obj , get_obj , target_price , portfolio = self . _portfolio , size = size , fee = new_fee , pos_type = pos_type , open_time = open_time , pos_id = trade_id ) return pos","title":"add_position"},{"location":"EC_tools/utility/","text":"Utility Created on Thu Mar 28 22:46:34 2024 @author: dexter General utility functions random_string ( length = 16 ) Generate a random x-digits alphanumerical string Parameters: length ( int , default: 16 ) \u2013 The number of digits. Returns: Shortcode. \u2013 Source code in EC_tools/utility.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def random_string ( length : int = 16 ): \"\"\" Generate a random x-digits alphanumerical string Parameters ---------- length : int The number of digits. Returns ------- Shortcode. \"\"\" base = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" # Pick a random 6 digits string from base # The amount to 56,800,235,584 possibilities code = '' . join ([ random . choice ( base ) for i in range ( length )]) return code time_it ( func ) Simple time it function. Use this in a decorator Parameters: func ( TYPE ) \u2013 DESCRIPTION. Returns: TYPE \u2013 DESCRIPTION. Source code in EC_tools/utility.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def time_it ( func ): \"\"\" Simple time it function. Use this in a decorator Parameters ---------- func : TYPE DESCRIPTION. Returns ------- TYPE DESCRIPTION. \"\"\" # simple timing function def wrapper ( * args , ** kwargs ): t1 = time . time () result = func ( * args , ** kwargs ) t2 = time . time () - t1 print ( f \" { func . __name__ !r} ran in { t2 : .4f } seconds.\" ) return result return wrapper","title":"utility"},{"location":"EC_tools/utility/#utility","text":"Created on Thu Mar 28 22:46:34 2024 @author: dexter General utility functions","title":"Utility"},{"location":"EC_tools/utility/#EC_tools.utility.random_string","text":"Generate a random x-digits alphanumerical string Parameters: length ( int , default: 16 ) \u2013 The number of digits. Returns: Shortcode. \u2013 Source code in EC_tools/utility.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def random_string ( length : int = 16 ): \"\"\" Generate a random x-digits alphanumerical string Parameters ---------- length : int The number of digits. Returns ------- Shortcode. \"\"\" base = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" # Pick a random 6 digits string from base # The amount to 56,800,235,584 possibilities code = '' . join ([ random . choice ( base ) for i in range ( length )]) return code","title":"random_string"},{"location":"EC_tools/utility/#EC_tools.utility.time_it","text":"Simple time it function. Use this in a decorator Parameters: func ( TYPE ) \u2013 DESCRIPTION. Returns: TYPE \u2013 DESCRIPTION. Source code in EC_tools/utility.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def time_it ( func ): \"\"\" Simple time it function. Use this in a decorator Parameters ---------- func : TYPE DESCRIPTION. Returns ------- TYPE DESCRIPTION. \"\"\" # simple timing function def wrapper ( * args , ** kwargs ): t1 = time . time () result = func ( * args , ** kwargs ) t2 = time . time () - t1 print ( f \" { func . __name__ !r} ran in { t2 : .4f } seconds.\" ) return result return wrapper","title":"time_it"},{"location":"app/app/","text":"Applications","title":"Introduction"},{"location":"app/app/#applications","text":"","title":"Applications"},{"location":"app/run_PNL_plot/","text":"Run PNL plot Created on Fri May 10 04:35:17 2024 @author: dexter","title":"Run PNL Plots"},{"location":"app/run_PNL_plot/#run-pnl-plot","text":"Created on Fri May 10 04:35:17 2024 @author: dexter","title":"Run PNL plot"},{"location":"app/run_apc_price_study/","text":"Run APC Price Study Created on Wed Aug 7 19:30:06 2024 @author: dexter find_delta ( apc_interest , history_interest , symbol ) Find the price difference in between two different list. Parameters: apc_interest ( TYPE ) \u2013 DESCRIPTION. history_interest ( TYPE ) \u2013 DESCRIPTION. symbol ( TYPE ) \u2013 DESCRIPTION. Returns: delta_list ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_apc_price_study.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def find_delta ( apc_interest , history_interest , symbol ): \"\"\" Find the price difference in between two different list. Parameters ---------- apc_interest : TYPE DESCRIPTION. history_interest : TYPE DESCRIPTION. symbol : TYPE DESCRIPTION. Returns ------- delta_list : TYPE DESCRIPTION. \"\"\" # Daily settlement price list history_interest_close_list = history_interest [ 'Settle' ] . to_list () apc_date = [ apc_interest [ 'PERIOD' ] . iloc [ i ] for i in range ( len ( apc_interest ))] delta_list = list () for i in range ( len ( history_interest_close_list )): delta = ( history_interest_close_list [ i ] - apc_interest . iloc [ i ][ '0.5' ]) / apc_interest . iloc [ i ][ '0.5' ] delta_list . append ( delta ) if history_interest [ 'Date' ] . to_list ()[ i ] != apc_date [ i ]: print ( 'mismatch date' , history_interest [ 'Date' ] . to_list ()[ i ], apc_date [ i ]) pass N = len ( delta_list ) rms = np . sqrt (( 1 / N ) * sum ( np . array ( delta_list ) ** 2 )) print ( symbol , 'Root mean square error:' , rms ) return delta_list make_apc_asset_dict ( symbol , APC_quantile_label_list ) Make a dictionary of a single asset that contain the quantile price information. Source code in app/run_apc_price_study.py 47 48 49 50 51 52 53 54 55 56 57 58 def make_apc_asset_dict ( symbol , APC_quantile_label_list ): \"\"\" Make a dictionary of a single asset that contain the quantile price information. \"\"\" master_dict = dict () for num in APC_quantile_label_list : quantile_list = [ apc_pkl [ symbol ] . iloc [ i ][ num ] for i in range ( len ( apc_pkl [ symbol ]))] master_dict [ num ] = quantile_list return master_dict make_apc_dict ( symbol_list ) A function that make a dictionary of assets, each in itself is a dicrtionary containing the quantile price information Source code in app/run_apc_price_study.py 61 62 63 64 65 66 67 68 69 70 def make_apc_dict ( symbol_list ): \"\"\" A function that make a dictionary of assets, each in itself is a dicrtionary containing the quantile price information \"\"\" master_dict = dict () for symbol in symbol_list : asset_dict = make_apc_asset_dict ( symbol , APC_quantile_label_list ) master_dict [ symbol ] = asset_dict return master_dict pre_select_apc ( apc_pkl ) A function that preselect a subset of the APC file. It returns a reduced version of the apc. The methid is mainly for selecting for the monthly APC with a given Source code in app/run_apc_price_study.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def pre_select_apc ( apc_pkl ): \"\"\" A function that preselect a subset of the APC file. It returns a reduced version of the apc. The methid is mainly for selecting for the monthly APC with a given \"\"\" temp = dict () for key in apc_pkl : df = apc_pkl [ key ] df = df [ df [ 'CONTINUOUS_FORWARD' ] == 1 ] temp [ key ] = df apc_pkl = temp return apc_pkl","title":"Run APC Study"},{"location":"app/run_apc_price_study/#run-apc-price-study","text":"Created on Wed Aug 7 19:30:06 2024 @author: dexter","title":"Run APC Price Study"},{"location":"app/run_apc_price_study/#app.run_apc_price_study.find_delta","text":"Find the price difference in between two different list. Parameters: apc_interest ( TYPE ) \u2013 DESCRIPTION. history_interest ( TYPE ) \u2013 DESCRIPTION. symbol ( TYPE ) \u2013 DESCRIPTION. Returns: delta_list ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_apc_price_study.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def find_delta ( apc_interest , history_interest , symbol ): \"\"\" Find the price difference in between two different list. Parameters ---------- apc_interest : TYPE DESCRIPTION. history_interest : TYPE DESCRIPTION. symbol : TYPE DESCRIPTION. Returns ------- delta_list : TYPE DESCRIPTION. \"\"\" # Daily settlement price list history_interest_close_list = history_interest [ 'Settle' ] . to_list () apc_date = [ apc_interest [ 'PERIOD' ] . iloc [ i ] for i in range ( len ( apc_interest ))] delta_list = list () for i in range ( len ( history_interest_close_list )): delta = ( history_interest_close_list [ i ] - apc_interest . iloc [ i ][ '0.5' ]) / apc_interest . iloc [ i ][ '0.5' ] delta_list . append ( delta ) if history_interest [ 'Date' ] . to_list ()[ i ] != apc_date [ i ]: print ( 'mismatch date' , history_interest [ 'Date' ] . to_list ()[ i ], apc_date [ i ]) pass N = len ( delta_list ) rms = np . sqrt (( 1 / N ) * sum ( np . array ( delta_list ) ** 2 )) print ( symbol , 'Root mean square error:' , rms ) return delta_list","title":"find_delta"},{"location":"app/run_apc_price_study/#app.run_apc_price_study.make_apc_asset_dict","text":"Make a dictionary of a single asset that contain the quantile price information. Source code in app/run_apc_price_study.py 47 48 49 50 51 52 53 54 55 56 57 58 def make_apc_asset_dict ( symbol , APC_quantile_label_list ): \"\"\" Make a dictionary of a single asset that contain the quantile price information. \"\"\" master_dict = dict () for num in APC_quantile_label_list : quantile_list = [ apc_pkl [ symbol ] . iloc [ i ][ num ] for i in range ( len ( apc_pkl [ symbol ]))] master_dict [ num ] = quantile_list return master_dict","title":"make_apc_asset_dict"},{"location":"app/run_apc_price_study/#app.run_apc_price_study.make_apc_dict","text":"A function that make a dictionary of assets, each in itself is a dicrtionary containing the quantile price information Source code in app/run_apc_price_study.py 61 62 63 64 65 66 67 68 69 70 def make_apc_dict ( symbol_list ): \"\"\" A function that make a dictionary of assets, each in itself is a dicrtionary containing the quantile price information \"\"\" master_dict = dict () for symbol in symbol_list : asset_dict = make_apc_asset_dict ( symbol , APC_quantile_label_list ) master_dict [ symbol ] = asset_dict return master_dict","title":"make_apc_dict"},{"location":"app/run_apc_price_study/#app.run_apc_price_study.pre_select_apc","text":"A function that preselect a subset of the APC file. It returns a reduced version of the apc. The methid is mainly for selecting for the monthly APC with a given Source code in app/run_apc_price_study.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def pre_select_apc ( apc_pkl ): \"\"\" A function that preselect a subset of the APC file. It returns a reduced version of the apc. The methid is mainly for selecting for the monthly APC with a given \"\"\" temp = dict () for key in apc_pkl : df = apc_pkl [ key ] df = df [ df [ 'CONTINUOUS_FORWARD' ] == 1 ] temp [ key ] = df apc_pkl = temp return apc_pkl","title":"pre_select_apc"},{"location":"app/run_backtest/","text":"Run Backtest Created on Tue May 7 23:46:42 2024 @author: dexter The run_backtest application setup and run backtest using backtest module Backtest Methods on Singular Asset: The method to run singular asset are: 1) \"run_backtest\" that utilise loop_date and simple_trade functions. 2) \"run_backtest_portfolio\" that utilise loop_date_portfolio and Trade class child objects. Backtest Methods on Multiple Assets: There are several method that can be used to iterate through multiple assets. At the moment, there are two methods: 1) \"run_backtest_list\" that uses \"run_backtest\" and take a list of historical data filename as inputs. 2) \"run_backtest_portfolio_preloaded\" that use a preloaded pkl files that contains the historical data in the form of pd.DataFrame The master function that controls which method to be used: - \"run_backtest_bulk\" is the master function that controls which multi-asset backtest to be used. If method = \"list\", the method runs \"run_backtest_list\", If method = \"preload\", the method runs \"run_backtest_portfolio_preloaded\", run_backtest ( trade_choice , filename_minute , filename_buysell_signals , start_date , end_date , open_hr = '0800' , close_hr = '1630' , selected_directions = [ 'Buy' , 'Sell' ]) The simplest backtest method. It uses the basic 'loop_date' to iterate the data. At the moment it uses cross-over loop. The current method only allows one singular direction signal per day and a set of constant EES Parameters: trade_choice ( TYPE ) \u2013 DESCRIPTION. filename_minute ( str ) \u2013 The filename of the historical minute data. filename_buysell_signals ( str ) \u2013 The filename of the trading signals data. start_date ( datetime ) \u2013 The start date. end_date ( datetime ) \u2013 The end date. open_hr ( str , default: '0800' ) \u2013 The opening hour. The default is '0800'. close_hr ( str , default: '1630' ) \u2013 The closing hour. The default is '1630'. selected_directions \u2013 Returns: dict_trade_PNL ( ataFrame ) \u2013 The resulting PNL file. Source code in app/run_backtest.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @util . time_it def run_backtest ( trade_choice , filename_minute : str , filename_buysell_signals : str , start_date : datetime . datetime , end_date : datetime . datetime , open_hr : str = '0800' , close_hr : str = '1630' , selected_directions = [ \"Buy\" , \"Sell\" ]) -> pd . DataFrame : \"\"\" The simplest backtest method. It uses the basic 'loop_date' to iterate the data. At the moment it uses cross-over loop. The current method only allows one singular direction signal per day and a set of constant EES Parameters ---------- trade_choice : TYPE DESCRIPTION. filename_minute : str The filename of the historical minute data. filename_buysell_signals : str The filename of the trading signals data. start_date : datetime.datetime The start date. end_date : datetime.datetime The end date. open_hr : str, optional The opening hour. The default is '0800'. close_hr : str, optional The closing hour. The default is '1630'. selected_directions: Returns ------- dict_trade_PNL : ataFrame The resulting PNL file. \"\"\" # read the reformatted minute history data history_data = read . read_reformat_Portara_minute_data ( filename_minute ) # Find the date for trading trade_date_table = backtest . prepare_signal_interest ( filename_buysell_signals , direction = selected_directions , trim = False ) start_date = datetime . datetime . strptime ( start_date , \"%Y-%m- %d \" ) # datetime.datetime(2023,1,1) end_date = datetime . datetime . strptime ( end_date , \"%Y-%m- %d \" ) ##datetime.datetime(2023,12,30) # Select for the date interval for investigation history_data = history_data [( history_data [ 'Date' ] >= start_date ) & ( history_data [ 'Date' ] <= end_date )] trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] # loop through the date and set the EES prices for each trading day dict_trade_PNL = backtest . loop_date ( trade_choice , trade_date_table , history_data , open_hr = open_hr , close_hr = close_hr , plot_or_not = False ) return dict_trade_PNL run_backtest_bulk ( TradeMethod , signal_file_loc , save_file_loc , start_date , end_date , method = 'list' , master_signal_filename = '' , master_pnl_filename = '' , give_obj_name = 'USD' , get_obj_quantity = 1 , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , loop_type = LoopType . CROSSOVER , selected_directions = [ 'Buy' , 'Sell' ], save_or_not = True , merge_or_not = True ) Parameters: TradeMethod ( TYPE ) \u2013 DESCRIPTION. signal_file_loc ( dict ) \u2013 DESCRIPTION. save_file_loc ( dict ) \u2013 DESCRIPTION. start_date ( str ) \u2013 DESCRIPTION. end_date ( str ) \u2013 DESCRIPTION. method ( str , default: 'list' ) \u2013 DESCRIPTION. The default is \"list\". master_signal_filename ( str , default: '' ) \u2013 DESCRIPTION. The default is \"\". master_pnl_filename ( str , default: '' ) \u2013 DESCRIPTION. The default is ''. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is 'USD'. get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. open_hr_dict ( TYPE , default: OPEN_HR_DICT ) \u2013 DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict ( TYPE , default: CLOSE_HR_DICT ) \u2013 DESCRIPTION. The default is CLOSE_HR_DICT. loop_type ( LoopType , default: CROSSOVER ) \u2013 DESCRIPTION. The default is LoopType.CROSSOVER. selected_directions ( TYPE , default: ['Buy', 'Sell'] ) \u2013 DESCRIPTION. The default is ['Buy', 'Sell']. save_or_not ( bool , default: True ) \u2013 DESCRIPTION. The default is True. merge_or_not ( bool , default: True ) \u2013 DESCRIPTION. The default is True. Returns: backtest_result ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_backtest.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def run_backtest_bulk ( TradeMethod , signal_file_loc : dict , save_file_loc : dict , start_date : str , end_date : str , method : str = \"list\" , master_signal_filename : str = \"\" , master_pnl_filename : str = '' , give_obj_name : str = 'USD' , get_obj_quantity : int = 1 , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , loop_type : LoopType = LoopType . CROSSOVER , selected_directions = [ 'Buy' , 'Sell' ], save_or_not : bool = True , merge_or_not : bool = True ): \"\"\" Parameters ---------- TradeMethod : TYPE DESCRIPTION. signal_file_loc : dict DESCRIPTION. save_file_loc : dict DESCRIPTION. start_date : str DESCRIPTION. end_date : str DESCRIPTION. method : str, optional DESCRIPTION. The default is \"list\". master_signal_filename : str, optional DESCRIPTION. The default is \"\". master_pnl_filename : str, optional DESCRIPTION. The default is ''. give_obj_name : str, optional DESCRIPTION. The default is 'USD'. get_obj_quantity : int, optional DESCRIPTION. The default is 1. open_hr_dict : TYPE, optional DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict : TYPE, optional DESCRIPTION. The default is CLOSE_HR_DICT. loop_type : LoopType, optional DESCRIPTION. The default is LoopType.CROSSOVER. selected_directions : TYPE, optional DESCRIPTION. The default is ['Buy', 'Sell']. save_or_not : bool, optional DESCRIPTION. The default is True. merge_or_not : bool, optional DESCRIPTION. The default is True. Returns ------- backtest_result : TYPE DESCRIPTION. \"\"\" if method == \"list\" : SAVE_FILENAME_LIST = list ( save_file_loc . values ()) SIGNAL_FILENAME_LIST = list ( signal_file_loc . values ()) SYMBOL_LIST = list ( signal_file_loc . keys ()) HISTORY_MINUTE_FILENAME_LIST = list ( HISTORY_MINTUE_FILE_LOC . values ()) backtest_result = run_backtest_list ( TradeMethod , SAVE_FILENAME_LIST , SYMBOL_LIST , SIGNAL_FILENAME_LIST , HISTORY_MINUTE_FILENAME_LIST , start_date , end_date , open_hr_dict = open_hr_dict , close_hr_dict = close_hr_dict , selected_directions = selected_directions , save_or_not = save_or_not ) if merge_or_not : #merge_filename = getpass.getpass(prompt=\"please enter the name for the merged file :\") #MASTER_SIGNAL_FILENAME = RESULT_FILEPATH + merge_filename read . merge_raw_data ( SAVE_FILENAME_LIST , master_pnl_filename , sort_by = \"Entry_Date\" ) elif method == \"preload\" : #MASTER_SIGNAL_FILENAME HISTORY_MINUTE_PKL = util . load_pkl ( DAILY_MINUTE_DATA_PKL ) PP = run_backtest_portfolio_preloaded ( TradeMethod , master_signal_filename , HISTORY_MINUTE_PKL , start_date , end_date , loop_type = loop_type , give_obj_name = give_obj_name , get_obj_quantity = get_obj_quantity , open_hr_dict = open_hr_dict , close_hr_dict = close_hr_dict , selected_directions = selected_directions ) backtest_result = PP if save_or_not : # save pkl portfolio file = open ( master_pnl_filename , 'wb' ) pickle . dump ( PP , file ) #my_pkl = pickle.load(output) #print(\"File:{} is loaded.\".format(filename)) #output.close() return backtest_result run_backtest_portfolio ( TradeMethod , filename_minute , filename_buysell_signals , start_date , end_date , loop_type = LoopType . CROSSOVER , selected_directions = [ 'Buy' , 'Sell' ]) The basic backtest method utilising the Portfolio module. The current method only allows one singular direction signal per day and a set of constant EES Parameters: TradeMethod ( Trade object ) \u2013 The main trade class object that operate the backtest. filename_minute ( str ) \u2013 The filename of the historical minute data. filename_buysell_signals ( str ) \u2013 The filename of the trading signals data. start_date ( str ) \u2013 The start date. end_date ( str ) \u2013 The end date. Returns: P1 ( Portfolio object ) \u2013 The resulting Portfolio. Source code in app/run_backtest.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def run_backtest_portfolio ( TradeMethod , filename_minute : str , filename_buysell_signals : str , start_date : str , end_date : str , loop_type : LoopType = LoopType . CROSSOVER , selected_directions = [ \"Buy\" , \"Sell\" ]) \\ -> Portfolio : \"\"\" The basic backtest method utilising the Portfolio module. The current method only allows one singular direction signal per day and a set of constant EES Parameters ---------- TradeMethod : Trade object The main trade class object that operate the backtest. filename_minute : str The filename of the historical minute data. filename_buysell_signals : str The filename of the trading signals data. start_date : str The start date. end_date : str The end date. Returns ------- P1 : Portfolio object The resulting Portfolio. \"\"\" # Turn the start and end date from str to datetime.datetime start_date = datetime . datetime . strptime ( start_date , \"%Y-%m- %d \" ) # datetime.datetime(2023,1,1) end_date = datetime . datetime . strptime ( end_date , \"%Y-%m- %d \" ) ##datetime.datetime(2023,12,30) # read the reformatted minute history data history_data = read . read_reformat_Portara_minute_data ( filename_minute ) # Find the date for trading, only \"Buy\" or \"Sell\" date are taken. trade_date_table = backtest . prepare_signal_interest ( filename_buysell_signals , direction = selected_directions , trim = False ) # Select for the date interval for investigation history_data = history_data [( history_data [ 'Date' ] >= start_date ) & ( history_data [ 'Date' ] <= end_date )] trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] # Initialise Portfolio P1 = Portfolio () USD_initial = Asset ( \"USD\" , 10_000_000 , \"dollars\" , \"Cash\" ) # initial fund P1 . add ( USD_initial , datetime = datetime . datetime ( 2020 , 12 , 31 )) # loop through the date and set the EES prices for each trading day P1 = Loop ( loop_type ) . loop_date_portfolio ( P1 , TradeMethod , trade_date_table , history_data , give_obj_name = \"USD\" , get_obj_name = \"HOc1\" , get_obj_quantity = 10 , open_hr = '1300' , close_hr = '1828' , plot_or_not = False ) print ( 'master_table' , P1 . master_table ) return P1 run_backtest_portfolio_monthly ( TradeMethod , master_signals_filename , histroy_intraday_data_pkl , histroy_minute_cumavg_data_pkl , start_date , end_date , give_obj_name = 'USD' , get_obj_quantity = 1 , loop_type = LoopType . CROSSOVER , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , selected_directions = [ 'Buy' , 'Sell' ], plot_or_not = False ) Parameters: TradeMethod ( TYPE ) \u2013 DESCRIPTION. master_signals_filename ( str ) \u2013 DESCRIPTION. histroy_intraday_data_pkl ( dict ) \u2013 DESCRIPTION. histroy_minute_cumavg_data_pkl ( dict [ str , DataFrame ] ) \u2013 DESCRIPTION. start_date ( str ) \u2013 DESCRIPTION. end_date ( str ) \u2013 DESCRIPTION. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. loop_type ( LoopType , default: CROSSOVER ) \u2013 DESCRIPTION. The default is LoopType.CROSSOVER. open_hr_dict ( dict , default: OPEN_HR_DICT ) \u2013 DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict ( dict , default: CLOSE_HR_DICT ) \u2013 DESCRIPTION. The default is CLOSE_HR_DICT. selected_directions ( TYPE , default: ['Buy', 'Sell'] ) \u2013 DESCRIPTION. The default is [\"Buy\", \"Sell\"]. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: P1 ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_backtest.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def run_backtest_portfolio_monthly ( TradeMethod , master_signals_filename : str , histroy_intraday_data_pkl : dict , histroy_minute_cumavg_data_pkl : dict [ str , pd . DataFrame ], start_date : str , end_date : str , give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , loop_type : LoopType = LoopType . CROSSOVER , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , selected_directions = [ \"Buy\" , \"Sell\" ], plot_or_not : bool = False ): \"\"\" Parameters ---------- TradeMethod : TYPE DESCRIPTION. master_signals_filename : str DESCRIPTION. histroy_intraday_data_pkl : dict DESCRIPTION. histroy_minute_cumavg_data_pkl : dict[str, pd.DataFrame] DESCRIPTION. start_date : str DESCRIPTION. end_date : str DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. loop_type : LoopType, optional DESCRIPTION. The default is LoopType.CROSSOVER. open_hr_dict : dict, optional DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict : dict, optional DESCRIPTION. The default is CLOSE_HR_DICT. selected_directions : TYPE, optional DESCRIPTION. The default is [\"Buy\", \"Sell\"]. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- P1 : TYPE DESCRIPTION. \"\"\" t1 = time . time () start_date = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) end_date = datetime . datetime . strptime ( end_date , '%Y-%m- %d ' ) # Find the date for trading, only \"Buy\" or \"Sell\" date are taken. trade_date_table = backtest . prepare_signal_interest ( master_signals_filename , direction = selected_directions , trim = False ) trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] print ( trade_date_table ) # Initialise Portfolio P1 = Portfolio () USD_initial = { 'name' : \"USD\" , 'quantity' : 10_000_000 , 'unit' : \"dollars\" , 'asset_type' : \"Cash\" , 'misc' :{}} # initial fund P1 . add ( USD_initial , datetime = datetime . datetime ( 2020 , 12 , 31 )) P1 = Loop ( loop_type ) . loop_portfolio_preloaded_long ( P1 , TradeMethod , trade_date_table , histroy_intraday_data_pkl , histroy_minute_cumavg_data_pkl , give_obj_name = give_obj_name , get_obj_quantity = get_obj_quantity , plot_or_not = plot_or_not ) t2 = time . time () - t1 print ( \"It takes {} seconds to run the backtest\" . format ( t2 )) return P1 run_backtest_portfolio_preloaded ( TradeMethod , master_signals_filename , histroy_intraday_data_pkl , start_date , end_date , give_obj_name = 'USD' , get_obj_quantity = 1 , loop_type = LoopType . CROSSOVER , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , selected_directions = [ 'Buy' , 'Sell' ], plot_or_not = False ) Parameters: TradeMethod ( func or Trade object ) \u2013 The trademethod function/class. master_buysell_signals_filename ( str ) \u2013 The signal table filename. histroy_intraday_data_pkl ( TYPE ) \u2013 The dictionary of the preloaded historical minute data. start_date ( str ) \u2013 The start date. end_date ( str ) \u2013 The end date. give_obj_name ( str , default: 'USD' ) \u2013 The name of the give object. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 The name of the get object. The default is 1. Returns: P1 ( Portfolio object ) \u2013 DESCRIPTION. Source code in app/run_backtest.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def run_backtest_portfolio_preloaded ( TradeMethod , master_signals_filename : str , histroy_intraday_data_pkl : dict , start_date : str , end_date : str , give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , loop_type : LoopType = LoopType . CROSSOVER , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , selected_directions = [ \"Buy\" , \"Sell\" ], plot_or_not : bool = False ): \"\"\" Parameters ---------- TradeMethod : func or Trade object The trademethod function/class. master_buysell_signals_filename : str The signal table filename. histroy_intraday_data_pkl : TYPE The dictionary of the preloaded historical minute data. start_date : str The start date. end_date : str The end date. give_obj_name : str, optional The name of the give object. The default is \"USD\". get_obj_quantity : int, optional The name of the get object. The default is 1. Returns ------- P1 : Portfolio object DESCRIPTION. \"\"\" t1 = time . time () start_date = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) end_date = datetime . datetime . strptime ( end_date , '%Y-%m- %d ' ) #histroy_intraday_data_pkl = util.load_pkl(histroy_intraday_data_pkl_filename) # Find the date for trading, only \"Buy\" or \"Sell\" date are taken. trade_date_table = backtest . prepare_signal_interest ( master_signals_filename , direction = selected_directions , trim = False ) #start_date_lag = datetime.datetime.strptime(start_date, '%Y-%m-%d') - \\ # datetime.timedelta(days= start_date_pushback) trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] # Initialise Portfolio P1 = Portfolio () USD_initial = { 'name' : \"USD\" , 'quantity' : 10_000_000 , 'unit' : \"dollars\" , 'asset_type' : \"Cash\" , 'misc' :{}} # initial fund P1 . add ( USD_initial , datetime = datetime . datetime ( 2020 , 12 , 31 )) # a list of input files P1 = Loop ( loop_type ) . loop_portfolio_preloaded ( P1 , TradeMethod , trade_date_table , histroy_intraday_data_pkl , give_obj_name = give_obj_name , get_obj_quantity = get_obj_quantity , plot_or_not = plot_or_not ) t2 = time . time () - t1 print ( \"It takes {} seconds to run the backtest\" . format ( t2 )) return P1","title":"Run Backtest"},{"location":"app/run_backtest/#run-backtest","text":"Created on Tue May 7 23:46:42 2024 @author: dexter The run_backtest application setup and run backtest using backtest module Backtest Methods on Singular Asset: The method to run singular asset are: 1) \"run_backtest\" that utilise loop_date and simple_trade functions. 2) \"run_backtest_portfolio\" that utilise loop_date_portfolio and Trade class child objects. Backtest Methods on Multiple Assets: There are several method that can be used to iterate through multiple assets. At the moment, there are two methods: 1) \"run_backtest_list\" that uses \"run_backtest\" and take a list of historical data filename as inputs. 2) \"run_backtest_portfolio_preloaded\" that use a preloaded pkl files that contains the historical data in the form of pd.DataFrame The master function that controls which method to be used: - \"run_backtest_bulk\" is the master function that controls which multi-asset backtest to be used. If method = \"list\", the method runs \"run_backtest_list\", If method = \"preload\", the method runs \"run_backtest_portfolio_preloaded\",","title":"Run Backtest"},{"location":"app/run_backtest/#app.run_backtest.run_backtest","text":"The simplest backtest method. It uses the basic 'loop_date' to iterate the data. At the moment it uses cross-over loop. The current method only allows one singular direction signal per day and a set of constant EES Parameters: trade_choice ( TYPE ) \u2013 DESCRIPTION. filename_minute ( str ) \u2013 The filename of the historical minute data. filename_buysell_signals ( str ) \u2013 The filename of the trading signals data. start_date ( datetime ) \u2013 The start date. end_date ( datetime ) \u2013 The end date. open_hr ( str , default: '0800' ) \u2013 The opening hour. The default is '0800'. close_hr ( str , default: '1630' ) \u2013 The closing hour. The default is '1630'. selected_directions \u2013 Returns: dict_trade_PNL ( ataFrame ) \u2013 The resulting PNL file. Source code in app/run_backtest.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @util . time_it def run_backtest ( trade_choice , filename_minute : str , filename_buysell_signals : str , start_date : datetime . datetime , end_date : datetime . datetime , open_hr : str = '0800' , close_hr : str = '1630' , selected_directions = [ \"Buy\" , \"Sell\" ]) -> pd . DataFrame : \"\"\" The simplest backtest method. It uses the basic 'loop_date' to iterate the data. At the moment it uses cross-over loop. The current method only allows one singular direction signal per day and a set of constant EES Parameters ---------- trade_choice : TYPE DESCRIPTION. filename_minute : str The filename of the historical minute data. filename_buysell_signals : str The filename of the trading signals data. start_date : datetime.datetime The start date. end_date : datetime.datetime The end date. open_hr : str, optional The opening hour. The default is '0800'. close_hr : str, optional The closing hour. The default is '1630'. selected_directions: Returns ------- dict_trade_PNL : ataFrame The resulting PNL file. \"\"\" # read the reformatted minute history data history_data = read . read_reformat_Portara_minute_data ( filename_minute ) # Find the date for trading trade_date_table = backtest . prepare_signal_interest ( filename_buysell_signals , direction = selected_directions , trim = False ) start_date = datetime . datetime . strptime ( start_date , \"%Y-%m- %d \" ) # datetime.datetime(2023,1,1) end_date = datetime . datetime . strptime ( end_date , \"%Y-%m- %d \" ) ##datetime.datetime(2023,12,30) # Select for the date interval for investigation history_data = history_data [( history_data [ 'Date' ] >= start_date ) & ( history_data [ 'Date' ] <= end_date )] trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] # loop through the date and set the EES prices for each trading day dict_trade_PNL = backtest . loop_date ( trade_choice , trade_date_table , history_data , open_hr = open_hr , close_hr = close_hr , plot_or_not = False ) return dict_trade_PNL","title":"run_backtest"},{"location":"app/run_backtest/#app.run_backtest.run_backtest_bulk","text":"Parameters: TradeMethod ( TYPE ) \u2013 DESCRIPTION. signal_file_loc ( dict ) \u2013 DESCRIPTION. save_file_loc ( dict ) \u2013 DESCRIPTION. start_date ( str ) \u2013 DESCRIPTION. end_date ( str ) \u2013 DESCRIPTION. method ( str , default: 'list' ) \u2013 DESCRIPTION. The default is \"list\". master_signal_filename ( str , default: '' ) \u2013 DESCRIPTION. The default is \"\". master_pnl_filename ( str , default: '' ) \u2013 DESCRIPTION. The default is ''. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is 'USD'. get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. open_hr_dict ( TYPE , default: OPEN_HR_DICT ) \u2013 DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict ( TYPE , default: CLOSE_HR_DICT ) \u2013 DESCRIPTION. The default is CLOSE_HR_DICT. loop_type ( LoopType , default: CROSSOVER ) \u2013 DESCRIPTION. The default is LoopType.CROSSOVER. selected_directions ( TYPE , default: ['Buy', 'Sell'] ) \u2013 DESCRIPTION. The default is ['Buy', 'Sell']. save_or_not ( bool , default: True ) \u2013 DESCRIPTION. The default is True. merge_or_not ( bool , default: True ) \u2013 DESCRIPTION. The default is True. Returns: backtest_result ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_backtest.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def run_backtest_bulk ( TradeMethod , signal_file_loc : dict , save_file_loc : dict , start_date : str , end_date : str , method : str = \"list\" , master_signal_filename : str = \"\" , master_pnl_filename : str = '' , give_obj_name : str = 'USD' , get_obj_quantity : int = 1 , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , loop_type : LoopType = LoopType . CROSSOVER , selected_directions = [ 'Buy' , 'Sell' ], save_or_not : bool = True , merge_or_not : bool = True ): \"\"\" Parameters ---------- TradeMethod : TYPE DESCRIPTION. signal_file_loc : dict DESCRIPTION. save_file_loc : dict DESCRIPTION. start_date : str DESCRIPTION. end_date : str DESCRIPTION. method : str, optional DESCRIPTION. The default is \"list\". master_signal_filename : str, optional DESCRIPTION. The default is \"\". master_pnl_filename : str, optional DESCRIPTION. The default is ''. give_obj_name : str, optional DESCRIPTION. The default is 'USD'. get_obj_quantity : int, optional DESCRIPTION. The default is 1. open_hr_dict : TYPE, optional DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict : TYPE, optional DESCRIPTION. The default is CLOSE_HR_DICT. loop_type : LoopType, optional DESCRIPTION. The default is LoopType.CROSSOVER. selected_directions : TYPE, optional DESCRIPTION. The default is ['Buy', 'Sell']. save_or_not : bool, optional DESCRIPTION. The default is True. merge_or_not : bool, optional DESCRIPTION. The default is True. Returns ------- backtest_result : TYPE DESCRIPTION. \"\"\" if method == \"list\" : SAVE_FILENAME_LIST = list ( save_file_loc . values ()) SIGNAL_FILENAME_LIST = list ( signal_file_loc . values ()) SYMBOL_LIST = list ( signal_file_loc . keys ()) HISTORY_MINUTE_FILENAME_LIST = list ( HISTORY_MINTUE_FILE_LOC . values ()) backtest_result = run_backtest_list ( TradeMethod , SAVE_FILENAME_LIST , SYMBOL_LIST , SIGNAL_FILENAME_LIST , HISTORY_MINUTE_FILENAME_LIST , start_date , end_date , open_hr_dict = open_hr_dict , close_hr_dict = close_hr_dict , selected_directions = selected_directions , save_or_not = save_or_not ) if merge_or_not : #merge_filename = getpass.getpass(prompt=\"please enter the name for the merged file :\") #MASTER_SIGNAL_FILENAME = RESULT_FILEPATH + merge_filename read . merge_raw_data ( SAVE_FILENAME_LIST , master_pnl_filename , sort_by = \"Entry_Date\" ) elif method == \"preload\" : #MASTER_SIGNAL_FILENAME HISTORY_MINUTE_PKL = util . load_pkl ( DAILY_MINUTE_DATA_PKL ) PP = run_backtest_portfolio_preloaded ( TradeMethod , master_signal_filename , HISTORY_MINUTE_PKL , start_date , end_date , loop_type = loop_type , give_obj_name = give_obj_name , get_obj_quantity = get_obj_quantity , open_hr_dict = open_hr_dict , close_hr_dict = close_hr_dict , selected_directions = selected_directions ) backtest_result = PP if save_or_not : # save pkl portfolio file = open ( master_pnl_filename , 'wb' ) pickle . dump ( PP , file ) #my_pkl = pickle.load(output) #print(\"File:{} is loaded.\".format(filename)) #output.close() return backtest_result","title":"run_backtest_bulk"},{"location":"app/run_backtest/#app.run_backtest.run_backtest_portfolio","text":"The basic backtest method utilising the Portfolio module. The current method only allows one singular direction signal per day and a set of constant EES Parameters: TradeMethod ( Trade object ) \u2013 The main trade class object that operate the backtest. filename_minute ( str ) \u2013 The filename of the historical minute data. filename_buysell_signals ( str ) \u2013 The filename of the trading signals data. start_date ( str ) \u2013 The start date. end_date ( str ) \u2013 The end date. Returns: P1 ( Portfolio object ) \u2013 The resulting Portfolio. Source code in app/run_backtest.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def run_backtest_portfolio ( TradeMethod , filename_minute : str , filename_buysell_signals : str , start_date : str , end_date : str , loop_type : LoopType = LoopType . CROSSOVER , selected_directions = [ \"Buy\" , \"Sell\" ]) \\ -> Portfolio : \"\"\" The basic backtest method utilising the Portfolio module. The current method only allows one singular direction signal per day and a set of constant EES Parameters ---------- TradeMethod : Trade object The main trade class object that operate the backtest. filename_minute : str The filename of the historical minute data. filename_buysell_signals : str The filename of the trading signals data. start_date : str The start date. end_date : str The end date. Returns ------- P1 : Portfolio object The resulting Portfolio. \"\"\" # Turn the start and end date from str to datetime.datetime start_date = datetime . datetime . strptime ( start_date , \"%Y-%m- %d \" ) # datetime.datetime(2023,1,1) end_date = datetime . datetime . strptime ( end_date , \"%Y-%m- %d \" ) ##datetime.datetime(2023,12,30) # read the reformatted minute history data history_data = read . read_reformat_Portara_minute_data ( filename_minute ) # Find the date for trading, only \"Buy\" or \"Sell\" date are taken. trade_date_table = backtest . prepare_signal_interest ( filename_buysell_signals , direction = selected_directions , trim = False ) # Select for the date interval for investigation history_data = history_data [( history_data [ 'Date' ] >= start_date ) & ( history_data [ 'Date' ] <= end_date )] trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] # Initialise Portfolio P1 = Portfolio () USD_initial = Asset ( \"USD\" , 10_000_000 , \"dollars\" , \"Cash\" ) # initial fund P1 . add ( USD_initial , datetime = datetime . datetime ( 2020 , 12 , 31 )) # loop through the date and set the EES prices for each trading day P1 = Loop ( loop_type ) . loop_date_portfolio ( P1 , TradeMethod , trade_date_table , history_data , give_obj_name = \"USD\" , get_obj_name = \"HOc1\" , get_obj_quantity = 10 , open_hr = '1300' , close_hr = '1828' , plot_or_not = False ) print ( 'master_table' , P1 . master_table ) return P1","title":"run_backtest_portfolio"},{"location":"app/run_backtest/#app.run_backtest.run_backtest_portfolio_monthly","text":"Parameters: TradeMethod ( TYPE ) \u2013 DESCRIPTION. master_signals_filename ( str ) \u2013 DESCRIPTION. histroy_intraday_data_pkl ( dict ) \u2013 DESCRIPTION. histroy_minute_cumavg_data_pkl ( dict [ str , DataFrame ] ) \u2013 DESCRIPTION. start_date ( str ) \u2013 DESCRIPTION. end_date ( str ) \u2013 DESCRIPTION. give_obj_name ( str , default: 'USD' ) \u2013 DESCRIPTION. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. loop_type ( LoopType , default: CROSSOVER ) \u2013 DESCRIPTION. The default is LoopType.CROSSOVER. open_hr_dict ( dict , default: OPEN_HR_DICT ) \u2013 DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict ( dict , default: CLOSE_HR_DICT ) \u2013 DESCRIPTION. The default is CLOSE_HR_DICT. selected_directions ( TYPE , default: ['Buy', 'Sell'] ) \u2013 DESCRIPTION. The default is [\"Buy\", \"Sell\"]. plot_or_not ( bool , default: False ) \u2013 DESCRIPTION. The default is False. Returns: P1 ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_backtest.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def run_backtest_portfolio_monthly ( TradeMethod , master_signals_filename : str , histroy_intraday_data_pkl : dict , histroy_minute_cumavg_data_pkl : dict [ str , pd . DataFrame ], start_date : str , end_date : str , give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , loop_type : LoopType = LoopType . CROSSOVER , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , selected_directions = [ \"Buy\" , \"Sell\" ], plot_or_not : bool = False ): \"\"\" Parameters ---------- TradeMethod : TYPE DESCRIPTION. master_signals_filename : str DESCRIPTION. histroy_intraday_data_pkl : dict DESCRIPTION. histroy_minute_cumavg_data_pkl : dict[str, pd.DataFrame] DESCRIPTION. start_date : str DESCRIPTION. end_date : str DESCRIPTION. give_obj_name : str, optional DESCRIPTION. The default is \"USD\". get_obj_quantity : int, optional DESCRIPTION. The default is 1. loop_type : LoopType, optional DESCRIPTION. The default is LoopType.CROSSOVER. open_hr_dict : dict, optional DESCRIPTION. The default is OPEN_HR_DICT. close_hr_dict : dict, optional DESCRIPTION. The default is CLOSE_HR_DICT. selected_directions : TYPE, optional DESCRIPTION. The default is [\"Buy\", \"Sell\"]. plot_or_not : bool, optional DESCRIPTION. The default is False. Returns ------- P1 : TYPE DESCRIPTION. \"\"\" t1 = time . time () start_date = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) end_date = datetime . datetime . strptime ( end_date , '%Y-%m- %d ' ) # Find the date for trading, only \"Buy\" or \"Sell\" date are taken. trade_date_table = backtest . prepare_signal_interest ( master_signals_filename , direction = selected_directions , trim = False ) trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] print ( trade_date_table ) # Initialise Portfolio P1 = Portfolio () USD_initial = { 'name' : \"USD\" , 'quantity' : 10_000_000 , 'unit' : \"dollars\" , 'asset_type' : \"Cash\" , 'misc' :{}} # initial fund P1 . add ( USD_initial , datetime = datetime . datetime ( 2020 , 12 , 31 )) P1 = Loop ( loop_type ) . loop_portfolio_preloaded_long ( P1 , TradeMethod , trade_date_table , histroy_intraday_data_pkl , histroy_minute_cumavg_data_pkl , give_obj_name = give_obj_name , get_obj_quantity = get_obj_quantity , plot_or_not = plot_or_not ) t2 = time . time () - t1 print ( \"It takes {} seconds to run the backtest\" . format ( t2 )) return P1","title":"run_backtest_portfolio_monthly"},{"location":"app/run_backtest/#app.run_backtest.run_backtest_portfolio_preloaded","text":"Parameters: TradeMethod ( func or Trade object ) \u2013 The trademethod function/class. master_buysell_signals_filename ( str ) \u2013 The signal table filename. histroy_intraday_data_pkl ( TYPE ) \u2013 The dictionary of the preloaded historical minute data. start_date ( str ) \u2013 The start date. end_date ( str ) \u2013 The end date. give_obj_name ( str , default: 'USD' ) \u2013 The name of the give object. The default is \"USD\". get_obj_quantity ( int , default: 1 ) \u2013 The name of the get object. The default is 1. Returns: P1 ( Portfolio object ) \u2013 DESCRIPTION. Source code in app/run_backtest.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def run_backtest_portfolio_preloaded ( TradeMethod , master_signals_filename : str , histroy_intraday_data_pkl : dict , start_date : str , end_date : str , give_obj_name : str = \"USD\" , get_obj_quantity : int = 1 , loop_type : LoopType = LoopType . CROSSOVER , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , selected_directions = [ \"Buy\" , \"Sell\" ], plot_or_not : bool = False ): \"\"\" Parameters ---------- TradeMethod : func or Trade object The trademethod function/class. master_buysell_signals_filename : str The signal table filename. histroy_intraday_data_pkl : TYPE The dictionary of the preloaded historical minute data. start_date : str The start date. end_date : str The end date. give_obj_name : str, optional The name of the give object. The default is \"USD\". get_obj_quantity : int, optional The name of the get object. The default is 1. Returns ------- P1 : Portfolio object DESCRIPTION. \"\"\" t1 = time . time () start_date = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) end_date = datetime . datetime . strptime ( end_date , '%Y-%m- %d ' ) #histroy_intraday_data_pkl = util.load_pkl(histroy_intraday_data_pkl_filename) # Find the date for trading, only \"Buy\" or \"Sell\" date are taken. trade_date_table = backtest . prepare_signal_interest ( master_signals_filename , direction = selected_directions , trim = False ) #start_date_lag = datetime.datetime.strptime(start_date, '%Y-%m-%d') - \\ # datetime.timedelta(days= start_date_pushback) trade_date_table = trade_date_table [( trade_date_table [ 'Date' ] >= start_date ) & ( trade_date_table [ 'Date' ] <= end_date )] # Initialise Portfolio P1 = Portfolio () USD_initial = { 'name' : \"USD\" , 'quantity' : 10_000_000 , 'unit' : \"dollars\" , 'asset_type' : \"Cash\" , 'misc' :{}} # initial fund P1 . add ( USD_initial , datetime = datetime . datetime ( 2020 , 12 , 31 )) # a list of input files P1 = Loop ( loop_type ) . loop_portfolio_preloaded ( P1 , TradeMethod , trade_date_table , histroy_intraday_data_pkl , give_obj_name = give_obj_name , get_obj_quantity = get_obj_quantity , plot_or_not = plot_or_not ) t2 = time . time () - t1 print ( \"It takes {} seconds to run the backtest\" . format ( t2 )) return P1","title":"run_backtest_portfolio_preloaded"},{"location":"app/run_comparison_plot/","text":"Run Comparison Plot Created on Wed Jul 17 23:30:24 2024 @author: dexter","title":"Run Comparison Plot"},{"location":"app/run_comparison_plot/#run-comparison-plot","text":"Created on Wed Jul 17 23:30:24 2024 @author: dexter","title":"Run Comparison Plot"},{"location":"app/run_daily_instruction/","text":"Run Daily Instruction Created on Wed May 15 02:31:06 2024 @author: dexter enter_new_value ( workbook , date_interest , cell_loc_dict , signal_result_dict , contract_num_dict , output_filename ) Enter new values to the excel workbook. Parameters: workbook ( TYPE ) \u2013 DESCRIPTION. date_interest ( TYPE ) \u2013 DESCRIPTION. cell_loc_dict ( TYPE ) \u2013 DESCRIPTION. signal_result_dict ( TYPE ) \u2013 DESCRIPTION. contract_num_dict ( TYPE ) \u2013 DESCRIPTION. output_filename ( TYPE ) \u2013 DESCRIPTION. Returns: workbook ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @util . time_it def enter_new_value ( workbook , date_interest : datetime . datetime , cell_loc_dict : dict , signal_result_dict : dict , contract_num_dict : dict , output_filename : str ): \"\"\" Enter new values to the excel workbook. Parameters ---------- workbook : TYPE DESCRIPTION. date_interest : TYPE DESCRIPTION. cell_loc_dict : TYPE DESCRIPTION. signal_result_dict : TYPE DESCRIPTION. contract_num_dict : TYPE DESCRIPTION. output_filename : TYPE DESCRIPTION. Returns ------- workbook : TYPE DESCRIPTION. \"\"\" sheet_obj = workbook . active asset_name_list = list ( cell_loc_dict . keys ()) for asset_name in asset_name_list : #if asset_name == 'CLc1': direction_cell = cell_loc_dict [ asset_name ][ 'signal_type' ] entry_cell = cell_loc_dict [ asset_name ][ 'target_entry' ] exit_cell = cell_loc_dict [ asset_name ][ 'target_exit' ] stop_cell = cell_loc_dict [ asset_name ][ 'stop_loss' ] symbol_cell = cell_loc_dict [ asset_name ][ 'symbol' ] number_cell = cell_loc_dict [ asset_name ][ 'number' ] sheet_obj [ direction_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'direction' ] sheet_obj [ entry_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'target entry' ] sheet_obj [ exit_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'target exit' ] sheet_obj [ stop_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'stop exit' ] sheet_obj [ symbol_cell ] . value = make_new_symbol ( date_interest , asset_name , forward_unit = int ( asset_name [ - 1 ])) sheet_obj [ number_cell ] . value = contract_num_dict [ asset_name ] # a function that add new values into the new excel file return workbook gen_new_xlfile ( xl_template_filename , output_filename , date_interest , signal_result_dict , cell_loc_dict = CELL_LOC_DICT , contract_num_dict = CONTRACT_NUM_DICT ) Generate a new excel file. Parameters: xl_template_filename ( TYPE ) \u2013 DESCRIPTION. output_filename ( TYPE ) \u2013 DESCRIPTION. date_interest ( TYPE ) \u2013 DESCRIPTION. signal_result_dict ( TYPE ) \u2013 DESCRIPTION. cell_loc_dict ( TYPE , default: CELL_LOC_DICT ) \u2013 DESCRIPTION. The default is CELL_LOC_DICT. contract_num_dict ( TYPE , default: CONTRACT_NUM_DICT ) \u2013 DESCRIPTION. The default is CONTRACT_NUM_DICT. Returns: wb_obj ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 @util . time_it def gen_new_xlfile ( xl_template_filename : str , output_filename : str , date_interest : datetime . datetime , signal_result_dict : dict , cell_loc_dict : dict = CELL_LOC_DICT , contract_num_dict : dict = CONTRACT_NUM_DICT ): \"\"\" Generate a new excel file. Parameters ---------- xl_template_filename : TYPE DESCRIPTION. output_filename : TYPE DESCRIPTION. date_interest : TYPE DESCRIPTION. signal_result_dict : TYPE DESCRIPTION. cell_loc_dict : TYPE, optional DESCRIPTION. The default is CELL_LOC_DICT. contract_num_dict : TYPE, optional DESCRIPTION. The default is CONTRACT_NUM_DICT. Returns ------- wb_obj : TYPE DESCRIPTION. \"\"\" wb_obj = openpyxl . load_workbook ( xl_template_filename ) wb_obj = enter_new_value ( wb_obj , date_interest , cell_loc_dict , signal_result_dict , contract_num_dict , output_filename ) wb_obj . save ( output_filename ) return wb_obj make_new_symbol ( date_interest , old_symbol , forward_unit = 1 ) A function that generate a new price symbol based on the month and year of today. Parameters: date_interest ( datetime ) \u2013 DESCRIPTION. old_symbol ( str ) \u2013 DESCRIPTION. forward_unit ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. Returns: str \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def make_new_symbol ( date_interest : datetime . datetime , old_symbol : str , forward_unit : int = 1 ) -> str : \"\"\" A function that generate a new price symbol based on the month and year of today. Parameters ---------- date_interest : datetime.datetime DESCRIPTION. old_symbol : str DESCRIPTION. forward_unit : int, optional DESCRIPTION. The default is 1. Returns ------- str DESCRIPTION. \"\"\" month_str = str ( date_interest . month + forward_unit ) year_str = str ( date_interest . year ) new_symbol = old_symbol [ 0 : 2 ] + MONTHS_TO_SYMBOLS [ month_str ] + year_str [ - 2 :] return new_symbol run_MR_list ( start_date , end_date , MR_method = run_gen_MR_signals_preloaded_list ) Run MR stratgy in a list. Parameters: start_date ( TYPE ) \u2013 DESCRIPTION. start_date_2 ( TYPE ) \u2013 DESCRIPTION. end_date ( TYPE ) \u2013 DESCRIPTION. Returns: A ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @util . time_it def run_MR_list ( start_date , end_date , MR_method = run_gen_MR_signals_preloaded_list ): \"\"\" Run MR stratgy in a list. Parameters ---------- start_date : TYPE DESCRIPTION. start_date_2 : TYPE DESCRIPTION. end_date : TYPE DESCRIPTION. Returns ------- A : TYPE DESCRIPTION. \"\"\" SAVE_SIGNAL_FILENAME_LIST = TEST_FILE_LOC result = MR_method ( SAVE_SIGNAL_FILENAME_LIST , start_date , end_date , SIGNAL_PKL , HISTORY_DAILY_PKL , OPENPRICE_PKL , save_or_not = False ) return result","title":"Run Daily Instruction"},{"location":"app/run_daily_instruction/#run-daily-instruction","text":"Created on Wed May 15 02:31:06 2024 @author: dexter","title":"Run Daily Instruction"},{"location":"app/run_daily_instruction/#app.run_daily_instruction.enter_new_value","text":"Enter new values to the excel workbook. Parameters: workbook ( TYPE ) \u2013 DESCRIPTION. date_interest ( TYPE ) \u2013 DESCRIPTION. cell_loc_dict ( TYPE ) \u2013 DESCRIPTION. signal_result_dict ( TYPE ) \u2013 DESCRIPTION. contract_num_dict ( TYPE ) \u2013 DESCRIPTION. output_filename ( TYPE ) \u2013 DESCRIPTION. Returns: workbook ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @util . time_it def enter_new_value ( workbook , date_interest : datetime . datetime , cell_loc_dict : dict , signal_result_dict : dict , contract_num_dict : dict , output_filename : str ): \"\"\" Enter new values to the excel workbook. Parameters ---------- workbook : TYPE DESCRIPTION. date_interest : TYPE DESCRIPTION. cell_loc_dict : TYPE DESCRIPTION. signal_result_dict : TYPE DESCRIPTION. contract_num_dict : TYPE DESCRIPTION. output_filename : TYPE DESCRIPTION. Returns ------- workbook : TYPE DESCRIPTION. \"\"\" sheet_obj = workbook . active asset_name_list = list ( cell_loc_dict . keys ()) for asset_name in asset_name_list : #if asset_name == 'CLc1': direction_cell = cell_loc_dict [ asset_name ][ 'signal_type' ] entry_cell = cell_loc_dict [ asset_name ][ 'target_entry' ] exit_cell = cell_loc_dict [ asset_name ][ 'target_exit' ] stop_cell = cell_loc_dict [ asset_name ][ 'stop_loss' ] symbol_cell = cell_loc_dict [ asset_name ][ 'symbol' ] number_cell = cell_loc_dict [ asset_name ][ 'number' ] sheet_obj [ direction_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'direction' ] sheet_obj [ entry_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'target entry' ] sheet_obj [ exit_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'target exit' ] sheet_obj [ stop_cell ] . value = signal_result_dict [ asset_name ] . iloc \\ [ - 1 ][ 'stop exit' ] sheet_obj [ symbol_cell ] . value = make_new_symbol ( date_interest , asset_name , forward_unit = int ( asset_name [ - 1 ])) sheet_obj [ number_cell ] . value = contract_num_dict [ asset_name ] # a function that add new values into the new excel file return workbook","title":"enter_new_value"},{"location":"app/run_daily_instruction/#app.run_daily_instruction.gen_new_xlfile","text":"Generate a new excel file. Parameters: xl_template_filename ( TYPE ) \u2013 DESCRIPTION. output_filename ( TYPE ) \u2013 DESCRIPTION. date_interest ( TYPE ) \u2013 DESCRIPTION. signal_result_dict ( TYPE ) \u2013 DESCRIPTION. cell_loc_dict ( TYPE , default: CELL_LOC_DICT ) \u2013 DESCRIPTION. The default is CELL_LOC_DICT. contract_num_dict ( TYPE , default: CONTRACT_NUM_DICT ) \u2013 DESCRIPTION. The default is CONTRACT_NUM_DICT. Returns: wb_obj ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 @util . time_it def gen_new_xlfile ( xl_template_filename : str , output_filename : str , date_interest : datetime . datetime , signal_result_dict : dict , cell_loc_dict : dict = CELL_LOC_DICT , contract_num_dict : dict = CONTRACT_NUM_DICT ): \"\"\" Generate a new excel file. Parameters ---------- xl_template_filename : TYPE DESCRIPTION. output_filename : TYPE DESCRIPTION. date_interest : TYPE DESCRIPTION. signal_result_dict : TYPE DESCRIPTION. cell_loc_dict : TYPE, optional DESCRIPTION. The default is CELL_LOC_DICT. contract_num_dict : TYPE, optional DESCRIPTION. The default is CONTRACT_NUM_DICT. Returns ------- wb_obj : TYPE DESCRIPTION. \"\"\" wb_obj = openpyxl . load_workbook ( xl_template_filename ) wb_obj = enter_new_value ( wb_obj , date_interest , cell_loc_dict , signal_result_dict , contract_num_dict , output_filename ) wb_obj . save ( output_filename ) return wb_obj","title":"gen_new_xlfile"},{"location":"app/run_daily_instruction/#app.run_daily_instruction.make_new_symbol","text":"A function that generate a new price symbol based on the month and year of today. Parameters: date_interest ( datetime ) \u2013 DESCRIPTION. old_symbol ( str ) \u2013 DESCRIPTION. forward_unit ( int , default: 1 ) \u2013 DESCRIPTION. The default is 1. Returns: str \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def make_new_symbol ( date_interest : datetime . datetime , old_symbol : str , forward_unit : int = 1 ) -> str : \"\"\" A function that generate a new price symbol based on the month and year of today. Parameters ---------- date_interest : datetime.datetime DESCRIPTION. old_symbol : str DESCRIPTION. forward_unit : int, optional DESCRIPTION. The default is 1. Returns ------- str DESCRIPTION. \"\"\" month_str = str ( date_interest . month + forward_unit ) year_str = str ( date_interest . year ) new_symbol = old_symbol [ 0 : 2 ] + MONTHS_TO_SYMBOLS [ month_str ] + year_str [ - 2 :] return new_symbol","title":"make_new_symbol"},{"location":"app/run_daily_instruction/#app.run_daily_instruction.run_MR_list","text":"Run MR stratgy in a list. Parameters: start_date ( TYPE ) \u2013 DESCRIPTION. start_date_2 ( TYPE ) \u2013 DESCRIPTION. end_date ( TYPE ) \u2013 DESCRIPTION. Returns: A ( TYPE ) \u2013 DESCRIPTION. Source code in app/run_daily_instruction.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @util . time_it def run_MR_list ( start_date , end_date , MR_method = run_gen_MR_signals_preloaded_list ): \"\"\" Run MR stratgy in a list. Parameters ---------- start_date : TYPE DESCRIPTION. start_date_2 : TYPE DESCRIPTION. end_date : TYPE DESCRIPTION. Returns ------- A : TYPE DESCRIPTION. \"\"\" SAVE_SIGNAL_FILENAME_LIST = TEST_FILE_LOC result = MR_method ( SAVE_SIGNAL_FILENAME_LIST , start_date , end_date , SIGNAL_PKL , HISTORY_DAILY_PKL , OPENPRICE_PKL , save_or_not = False ) return result","title":"run_MR_list"},{"location":"app/run_data_management/","text":"Run Data Management Created on Sat Jun 22 21:31:35 2024 @author: dexter","title":"Run Data Management"},{"location":"app/run_data_management/#run-data-management","text":"Created on Sat Jun 22 21:31:35 2024 @author: dexter","title":"Run Data Management"},{"location":"app/run_gen_MR_dir/","text":"Run Generate daily MR signals Created on Wed Mar 13 19:51:24 2024 @author: dexter A modified script based on the Mean-Reversion Method developed by Abbe Whitford. loop_signal ( strategy , book , signal_data , history_data , open_price_data , start_date , end_date , buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 ), open_hr = '' , close_hr = '' , quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name = '' , Timezone = '' , contract_symbol_condse = False , loop_symbol = None ) The main loop used to generate Buy/Sell signals. Parameters: strategy ( strategy object ) \u2013 The function of signal generation from the strategy module. book ( bookkeep object ) \u2013 The bookkeeping object from the bookkeep module. signal_data ( dataframe ) \u2013 The dataframe of the signal data, e.g.the APCs. history_data ( dataframe ) \u2013 The dataframe of the history daily pricing data. open_price_data ( dataframe ) \u2013 The dataframe of the history opening pricing data. start_date ( datetime ) \u2013 The starting datetime. end_date ( datetime ) \u2013 The ending datetime. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr ( str , default: '' ) \u2013 A string for the opening hour for the loop in military format. The default is ''. close_hr ( str , default: '' ) \u2013 A string for the closing hour for the loop in military format. The default is ''. commodity_name ( str ) \u2013 The name of the asset in our test. The default is ''. Timezone ( str , default: '' ) \u2013 The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse ( bool , default: False ) \u2013 Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol ( str , default: None ) \u2013 The name of the loop to be printed. The default is None. Returns: dataframe \u2013 The generated signals Source code in app/run_gen_MR_dir.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def loop_signal ( strategy : type [ Strategy ], book : Bookkeep , signal_data : pd . DataFrame , history_data : pd . DataFrame , open_price_data : pd . DataFrame , start_date : datetime . datetime , end_date : datetime . datetime , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 ), open_hr : str = '' , close_hr : str = '' , quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name : str = '' , Timezone : str = \"\" , contract_symbol_condse : bool = False , loop_symbol : bool = None ) -> pd . DataFrame : \"\"\" The main loop used to generate Buy/Sell signals. Parameters ---------- strategy : strategy object The function of signal generation from the strategy module. book : bookkeep object The bookkeeping object from the bookkeep module. signal_data : dataframe The dataframe of the signal data, e.g.the APCs. history_data : dataframe The dataframe of the history daily pricing data. open_price_data : dataframe The dataframe of the history opening pricing data. start_date : datetime The starting datetime. end_date : datetime The ending datetime. buy_range : tuple, optional The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr : str, optional A string for the opening hour for the loop in military format. The default is ''. close_hr : str, optional A string for the closing hour for the loop in military format. The default is ''. commodity_name : str, optional The name of the asset in our test. The default is ''. Timezone : str, optional The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse : bool, optional Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol : str, optional The name of the loop to be printed. The default is None. Returns ------- dataframe The generated signals \"\"\" #make bucket bucket = book . make_bucket ( keyword = strategy () . strategy_name ,) # 'argus_exact_mode')# print ( 'Start looping signal: {} ...' . format ( loop_symbol )) # Find the index of the start_date and end_date here. start_index = history_data . index [ history_data [ 'Date' ] == start_date ] . item () end_index = history_data . index [ history_data [ 'Date' ] == end_date ] . item () # loop through every forecast date and contract symbol for i in np . arange ( start_index , end_index ): this_date = history_data [ \"Date\" ][ i ] this_symbol = history_data [ \"symbol\" ][ i ] # cross reference the APC list to get the APC of this date and symbol APCs_this_date = signal_data [( signal_data [ 'PERIOD' ] == this_date )] # & (APCs_dat['symbol']== this_symbol)] #<-- here add a condition matching the symbols if len ( APCs_this_date ) == 0 : print ( \"APC data of {} from the date {} is missing\" . \\ format ( this_symbol , this_date . date ())) else : #print(this_date, this_symbol, APCs_this_date['Forecast Period'].iloc[0]) forecast_date = APCs_this_date [ 'PERIOD' ] . to_list ()[ 0 ] # This is the APC number only curve_this_date = APCs_this_date . to_numpy ()[ 0 ][ - 1 - APC_LENGTH : - 1 ] # create input for bookkepping price_code = APCs_this_date [ 'symbol' ] . to_list ()[ 0 ] # find the quantile of the opening price price_330 = open_price_data [ open_price_data [ 'Date' ] == this_date ] \\ [ 'Open Price' ] . item () # The conidtions to decide whether we trim the full_contract_symbol # CLA2024J or CL24J if contract_symbol_condse == True : temp = history_data [ 'Contract Code' ][ i ] full_contract_symbol = str ( temp )[ 0 : 2 ] + str ( temp )[ 5 : 7 ] + str ( temp )[ - 1 ] elif contract_symbol_condse == False : full_contract_symbol = history_data [ 'Contract Code' ][ i ] # Get the extracted 5 days Lag data. This is the main input to be # put into the Stragey function apc_curve_lag5 , history_data_lag5 = read . extract_lag_data ( \\ signal_data , history_data , forecast_date , lag_size = 5 ) # Apply the strategy, The Strategy is variable strategy_output = strategy ( curve_this_date ) . \\ apply_strategy ( history_data_lag5 , apc_curve_lag5 , price_330 , buy_range = buy_range , sell_range = sell_range , quantile = quantile ) print ( '====================================' ) print ( forecast_date , full_contract_symbol , 'MR signal generated!' , strategy_output [ 'direction' ], i ) # make a list of data to be written into bookkeep static_info = [ asset_name , full_contract_symbol , \\ Timezone , open_hr , close_hr ] # put all the data in a singular list data = [ forecast_date , price_code ] + \\ [ strategy_output [ 'direction' ]] + \\ static_info + strategy_output [ 'data' ] #print(\"data\", data, len(data)) # Storing the data bucket = book . store_to_bucket_single ( data ) dict_contracts_quant_signals = pd . DataFrame ( bucket ) #sort by date (the first column) dict_contracts_quant_signals = dict_contracts_quant_signals . sort_values ( by = dict_contracts_quant_signals . columns . values [ 0 ]) return dict_contracts_quant_signals run_gen_MR_signals ( strategy , asset_pack , signal_filename , filename_daily , filename_minute , start_date , end_date , buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 ), open_hr = '' , close_hr = '' , qunatile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name = '' , Timezone = '' , start_date_pushback = 20 ) The main function that generate MeanRversion signals. This particular method uses the bookkeep module to generate CSV file as outputs. Parameters: asset_pack ( dict ) \u2013 A dict that contains the symbol and the asset name. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. signal_filename ( str ) \u2013 The filename for the forecasting signals. filename_daily ( str ) \u2013 The filename for the historical daily price data. filename_minute ( str ) \u2013 The filename for the historical minute price data. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr ( str , default: '' ) \u2013 The opening hour. The default is ''. close_hr ( str , default: '' ) \u2013 The closing hour. The default is ''. qunatile ( list , default: [0.05, 0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9, 0.95] ) \u2013 asset_name ( str , default: '' ) \u2013 The asset name to be recoreded in the bookkeep object. The default is ''. Timezone ( str , default: '' ) \u2013 The name of the Time Zone. The default is \"\". start_date_pushback ( int , default: 20 ) \u2013 The number of days to push back before the given start date. This is necessary for strategies that use lag day data to produce trading signals The default is 20 (days). Returns: dataframe \u2013 The result dataframe for bookkeep. Source code in app/run_gen_MR_dir.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def run_gen_MR_signals ( strategy : type [ Strategy ], asset_pack : dict , signal_filename : str , filename_daily : str , filename_minute : str , start_date : str , end_date : str , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 ), open_hr : str = '' , close_hr : str = '' , qunatile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name : str = '' , Timezone : str = \"\" , start_date_pushback : int = 20 ) -> pd . DataFrame : \"\"\" The main function that generate MeanRversion signals. This particular method uses the bookkeep module to generate CSV file as outputs. Parameters ---------- asset_pack : dict A dict that contains the symbol and the asset name. start_date : str The starting date. end_date : str The ending date. signal_filename : str The filename for the forecasting signals. filename_daily : str The filename for the historical daily price data. filename_minute : str The filename for the historical minute price data. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr : str, optional The opening hour. The default is ''. close_hr : str, optional The closing hour. The default is ''. qunatile : list asset_name : str, optional The asset name to be recoreded in the bookkeep object. The default is ''. Timezone : str, optional The name of the Time Zone. The default is \"\". start_date_pushback : int, optional The number of days to push back before the given start date. This is necessary for strategies that use lag day data to produce trading signals The default is 20 (days). Returns ------- dataframe The result dataframe for bookkeep. \"\"\" symbol , asset_name = asset_pack [ 'symbol' ], asset_pack [ 'keywords' ] # The reading part takes the longest time: 13 seconds. The loop itself takes # input 1, APC. Load the master table in memory and test multple strategies signal_data = read . read_reformat_APC_data ( signal_filename ) # input 2, Portara history file. # start_date2 is a temporary solution history_data_daily = read . read_reformat_Portara_daily_data ( filename_daily ) history_data_minute = read . read_reformat_Portara_minute_data ( filename_minute ) # Add a symbol column history_data_daily [ 'symbol' ] = [ symbol for i in range ( len ( history_data_daily ))] history_data_minute [ 'symbol' ] = [ symbol for i in range ( len ( history_data_minute ))] # Find the opening price at 03:30 UK time. If not found, #loop through the next 30 minutes to find the opening price #price_330 = read.find_open_price(history_data_daily, history_data_minute) price_330 = read . find_price_by_time ( history_data_daily , history_data_minute , open_hr = OPEN_HR_DICT [ symbol ]) # make an empty signal dictionary for storage book = Bookkeep ( bucket_type = 'mr_signals' ) start_date_lag = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) - \\ datetime . timedelta ( days = start_date_pushback ) start_date = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) end_date = datetime . datetime . strptime ( end_date , '%Y-%m- %d ' ) # Define a small window of interest APCs_dat = signal_data [( signal_data [ 'PERIOD' ] >= start_date_lag ) & ( signal_data [ 'PERIOD' ] <= end_date )] portara_dat = history_data_daily [( history_data_daily [ 'Date' ] >= start_date_lag ) & ( history_data_daily [ 'Date' ] <= end_date )] open_price_data = price_330 [( price_330 [ 'Date' ] >= start_date_lag ) & ( price_330 [ 'Date' ] <= end_date )] #print(APCs_dat, portara_dat, open_price_data) # The strategy will be ran in loop_signal decorator dict_contracts_quant_signals = loop_signal ( strategy , book , APCs_dat , portara_dat , open_price_data , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , qunatile = qunatile , asset_name = asset_name , Timezone = Timezone , loop_symbol = symbol ) dict_contracts_quant_signals = pd . DataFrame ( dict_contracts_quant_signals ) #sort by date dict_contracts_quant_signals = dict_contracts_quant_signals . \\ sort_values ( by = 'Date' ) return dict_contracts_quant_signals run_gen_MR_signals_list ( strategy , filename_list , categories_list , keywords_list , symbol_list , signal_list , history_daily_list , history_minute_list , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = ([ 0.25 , 0.4 ], [ 0.6 , 0.75 ], 0.05 ), sell_range = ([ 0.6 , 0.75 ], [ 0.25 , 0.4 ], 0.95 ), quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not = False ) A method that run Mean Reversion signal generation form a list of inputs. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters: Strategy ( strategy object ) \u2013 The strategy function that is used to generate the trade signals. filename_list ( list ) \u2013 The saved filename list. categories_list ( list ) \u2013 A list containing categories keywords. keywords_list ( list ) \u2013 A list of keywords. signal_list ( list ) \u2013 A list of signal data filename. history_daily_list ( list ) \u2013 A list of history daily pricing data filename. history_minute_list ( list ) \u2013 history minute pricing data filename. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict ) \u2013 A dictionary for the input opening hour strings. close_hr_dict ( dict ) \u2013 A dictionary for the input closing hour strings. timezone_dict ( dict ) \u2013 A dictionary for the Time Zone name strings. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not ( bool , default: False ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: dict \u2013 The resuting dictionary for all the signals for different assets. Source code in app/run_gen_MR_dir.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @util . time_it def run_gen_MR_signals_list ( strategy : type [ Strategy ], filename_list : list [ str ], categories_list : list [ str ], keywords_list : list [ str ], symbol_list : list [ str ], signal_list : list , history_daily_list : list , history_minute_list : list , start_date : str , end_date : str , open_hr_dict : dict , close_hr_dict : dict , timezone_dict : dict , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not : bool = False ) -> dict : \"\"\" A method that run Mean Reversion signal generation form a list of inputs. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters ---------- Strategy : strategy object The strategy function that is used to generate the trade signals. filename_list : list The saved filename list. categories_list : list A list containing categories keywords. keywords_list : list A list of keywords. signal_list : list A list of signal data filename. history_daily_list : list A list of history daily pricing data filename. history_minute_list : list history minute pricing data filename. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. close_hr_dict : dict A dictionary for the input closing hour strings. timezone_dict : dict A dictionary for the Time Zone name strings. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- dict The resuting dictionary for all the signals for different assets. \"\"\" output_dict = dict () for filename , cat , key , sym , signal , history_daily , history_minute in zip ( \\ filename_list , categories_list , keywords_list , symbol_list , signal_list , \\ history_daily_list , history_minute_list ): print ( \"filename\" , filename ) @util . time_it @util . save_csv ( \" {} \" . format ( filename ), save_or_not = save_or_not ) def run_gen_MR_signals_indi ( cat : str , key : str , sym : str ): asset_pack = { 'categories' : cat , 'keywords' : key , 'symbol' : sym } open_hr = open_hr_dict [ sym ] close_hr = close_hr_dict [ sym ] Timezone = timezone_dict [ sym ] print ( \"files\" , signal , history_daily , history_minute ) signal_data = run_gen_MR_signals ( strategy , asset_pack , signal , history_daily , history_minute , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , asset_name = key , Timezone = Timezone ) #WIP print ( \"name {} \" . format ( filename )) return signal_data signal_data = run_gen_MR_signals_indi ( cat , key , sym ) output_dict [ sym ] = signal_data print ( \"All asset signal generated!\" ) return output_dict run_gen_MR_signals_preloaded ( strategy , filename_list , signal_pkl , history_daily_pkl , openprice_pkl , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = ( 0.4 , 0.6 , 0.1 ), sell_range = ( 0.6 , 0.4 , 0.9 ), quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not = True ) A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters: Strategy ( strategy object ) \u2013 The strategy function in use in generating the signal. filename_list ( list ) \u2013 The saved filename list. signal_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict ) \u2013 A dictionary for the input opening hour strings. close_hr_dict ( dict ) \u2013 A dictionary for the input closing hour strings. timezone_dict ( dict ) \u2013 A dictionary for the Time Zone name strings. buy_range ( tuple , default: (0.4, 0.6, 0.1) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: (0.6, 0.4, 0.9) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not ( bool , default: True ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: dataframe \u2013 signal data. Source code in app/run_gen_MR_dir.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @util . time_it def run_gen_MR_signals_preloaded ( strategy : type [ Strategy ], filename_list : list [ str ], signal_pkl : dict , history_daily_pkl : dict , openprice_pkl : dict , start_date : str , end_date : str , open_hr_dict : dict , close_hr_dict : dict , timezone_dict : dict , buy_range : tuple [ float ] = ( 0.4 , 0.6 , 0.1 ), sell_range : tuple [ float ] = ( 0.6 , 0.4 , 0.9 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not : bool = True ) -> pd . DataFrame : \"\"\" A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters ---------- Strategy : strategy object The strategy function in use in generating the signal. filename_list : list The saved filename list. signal_pkl : dict A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl : dict A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl : dict A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. close_hr_dict : dict A dictionary for the input closing hour strings. timezone_dict : dict A dictionary for the Time Zone name strings. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- dataframe signal data. \"\"\" # run meanreversion signal generation on the basis of individual programme # Loop the whole list in one go with all the contracts or Loop it one contract at a time? master_dict , symbol_list = dict (), list ( signal_pkl . keys ()) print ( symbol_list , filename_list ) for symbol in symbol_list : filename = filename_list [ symbol ] # The reading part takes the longest time: 13 seconds. The loop itself takes # input 1, APC. Load the master table in memory and test multple strategies @util . save_csv ( \" {} \" . format ( filename ), save_or_not = save_or_not ) def run_gen_MR_indi (): book = Bookkeep ( bucket_type = 'mr_signals' ) print ( \"symbol\" , symbol ) #signal file input signal_file = signal_pkl [ symbol ] # input 2, Portara history file. history_daily_file = history_daily_pkl [ symbol ] #history_minute_file = history_minute_pkl[symbol] # Find the opening price at 03:30 UK time. If not found, # loop through the next 30 minutes to find the opening price open_price = openprice_pkl [ symbol ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] Timezone = timezone_dict [ symbol ] # The strategy will be ran in loop_signal decorator dict_contracts_quant_signals = loop_signal ( strategy , book , signal_file , history_daily_file , open_price , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , quantile = quantile , asset_name = symbol , Timezone = Timezone , loop_symbol = symbol ) return dict_contracts_quant_signals master_dict [ symbol ] = run_gen_MR_indi () return master_dict run_gen_signal_bulk ( strategy , save_filename_loc , start_date , end_date , open_hr_dict = OPEN_HR_DICT , close_hr_dict = CLOSE_HR_DICT , timezone_dict = TIMEZONE_DICT , buy_range = ( 0.4 , 0.6 , 0.1 ), sell_range = ( 0.6 , 0.4 , 0.9 ), quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], runtype = 'list' , master_signal_filename = 'master_signal.csv' , merge_or_not = True , save_or_not = False ) A method that runs signal generations in bulk. This functions allows you to choose from euther Parameters: Strategy ( strategy object ) \u2013 The strategy function in use in generating the signal. save_filename_loc ( dict ) \u2013 The saved filename dictionary corresponding to the name of the asset. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict , default: OPEN_HR_DICT ) \u2013 A dictionary for the input opening hour strings. The default is = OPEN_HR_DICT close_hr_dict ( dict , default: CLOSE_HR_DICT ) \u2013 A dictionary for the input closing hour strings. The default is = CLOSE_HR_DICT timezone_dict ( dict , default: TIMEZONE_DICT ) \u2013 dictionary for the Time Zone name strings. The default is TIMEZONE_DICT. buy_range ( tuple [ float ] , default: (0.4, 0.6, 0.1) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is (0.4,0.6,0.1). sell_range ( tuple [ float ] , default: (0.6, 0.4, 0.9) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is (0.6,0.4,0.9). runtype ( str , default: 'list' ) \u2013 The name of the run_type. It determines the method to conduct the signal generation. It can be either 'list' or 'preload'. Each will run 'run_gen_MR_signals_list' or 'run_gen_MR_signals_preloaded', respectively. The default is 'list'. merge_or_not ( bool , default: True ) \u2013 A boolean value to decide whether to merge the results into one file or not. The default is True. save_or_not ( bool , default: False ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: None. \u2013 Source code in app/run_gen_MR_dir.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 def run_gen_signal_bulk ( strategy : type [ Strategy ], save_filename_loc : dict , start_date : str , end_date : str , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , timezone_dict : dict = TIMEZONE_DICT , buy_range : tuple [ float ] = ( 0.4 , 0.6 , 0.1 ), sell_range : tuple [ float ] = ( 0.6 , 0.4 , 0.9 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], runtype : str = 'list' , master_signal_filename : str = \"master_signal.csv\" , merge_or_not : bool = True , save_or_not : bool = False ) -> None : \"\"\" A method that runs signal generations in bulk. This functions allows you to choose from euther Parameters ---------- Strategy : strategy object The strategy function in use in generating the signal. save_filename_loc : dict The saved filename dictionary corresponding to the name of the asset. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. The default is = OPEN_HR_DICT close_hr_dict : dict A dictionary for the input closing hour strings. The default is = CLOSE_HR_DICT timezone_dict : dict, optional dictionary for the Time Zone name strings. The default is TIMEZONE_DICT. buy_range : tuple[float], optional The buy range in the format of (entry, exit, stop loss). The default is (0.4,0.6,0.1). sell_range : tuple[float], optional The sell range in the format of (entry, exit, stop loss). The default is (0.6,0.4,0.9). runtype : str, optional The name of the run_type. It determines the method to conduct the signal generation. It can be either 'list' or 'preload'. Each will run 'run_gen_MR_signals_list' or 'run_gen_MR_signals_preloaded', respectively. The default is 'list'. merge_or_not : bool, optional A boolean value to decide whether to merge the results into one file or not. The default is True. save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- None. \"\"\" if runtype == \"list\" : # Fixed input filename from constant variables SIGNAL_LIST = list ( APC_FILE_LOC . values ()) HISTORY_DAILY_LIST = list ( HISTORY_DAILY_FILE_LOC . values ()) HISTORY_MINUTE_LIST = list ( HISTORY_MINTUE_FILE_LOC . values ()) SAVE_FILENAME_LIST = list ( save_filename_loc . values ()) # Run signal generation in a list format run_gen_MR_signals_list ( strategy , SAVE_FILENAME_LIST , CAT_LIST , KEYWORDS_LIST , SYMBOL_LIST , SIGNAL_LIST , HISTORY_DAILY_LIST , HISTORY_MINUTE_LIST , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = buy_range , quantile = quantile , sell_range = sell_range , save_or_not = save_or_not ) if merge_or_not : #merge_filename = getpass.getpass(prompt=\"please enter the name for the merged file :\") MASTER_SIGNAL_FILENAME = master_signal_filename #MASTER_SIGNAL_FILENAME = RESULT_FILEPATH + merge_filename read . merge_raw_data ( SAVE_FILENAME_LIST , MASTER_SIGNAL_FILENAME , sort_by = \"Date\" ) elif runtype == 'preload' : # Fixed input filename from constant variables SIGNAL_PKL = util . load_pkl ( DATA_FILEPATH + \"/pkl_vault/crudeoil_future_APC_full.pkl\" ) HISTORY_DAILY_PKL = util . load_pkl ( DATA_FILEPATH + \"/pkl_vault/crudeoil_future_daily_full.pkl\" ) OPENPRICE_PKL = util . load_pkl ( DATA_FILEPATH + \"/pkl_vault/crudeoil_future_openprice_full.pkl\" ) SAVE_FILENAME_LIST = list ( save_filename_loc . values ()) # Run signal generation in a preloaded format run_gen_MR_signals_preloaded ( strategy , save_filename_loc , SIGNAL_PKL , HISTORY_DAILY_PKL , OPENPRICE_PKL , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = buy_range , quantile = quantile , sell_range = sell_range , save_or_not = save_or_not ) if merge_or_not : MASTER_SIGNAL_FILENAME = master_signal_filename read . merge_raw_data ( SAVE_FILENAME_LIST , MASTER_SIGNAL_FILENAME , sort_by = \"Date\" )","title":"Run Generate Daily MR signals"},{"location":"app/run_gen_MR_dir/#run-generate-daily-mr-signals","text":"Created on Wed Mar 13 19:51:24 2024 @author: dexter A modified script based on the Mean-Reversion Method developed by Abbe Whitford.","title":"Run Generate daily MR signals"},{"location":"app/run_gen_MR_dir/#app.run_gen_MR_dir.loop_signal","text":"The main loop used to generate Buy/Sell signals. Parameters: strategy ( strategy object ) \u2013 The function of signal generation from the strategy module. book ( bookkeep object ) \u2013 The bookkeeping object from the bookkeep module. signal_data ( dataframe ) \u2013 The dataframe of the signal data, e.g.the APCs. history_data ( dataframe ) \u2013 The dataframe of the history daily pricing data. open_price_data ( dataframe ) \u2013 The dataframe of the history opening pricing data. start_date ( datetime ) \u2013 The starting datetime. end_date ( datetime ) \u2013 The ending datetime. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr ( str , default: '' ) \u2013 A string for the opening hour for the loop in military format. The default is ''. close_hr ( str , default: '' ) \u2013 A string for the closing hour for the loop in military format. The default is ''. commodity_name ( str ) \u2013 The name of the asset in our test. The default is ''. Timezone ( str , default: '' ) \u2013 The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse ( bool , default: False ) \u2013 Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol ( str , default: None ) \u2013 The name of the loop to be printed. The default is None. Returns: dataframe \u2013 The generated signals Source code in app/run_gen_MR_dir.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def loop_signal ( strategy : type [ Strategy ], book : Bookkeep , signal_data : pd . DataFrame , history_data : pd . DataFrame , open_price_data : pd . DataFrame , start_date : datetime . datetime , end_date : datetime . datetime , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 ), open_hr : str = '' , close_hr : str = '' , quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name : str = '' , Timezone : str = \"\" , contract_symbol_condse : bool = False , loop_symbol : bool = None ) -> pd . DataFrame : \"\"\" The main loop used to generate Buy/Sell signals. Parameters ---------- strategy : strategy object The function of signal generation from the strategy module. book : bookkeep object The bookkeeping object from the bookkeep module. signal_data : dataframe The dataframe of the signal data, e.g.the APCs. history_data : dataframe The dataframe of the history daily pricing data. open_price_data : dataframe The dataframe of the history opening pricing data. start_date : datetime The starting datetime. end_date : datetime The ending datetime. buy_range : tuple, optional The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr : str, optional A string for the opening hour for the loop in military format. The default is ''. close_hr : str, optional A string for the closing hour for the loop in military format. The default is ''. commodity_name : str, optional The name of the asset in our test. The default is ''. Timezone : str, optional The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse : bool, optional Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol : str, optional The name of the loop to be printed. The default is None. Returns ------- dataframe The generated signals \"\"\" #make bucket bucket = book . make_bucket ( keyword = strategy () . strategy_name ,) # 'argus_exact_mode')# print ( 'Start looping signal: {} ...' . format ( loop_symbol )) # Find the index of the start_date and end_date here. start_index = history_data . index [ history_data [ 'Date' ] == start_date ] . item () end_index = history_data . index [ history_data [ 'Date' ] == end_date ] . item () # loop through every forecast date and contract symbol for i in np . arange ( start_index , end_index ): this_date = history_data [ \"Date\" ][ i ] this_symbol = history_data [ \"symbol\" ][ i ] # cross reference the APC list to get the APC of this date and symbol APCs_this_date = signal_data [( signal_data [ 'PERIOD' ] == this_date )] # & (APCs_dat['symbol']== this_symbol)] #<-- here add a condition matching the symbols if len ( APCs_this_date ) == 0 : print ( \"APC data of {} from the date {} is missing\" . \\ format ( this_symbol , this_date . date ())) else : #print(this_date, this_symbol, APCs_this_date['Forecast Period'].iloc[0]) forecast_date = APCs_this_date [ 'PERIOD' ] . to_list ()[ 0 ] # This is the APC number only curve_this_date = APCs_this_date . to_numpy ()[ 0 ][ - 1 - APC_LENGTH : - 1 ] # create input for bookkepping price_code = APCs_this_date [ 'symbol' ] . to_list ()[ 0 ] # find the quantile of the opening price price_330 = open_price_data [ open_price_data [ 'Date' ] == this_date ] \\ [ 'Open Price' ] . item () # The conidtions to decide whether we trim the full_contract_symbol # CLA2024J or CL24J if contract_symbol_condse == True : temp = history_data [ 'Contract Code' ][ i ] full_contract_symbol = str ( temp )[ 0 : 2 ] + str ( temp )[ 5 : 7 ] + str ( temp )[ - 1 ] elif contract_symbol_condse == False : full_contract_symbol = history_data [ 'Contract Code' ][ i ] # Get the extracted 5 days Lag data. This is the main input to be # put into the Stragey function apc_curve_lag5 , history_data_lag5 = read . extract_lag_data ( \\ signal_data , history_data , forecast_date , lag_size = 5 ) # Apply the strategy, The Strategy is variable strategy_output = strategy ( curve_this_date ) . \\ apply_strategy ( history_data_lag5 , apc_curve_lag5 , price_330 , buy_range = buy_range , sell_range = sell_range , quantile = quantile ) print ( '====================================' ) print ( forecast_date , full_contract_symbol , 'MR signal generated!' , strategy_output [ 'direction' ], i ) # make a list of data to be written into bookkeep static_info = [ asset_name , full_contract_symbol , \\ Timezone , open_hr , close_hr ] # put all the data in a singular list data = [ forecast_date , price_code ] + \\ [ strategy_output [ 'direction' ]] + \\ static_info + strategy_output [ 'data' ] #print(\"data\", data, len(data)) # Storing the data bucket = book . store_to_bucket_single ( data ) dict_contracts_quant_signals = pd . DataFrame ( bucket ) #sort by date (the first column) dict_contracts_quant_signals = dict_contracts_quant_signals . sort_values ( by = dict_contracts_quant_signals . columns . values [ 0 ]) return dict_contracts_quant_signals","title":"loop_signal"},{"location":"app/run_gen_MR_dir/#app.run_gen_MR_dir.run_gen_MR_signals","text":"The main function that generate MeanRversion signals. This particular method uses the bookkeep module to generate CSV file as outputs. Parameters: asset_pack ( dict ) \u2013 A dict that contains the symbol and the asset name. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. signal_filename ( str ) \u2013 The filename for the forecasting signals. filename_daily ( str ) \u2013 The filename for the historical daily price data. filename_minute ( str ) \u2013 The filename for the historical minute price data. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr ( str , default: '' ) \u2013 The opening hour. The default is ''. close_hr ( str , default: '' ) \u2013 The closing hour. The default is ''. qunatile ( list , default: [0.05, 0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9, 0.95] ) \u2013 asset_name ( str , default: '' ) \u2013 The asset name to be recoreded in the bookkeep object. The default is ''. Timezone ( str , default: '' ) \u2013 The name of the Time Zone. The default is \"\". start_date_pushback ( int , default: 20 ) \u2013 The number of days to push back before the given start date. This is necessary for strategies that use lag day data to produce trading signals The default is 20 (days). Returns: dataframe \u2013 The result dataframe for bookkeep. Source code in app/run_gen_MR_dir.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def run_gen_MR_signals ( strategy : type [ Strategy ], asset_pack : dict , signal_filename : str , filename_daily : str , filename_minute : str , start_date : str , end_date : str , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 ), open_hr : str = '' , close_hr : str = '' , qunatile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name : str = '' , Timezone : str = \"\" , start_date_pushback : int = 20 ) -> pd . DataFrame : \"\"\" The main function that generate MeanRversion signals. This particular method uses the bookkeep module to generate CSV file as outputs. Parameters ---------- asset_pack : dict A dict that contains the symbol and the asset name. start_date : str The starting date. end_date : str The ending date. signal_filename : str The filename for the forecasting signals. filename_daily : str The filename for the historical daily price data. filename_minute : str The filename for the historical minute price data. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr : str, optional The opening hour. The default is ''. close_hr : str, optional The closing hour. The default is ''. qunatile : list asset_name : str, optional The asset name to be recoreded in the bookkeep object. The default is ''. Timezone : str, optional The name of the Time Zone. The default is \"\". start_date_pushback : int, optional The number of days to push back before the given start date. This is necessary for strategies that use lag day data to produce trading signals The default is 20 (days). Returns ------- dataframe The result dataframe for bookkeep. \"\"\" symbol , asset_name = asset_pack [ 'symbol' ], asset_pack [ 'keywords' ] # The reading part takes the longest time: 13 seconds. The loop itself takes # input 1, APC. Load the master table in memory and test multple strategies signal_data = read . read_reformat_APC_data ( signal_filename ) # input 2, Portara history file. # start_date2 is a temporary solution history_data_daily = read . read_reformat_Portara_daily_data ( filename_daily ) history_data_minute = read . read_reformat_Portara_minute_data ( filename_minute ) # Add a symbol column history_data_daily [ 'symbol' ] = [ symbol for i in range ( len ( history_data_daily ))] history_data_minute [ 'symbol' ] = [ symbol for i in range ( len ( history_data_minute ))] # Find the opening price at 03:30 UK time. If not found, #loop through the next 30 minutes to find the opening price #price_330 = read.find_open_price(history_data_daily, history_data_minute) price_330 = read . find_price_by_time ( history_data_daily , history_data_minute , open_hr = OPEN_HR_DICT [ symbol ]) # make an empty signal dictionary for storage book = Bookkeep ( bucket_type = 'mr_signals' ) start_date_lag = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) - \\ datetime . timedelta ( days = start_date_pushback ) start_date = datetime . datetime . strptime ( start_date , '%Y-%m- %d ' ) end_date = datetime . datetime . strptime ( end_date , '%Y-%m- %d ' ) # Define a small window of interest APCs_dat = signal_data [( signal_data [ 'PERIOD' ] >= start_date_lag ) & ( signal_data [ 'PERIOD' ] <= end_date )] portara_dat = history_data_daily [( history_data_daily [ 'Date' ] >= start_date_lag ) & ( history_data_daily [ 'Date' ] <= end_date )] open_price_data = price_330 [( price_330 [ 'Date' ] >= start_date_lag ) & ( price_330 [ 'Date' ] <= end_date )] #print(APCs_dat, portara_dat, open_price_data) # The strategy will be ran in loop_signal decorator dict_contracts_quant_signals = loop_signal ( strategy , book , APCs_dat , portara_dat , open_price_data , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , qunatile = qunatile , asset_name = asset_name , Timezone = Timezone , loop_symbol = symbol ) dict_contracts_quant_signals = pd . DataFrame ( dict_contracts_quant_signals ) #sort by date dict_contracts_quant_signals = dict_contracts_quant_signals . \\ sort_values ( by = 'Date' ) return dict_contracts_quant_signals","title":"run_gen_MR_signals"},{"location":"app/run_gen_MR_dir/#app.run_gen_MR_dir.run_gen_MR_signals_list","text":"A method that run Mean Reversion signal generation form a list of inputs. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters: Strategy ( strategy object ) \u2013 The strategy function that is used to generate the trade signals. filename_list ( list ) \u2013 The saved filename list. categories_list ( list ) \u2013 A list containing categories keywords. keywords_list ( list ) \u2013 A list of keywords. signal_list ( list ) \u2013 A list of signal data filename. history_daily_list ( list ) \u2013 A list of history daily pricing data filename. history_minute_list ( list ) \u2013 history minute pricing data filename. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict ) \u2013 A dictionary for the input opening hour strings. close_hr_dict ( dict ) \u2013 A dictionary for the input closing hour strings. timezone_dict ( dict ) \u2013 A dictionary for the Time Zone name strings. buy_range ( tuple , default: ([0.25, 0.4], [0.6, 0.75], 0.05) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.6, 0.75], [0.25, 0.4], 0.95) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not ( bool , default: False ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: dict \u2013 The resuting dictionary for all the signals for different assets. Source code in app/run_gen_MR_dir.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @util . time_it def run_gen_MR_signals_list ( strategy : type [ Strategy ], filename_list : list [ str ], categories_list : list [ str ], keywords_list : list [ str ], symbol_list : list [ str ], signal_list : list , history_daily_list : list , history_minute_list : list , start_date : str , end_date : str , open_hr_dict : dict , close_hr_dict : dict , timezone_dict : dict , buy_range : tuple = ([ 0.25 , 0.4 ],[ 0.6 , 0.75 ], 0.05 ), sell_range : tuple = ([ 0.6 , 0.75 ],[ 0.25 , 0.4 ], 0.95 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not : bool = False ) -> dict : \"\"\" A method that run Mean Reversion signal generation form a list of inputs. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters ---------- Strategy : strategy object The strategy function that is used to generate the trade signals. filename_list : list The saved filename list. categories_list : list A list containing categories keywords. keywords_list : list A list of keywords. signal_list : list A list of signal data filename. history_daily_list : list A list of history daily pricing data filename. history_minute_list : list history minute pricing data filename. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. close_hr_dict : dict A dictionary for the input closing hour strings. timezone_dict : dict A dictionary for the Time Zone name strings. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- dict The resuting dictionary for all the signals for different assets. \"\"\" output_dict = dict () for filename , cat , key , sym , signal , history_daily , history_minute in zip ( \\ filename_list , categories_list , keywords_list , symbol_list , signal_list , \\ history_daily_list , history_minute_list ): print ( \"filename\" , filename ) @util . time_it @util . save_csv ( \" {} \" . format ( filename ), save_or_not = save_or_not ) def run_gen_MR_signals_indi ( cat : str , key : str , sym : str ): asset_pack = { 'categories' : cat , 'keywords' : key , 'symbol' : sym } open_hr = open_hr_dict [ sym ] close_hr = close_hr_dict [ sym ] Timezone = timezone_dict [ sym ] print ( \"files\" , signal , history_daily , history_minute ) signal_data = run_gen_MR_signals ( strategy , asset_pack , signal , history_daily , history_minute , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , asset_name = key , Timezone = Timezone ) #WIP print ( \"name {} \" . format ( filename )) return signal_data signal_data = run_gen_MR_signals_indi ( cat , key , sym ) output_dict [ sym ] = signal_data print ( \"All asset signal generated!\" ) return output_dict","title":"run_gen_MR_signals_list"},{"location":"app/run_gen_MR_dir/#app.run_gen_MR_dir.run_gen_MR_signals_preloaded","text":"A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters: Strategy ( strategy object ) \u2013 The strategy function in use in generating the signal. filename_list ( list ) \u2013 The saved filename list. signal_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict ) \u2013 A dictionary for the input opening hour strings. close_hr_dict ( dict ) \u2013 A dictionary for the input closing hour strings. timezone_dict ( dict ) \u2013 A dictionary for the Time Zone name strings. buy_range ( tuple , default: (0.4, 0.6, 0.1) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: (0.6, 0.4, 0.9) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not ( bool , default: True ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: dataframe \u2013 signal data. Source code in app/run_gen_MR_dir.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @util . time_it def run_gen_MR_signals_preloaded ( strategy : type [ Strategy ], filename_list : list [ str ], signal_pkl : dict , history_daily_pkl : dict , openprice_pkl : dict , start_date : str , end_date : str , open_hr_dict : dict , close_hr_dict : dict , timezone_dict : dict , buy_range : tuple [ float ] = ( 0.4 , 0.6 , 0.1 ), sell_range : tuple [ float ] = ( 0.6 , 0.4 , 0.9 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not : bool = True ) -> pd . DataFrame : \"\"\" A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters ---------- Strategy : strategy object The strategy function in use in generating the signal. filename_list : list The saved filename list. signal_pkl : dict A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl : dict A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl : dict A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. close_hr_dict : dict A dictionary for the input closing hour strings. timezone_dict : dict A dictionary for the Time Zone name strings. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- dataframe signal data. \"\"\" # run meanreversion signal generation on the basis of individual programme # Loop the whole list in one go with all the contracts or Loop it one contract at a time? master_dict , symbol_list = dict (), list ( signal_pkl . keys ()) print ( symbol_list , filename_list ) for symbol in symbol_list : filename = filename_list [ symbol ] # The reading part takes the longest time: 13 seconds. The loop itself takes # input 1, APC. Load the master table in memory and test multple strategies @util . save_csv ( \" {} \" . format ( filename ), save_or_not = save_or_not ) def run_gen_MR_indi (): book = Bookkeep ( bucket_type = 'mr_signals' ) print ( \"symbol\" , symbol ) #signal file input signal_file = signal_pkl [ symbol ] # input 2, Portara history file. history_daily_file = history_daily_pkl [ symbol ] #history_minute_file = history_minute_pkl[symbol] # Find the opening price at 03:30 UK time. If not found, # loop through the next 30 minutes to find the opening price open_price = openprice_pkl [ symbol ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] Timezone = timezone_dict [ symbol ] # The strategy will be ran in loop_signal decorator dict_contracts_quant_signals = loop_signal ( strategy , book , signal_file , history_daily_file , open_price , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , quantile = quantile , asset_name = symbol , Timezone = Timezone , loop_symbol = symbol ) return dict_contracts_quant_signals master_dict [ symbol ] = run_gen_MR_indi () return master_dict","title":"run_gen_MR_signals_preloaded"},{"location":"app/run_gen_MR_dir/#app.run_gen_MR_dir.run_gen_signal_bulk","text":"A method that runs signal generations in bulk. This functions allows you to choose from euther Parameters: Strategy ( strategy object ) \u2013 The strategy function in use in generating the signal. save_filename_loc ( dict ) \u2013 The saved filename dictionary corresponding to the name of the asset. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict , default: OPEN_HR_DICT ) \u2013 A dictionary for the input opening hour strings. The default is = OPEN_HR_DICT close_hr_dict ( dict , default: CLOSE_HR_DICT ) \u2013 A dictionary for the input closing hour strings. The default is = CLOSE_HR_DICT timezone_dict ( dict , default: TIMEZONE_DICT ) \u2013 dictionary for the Time Zone name strings. The default is TIMEZONE_DICT. buy_range ( tuple [ float ] , default: (0.4, 0.6, 0.1) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is (0.4,0.6,0.1). sell_range ( tuple [ float ] , default: (0.6, 0.4, 0.9) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is (0.6,0.4,0.9). runtype ( str , default: 'list' ) \u2013 The name of the run_type. It determines the method to conduct the signal generation. It can be either 'list' or 'preload'. Each will run 'run_gen_MR_signals_list' or 'run_gen_MR_signals_preloaded', respectively. The default is 'list'. merge_or_not ( bool , default: True ) \u2013 A boolean value to decide whether to merge the results into one file or not. The default is True. save_or_not ( bool , default: False ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: None. \u2013 Source code in app/run_gen_MR_dir.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 def run_gen_signal_bulk ( strategy : type [ Strategy ], save_filename_loc : dict , start_date : str , end_date : str , open_hr_dict : dict = OPEN_HR_DICT , close_hr_dict : dict = CLOSE_HR_DICT , timezone_dict : dict = TIMEZONE_DICT , buy_range : tuple [ float ] = ( 0.4 , 0.6 , 0.1 ), sell_range : tuple [ float ] = ( 0.6 , 0.4 , 0.9 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], runtype : str = 'list' , master_signal_filename : str = \"master_signal.csv\" , merge_or_not : bool = True , save_or_not : bool = False ) -> None : \"\"\" A method that runs signal generations in bulk. This functions allows you to choose from euther Parameters ---------- Strategy : strategy object The strategy function in use in generating the signal. save_filename_loc : dict The saved filename dictionary corresponding to the name of the asset. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. The default is = OPEN_HR_DICT close_hr_dict : dict A dictionary for the input closing hour strings. The default is = CLOSE_HR_DICT timezone_dict : dict, optional dictionary for the Time Zone name strings. The default is TIMEZONE_DICT. buy_range : tuple[float], optional The buy range in the format of (entry, exit, stop loss). The default is (0.4,0.6,0.1). sell_range : tuple[float], optional The sell range in the format of (entry, exit, stop loss). The default is (0.6,0.4,0.9). runtype : str, optional The name of the run_type. It determines the method to conduct the signal generation. It can be either 'list' or 'preload'. Each will run 'run_gen_MR_signals_list' or 'run_gen_MR_signals_preloaded', respectively. The default is 'list'. merge_or_not : bool, optional A boolean value to decide whether to merge the results into one file or not. The default is True. save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- None. \"\"\" if runtype == \"list\" : # Fixed input filename from constant variables SIGNAL_LIST = list ( APC_FILE_LOC . values ()) HISTORY_DAILY_LIST = list ( HISTORY_DAILY_FILE_LOC . values ()) HISTORY_MINUTE_LIST = list ( HISTORY_MINTUE_FILE_LOC . values ()) SAVE_FILENAME_LIST = list ( save_filename_loc . values ()) # Run signal generation in a list format run_gen_MR_signals_list ( strategy , SAVE_FILENAME_LIST , CAT_LIST , KEYWORDS_LIST , SYMBOL_LIST , SIGNAL_LIST , HISTORY_DAILY_LIST , HISTORY_MINUTE_LIST , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = buy_range , quantile = quantile , sell_range = sell_range , save_or_not = save_or_not ) if merge_or_not : #merge_filename = getpass.getpass(prompt=\"please enter the name for the merged file :\") MASTER_SIGNAL_FILENAME = master_signal_filename #MASTER_SIGNAL_FILENAME = RESULT_FILEPATH + merge_filename read . merge_raw_data ( SAVE_FILENAME_LIST , MASTER_SIGNAL_FILENAME , sort_by = \"Date\" ) elif runtype == 'preload' : # Fixed input filename from constant variables SIGNAL_PKL = util . load_pkl ( DATA_FILEPATH + \"/pkl_vault/crudeoil_future_APC_full.pkl\" ) HISTORY_DAILY_PKL = util . load_pkl ( DATA_FILEPATH + \"/pkl_vault/crudeoil_future_daily_full.pkl\" ) OPENPRICE_PKL = util . load_pkl ( DATA_FILEPATH + \"/pkl_vault/crudeoil_future_openprice_full.pkl\" ) SAVE_FILENAME_LIST = list ( save_filename_loc . values ()) # Run signal generation in a preloaded format run_gen_MR_signals_preloaded ( strategy , save_filename_loc , SIGNAL_PKL , HISTORY_DAILY_PKL , OPENPRICE_PKL , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = buy_range , quantile = quantile , sell_range = sell_range , save_or_not = save_or_not ) if merge_or_not : MASTER_SIGNAL_FILENAME = master_signal_filename read . merge_raw_data ( SAVE_FILENAME_LIST , MASTER_SIGNAL_FILENAME , sort_by = \"Date\" )","title":"run_gen_signal_bulk"},{"location":"app/run_gen_monthly_MR_dir/","text":"Run Generate Monthly MR signals Created on Mon Sep 16 12:42:50 2024 @author: dexter loop_signal ( strategy , book , signal_daily_data , signal_monthly_data , history_data , daily_cumavg_data , start_date , end_date , buy_range = ([ 0.1 , 0.35 ], [ 0.5 , 0.9 ], 0.05 ), sell_range = ([ 0.65 , 0.9 ], [ 0.1 , 0.5 ], 0.95 ), open_hr = '' , close_hr = '' , quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name = '' , Timezone = '' , contract_symbol_condse = False , loop_symbol = None ) The main loop used to generate Buy/Sell signals. Parameters: strategy ( strategy object ) \u2013 The function of signal generation from the strategy module. book ( bookkeep object ) \u2013 The bookkeeping object from the bookkeep module. signal_data ( dataframe ) \u2013 The dataframe of the signal data, e.g.the APCs. history_data ( dataframe ) \u2013 The dataframe of the history daily pricing data. open_price_data ( dataframe ) \u2013 The dataframe of the history opening pricing data. start_date ( datetime ) \u2013 The starting datetime. end_date ( datetime ) \u2013 The ending datetime. buy_range ( tuple , default: ([0.1, 0.35], [0.5, 0.9], 0.05) ) \u2013 The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.65, 0.9], [0.1, 0.5], 0.95) ) \u2013 The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr ( str , default: '' ) \u2013 A string for the opening hour for the loop in military format. The default is ''. close_hr ( str , default: '' ) \u2013 A string for the closing hour for the loop in military format. The default is ''. commodity_name ( str ) \u2013 The name of the asset in our test. The default is ''. Timezone ( str , default: '' ) \u2013 The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse ( bool , default: False ) \u2013 Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol ( str , default: None ) \u2013 The name of the loop to be printed. The default is None. Returns: dataframe \u2013 The generated signals Source code in app/run_gen_monthly_MR_dir.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def loop_signal ( strategy : type [ Strategy ], book : Bookkeep , signal_daily_data : pd . DataFrame , signal_monthly_data : pd . DataFrame , history_data : pd . DataFrame , daily_cumavg_data : pd . DataFrame , start_date : datetime . datetime , end_date : datetime . datetime , buy_range : tuple = ([ 0.10 , 0.35 ],[ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ],[ 0.10 , 0.50 ], 0.95 ), open_hr : str = '' , close_hr : str = '' , quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name : str = '' , Timezone : str = \"\" , contract_symbol_condse : bool = False , loop_symbol : bool = None ) -> pd . DataFrame : \"\"\" The main loop used to generate Buy/Sell signals. Parameters ---------- strategy : strategy object The function of signal generation from the strategy module. book : bookkeep object The bookkeeping object from the bookkeep module. signal_data : dataframe The dataframe of the signal data, e.g.the APCs. history_data : dataframe The dataframe of the history daily pricing data. open_price_data : dataframe The dataframe of the history opening pricing data. start_date : datetime The starting datetime. end_date : datetime The ending datetime. buy_range : tuple, optional The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr : str, optional A string for the opening hour for the loop in military format. The default is ''. close_hr : str, optional A string for the closing hour for the loop in military format. The default is ''. commodity_name : str, optional The name of the asset in our test. The default is ''. Timezone : str, optional The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse : bool, optional Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol : str, optional The name of the loop to be printed. The default is None. Returns ------- dataframe The generated signals \"\"\" #make bucket bucket = book . make_bucket ( keyword = strategy () . strategy_name ) # 'argus_exact_mode')# print ( 'Start looping signal: {} ...' . format ( loop_symbol )) # Find the index of the start_date and end_date here. start_index = history_data . index [ history_data [ 'Date' ] == start_date ] . item () end_index = history_data . index [ history_data [ 'Date' ] == end_date ] . item () # loop through every forecast date and contract symbol month_curve_index = 0 for i in np . arange ( start_index , end_index ): this_date = history_data [ \"Date\" ][ i ] this_symbol = history_data [ \"symbol\" ][ i ] ################################################################ ####PAY ATTENTION TO HOW TO SELECT FOR THE RIGHT MONTHLY APC.. WIP ## USE TWO POINTERS #APCs_this_week = signal_monthly_data[(signal_monthly_data['PERIOD'] <= this_date)] if this_date >= signal_monthly_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index ] \\ and this_date < signal_monthly_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index + 1 ]: APCs_this_week = signal_monthly_data . iloc [ month_curve_index ] elif this_date >= signal_daily_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index + 1 ]: month_curve_index = month_curve_index + 1 APCs_this_week = signal_monthly_data . iloc [ month_curve_index ] print ( \"this_date\" , this_date ) print ( 'Publication date' , signal_monthly_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index ]) print ( 'period' , signal_monthly_data [ 'PERIOD' ] . iloc [ month_curve_index ]) #if this_date > signal_daily_data['PERIOD'].iloc[month_curve_index]: # month_curve_index = month_curve_index +1 # APCs_this_week = signal_monthly_data.iloc[month_curve_index] #print(\"APCs_this_week\", APCs_this_week) ################################################################ # cross reference the APC list to get the APC of this date and symbol APCs_this_date = signal_daily_data [( signal_daily_data [ 'PERIOD' ] == this_date )] # & (APCs_dat['symbol']== this_symbol)] #<-- here add a condition matching the symbols if len ( APCs_this_date ) == 0 : print ( \"APC data of {} from the date {} is missing\" . \\ format ( this_symbol , this_date . date ())) else : #print(this_date, this_symbol, APCs_this_date['Forecast Period'].iloc[0]) forecast_date = APCs_this_date [ 'PERIOD' ] . to_list ()[ 0 ] # This is the APC number only daily_APC = APCs_this_date . to_numpy ()[ 0 ][ - 1 - APC_LENGTH : - 1 ] weekly_APC = APCs_this_week . to_numpy ()[ - 1 - APC_LENGTH : - 1 ] #print(\"daily_APC\", daily_APC) #monthly_APC = APCs_this_week.to_numpy()[-1-APC_LENGTH:-1] # create input for bookkepping price_code = APCs_this_date [ 'symbol' ] . to_list ()[ 0 ] # find the quantile of the opening price #price_330 = open_price_data[open_price_data['Date']==this_date]\\ # ['Open Price'].item() daily_cumavg = daily_cumavg_data [ daily_cumavg_data [ 'Date' ] == this_date ] \\ [ 'cumavg_price' ] . item () prev_cum_n = daily_cumavg_data [ daily_cumavg_data [ 'Date' ] == this_date ] \\ [ 'prev_cum_n' ] . item () # 'cumavg_price', #'prev_cum_n']) # The conidtions to decide whether we trim the full_contract_symbol # CLA2024J or CL24J if contract_symbol_condse == True : temp = history_data [ 'Contract Code' ][ i ] full_contract_symbol = str ( temp )[ 0 : 2 ] + str ( temp )[ 5 : 7 ] + str ( temp )[ - 1 ] elif contract_symbol_condse == False : full_contract_symbol = history_data [ 'Contract Code' ][ i ] # Get the extracted 5 days Lag data. This is the main input to be # put into the Stragey function apc_curve_lag , history_data_lag = read . extract_lag_data ( \\ signal_daily_data , history_data , forecast_date , lag_size = 5 ) # Apply the strategy, The Strategy is variable strategy_output = strategy ( weekly_APC , daily_APC ) . \\ apply_strategy ( history_data_lag , apc_curve_lag , daily_cumavg , prev_cum_n , buy_range = buy_range , sell_range = sell_range , quantile = quantile ) print ( '====================================' ) print ( forecast_date , full_contract_symbol , 'MR signal generated!' , strategy_output [ 'direction' ], i ) # make a list of data to be written into bookkeep static_info = [ asset_name , full_contract_symbol , \\ Timezone , open_hr , close_hr ] # put all the data in a singular list data = [ forecast_date , price_code ] + \\ [ strategy_output [ 'direction' ]] + \\ static_info + strategy_output [ 'data' ] #print(\"data\", data, len(data)) # Storing the data bucket = book . store_to_bucket_single ( data ) dict_contracts_quant_signals = pd . DataFrame ( bucket ) #sort by date (the first column) dict_contracts_quant_signals = dict_contracts_quant_signals . sort_values ( by = dict_contracts_quant_signals . columns . values [ 0 ]) return dict_contracts_quant_signals run_gen_MR_signals_preloaded_monthly ( strategy , filename_list , signal_daily_pkl , signal_monthly_pkl , history_daily_pkl , daily_cumavg_pkl , start_date , end_date , open_hr_dict , close_hr_dict , timezone_dict , buy_range = ([ 0.1 , 0.35 ], [ 0.5 , 0.9 ], 0.05 ), sell_range = ([ 0.65 , 0.9 ], [ 0.1 , 0.5 ], 0.95 ), quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not = True ) A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters: Strategy ( strategy object ) \u2013 The strategy function in use in generating the signal. filename_list ( list ) \u2013 The saved filename list. signal_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict ) \u2013 A dictionary for the input opening hour strings. close_hr_dict ( dict ) \u2013 A dictionary for the input closing hour strings. timezone_dict ( dict ) \u2013 A dictionary for the Time Zone name strings. buy_range ( tuple , default: ([0.1, 0.35], [0.5, 0.9], 0.05) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.65, 0.9], [0.1, 0.5], 0.95) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not ( bool , default: True ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: dataframe \u2013 signal data. Source code in app/run_gen_monthly_MR_dir.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 @util . time_it def run_gen_MR_signals_preloaded_monthly ( strategy : type [ Strategy ], filename_list : list [ str ], signal_daily_pkl : dict , signal_monthly_pkl : dict , history_daily_pkl : dict , daily_cumavg_pkl : dict , start_date : str , end_date : str , open_hr_dict : dict , close_hr_dict : dict , timezone_dict : dict , buy_range : tuple = ([ 0.10 , 0.35 ], [ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ], [ 0.10 , 0.50 ], 0.95 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not : bool = True ) -> pd . DataFrame : \"\"\" A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters ---------- Strategy : strategy object The strategy function in use in generating the signal. filename_list : list The saved filename list. signal_pkl : dict A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl : dict A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl : dict A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. close_hr_dict : dict A dictionary for the input closing hour strings. timezone_dict : dict A dictionary for the Time Zone name strings. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- dataframe signal data. \"\"\" # run meanreversion signal generation on the basis of individual programme # Loop the whole list in one go with all the contracts or Loop it one contract at a time? master_dict , symbol_list = dict (), list ( signal_monthly_pkl . keys ()) print ( symbol_list , filename_list ) for symbol in symbol_list : filename = filename_list [ symbol ] print ( 'filename' , filename ) # The reading part takes the longest time: 13 seconds. The loop itself takes # input 1, APC. Load the master table in memory and test multple strategies @util . save_csv ( \" {} \" . format ( filename ), save_or_not = save_or_not ) def run_gen_MR_indi (): book = Bookkeep ( bucket_type = 'None' , custom_keywords_list = MONTHLY_BOOK_COLS ) print ( \"symbol\" , symbol ) #signal file input signal_daily_file = signal_daily_pkl [ symbol ] signal_monthly_file = signal_monthly_pkl [ symbol ] # Prepare monthly APC file ** Crucial step in making the whole sctip works signal_monthly_file = signal_monthly_file [ signal_monthly_file [ 'CONTINUOUS_FORWARD' ] == 1 ] # input 2, Portara history file. history_daily_file = history_daily_pkl [ symbol ] #history_minute_file = history_minute_pkl[symbol] # Find the opening price at 03:30 UK time. If not found, # loop through the next 30 minutes to find the opening price daily_cumavg_file = daily_cumavg_pkl [ symbol ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] Timezone = timezone_dict [ symbol ] # The strategy will be ran in loop_signal decorator dict_contracts_quant_signals = loop_signal ( strategy , book , signal_daily_file , signal_monthly_file , history_daily_file , daily_cumavg_file , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , quantile = quantile , asset_name = symbol , Timezone = Timezone , loop_symbol = symbol ) return dict_contracts_quant_signals master_dict [ symbol ] = run_gen_MR_indi () return master_dict","title":"Run Generate Monthly MR signals"},{"location":"app/run_gen_monthly_MR_dir/#run-generate-monthly-mr-signals","text":"Created on Mon Sep 16 12:42:50 2024 @author: dexter","title":"Run Generate Monthly MR signals"},{"location":"app/run_gen_monthly_MR_dir/#app.run_gen_monthly_MR_dir.loop_signal","text":"The main loop used to generate Buy/Sell signals. Parameters: strategy ( strategy object ) \u2013 The function of signal generation from the strategy module. book ( bookkeep object ) \u2013 The bookkeeping object from the bookkeep module. signal_data ( dataframe ) \u2013 The dataframe of the signal data, e.g.the APCs. history_data ( dataframe ) \u2013 The dataframe of the history daily pricing data. open_price_data ( dataframe ) \u2013 The dataframe of the history opening pricing data. start_date ( datetime ) \u2013 The starting datetime. end_date ( datetime ) \u2013 The ending datetime. buy_range ( tuple , default: ([0.1, 0.35], [0.5, 0.9], 0.05) ) \u2013 The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.65, 0.9], [0.1, 0.5], 0.95) ) \u2013 The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr ( str , default: '' ) \u2013 A string for the opening hour for the loop in military format. The default is ''. close_hr ( str , default: '' ) \u2013 A string for the closing hour for the loop in military format. The default is ''. commodity_name ( str ) \u2013 The name of the asset in our test. The default is ''. Timezone ( str , default: '' ) \u2013 The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse ( bool , default: False ) \u2013 Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol ( str , default: None ) \u2013 The name of the loop to be printed. The default is None. Returns: dataframe \u2013 The generated signals Source code in app/run_gen_monthly_MR_dir.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def loop_signal ( strategy : type [ Strategy ], book : Bookkeep , signal_daily_data : pd . DataFrame , signal_monthly_data : pd . DataFrame , history_data : pd . DataFrame , daily_cumavg_data : pd . DataFrame , start_date : datetime . datetime , end_date : datetime . datetime , buy_range : tuple = ([ 0.10 , 0.35 ],[ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ],[ 0.10 , 0.50 ], 0.95 ), open_hr : str = '' , close_hr : str = '' , quantile = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], asset_name : str = '' , Timezone : str = \"\" , contract_symbol_condse : bool = False , loop_symbol : bool = None ) -> pd . DataFrame : \"\"\" The main loop used to generate Buy/Sell signals. Parameters ---------- strategy : strategy object The function of signal generation from the strategy module. book : bookkeep object The bookkeeping object from the bookkeep module. signal_data : dataframe The dataframe of the signal data, e.g.the APCs. history_data : dataframe The dataframe of the history daily pricing data. open_price_data : dataframe The dataframe of the history opening pricing data. start_date : datetime The starting datetime. end_date : datetime The ending datetime. buy_range : tuple, optional The range for buy action. The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The range for sell action. The default is ([0.6,0.75],[0.25,0.4],0.95). open_hr : str, optional A string for the opening hour for the loop in military format. The default is ''. close_hr : str, optional A string for the closing hour for the loop in military format. The default is ''. commodity_name : str, optional The name of the asset in our test. The default is ''. Timezone : str, optional The name of the Timezone for a particular asset. The default is \"\". contract_symbol_condse : bool, optional Whether we condense the contract symbol. If False, it is going to If True The default is False. loop_symbol : str, optional The name of the loop to be printed. The default is None. Returns ------- dataframe The generated signals \"\"\" #make bucket bucket = book . make_bucket ( keyword = strategy () . strategy_name ) # 'argus_exact_mode')# print ( 'Start looping signal: {} ...' . format ( loop_symbol )) # Find the index of the start_date and end_date here. start_index = history_data . index [ history_data [ 'Date' ] == start_date ] . item () end_index = history_data . index [ history_data [ 'Date' ] == end_date ] . item () # loop through every forecast date and contract symbol month_curve_index = 0 for i in np . arange ( start_index , end_index ): this_date = history_data [ \"Date\" ][ i ] this_symbol = history_data [ \"symbol\" ][ i ] ################################################################ ####PAY ATTENTION TO HOW TO SELECT FOR THE RIGHT MONTHLY APC.. WIP ## USE TWO POINTERS #APCs_this_week = signal_monthly_data[(signal_monthly_data['PERIOD'] <= this_date)] if this_date >= signal_monthly_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index ] \\ and this_date < signal_monthly_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index + 1 ]: APCs_this_week = signal_monthly_data . iloc [ month_curve_index ] elif this_date >= signal_daily_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index + 1 ]: month_curve_index = month_curve_index + 1 APCs_this_week = signal_monthly_data . iloc [ month_curve_index ] print ( \"this_date\" , this_date ) print ( 'Publication date' , signal_monthly_data [ 'PUBLICATION_DATE' ] . iloc [ month_curve_index ]) print ( 'period' , signal_monthly_data [ 'PERIOD' ] . iloc [ month_curve_index ]) #if this_date > signal_daily_data['PERIOD'].iloc[month_curve_index]: # month_curve_index = month_curve_index +1 # APCs_this_week = signal_monthly_data.iloc[month_curve_index] #print(\"APCs_this_week\", APCs_this_week) ################################################################ # cross reference the APC list to get the APC of this date and symbol APCs_this_date = signal_daily_data [( signal_daily_data [ 'PERIOD' ] == this_date )] # & (APCs_dat['symbol']== this_symbol)] #<-- here add a condition matching the symbols if len ( APCs_this_date ) == 0 : print ( \"APC data of {} from the date {} is missing\" . \\ format ( this_symbol , this_date . date ())) else : #print(this_date, this_symbol, APCs_this_date['Forecast Period'].iloc[0]) forecast_date = APCs_this_date [ 'PERIOD' ] . to_list ()[ 0 ] # This is the APC number only daily_APC = APCs_this_date . to_numpy ()[ 0 ][ - 1 - APC_LENGTH : - 1 ] weekly_APC = APCs_this_week . to_numpy ()[ - 1 - APC_LENGTH : - 1 ] #print(\"daily_APC\", daily_APC) #monthly_APC = APCs_this_week.to_numpy()[-1-APC_LENGTH:-1] # create input for bookkepping price_code = APCs_this_date [ 'symbol' ] . to_list ()[ 0 ] # find the quantile of the opening price #price_330 = open_price_data[open_price_data['Date']==this_date]\\ # ['Open Price'].item() daily_cumavg = daily_cumavg_data [ daily_cumavg_data [ 'Date' ] == this_date ] \\ [ 'cumavg_price' ] . item () prev_cum_n = daily_cumavg_data [ daily_cumavg_data [ 'Date' ] == this_date ] \\ [ 'prev_cum_n' ] . item () # 'cumavg_price', #'prev_cum_n']) # The conidtions to decide whether we trim the full_contract_symbol # CLA2024J or CL24J if contract_symbol_condse == True : temp = history_data [ 'Contract Code' ][ i ] full_contract_symbol = str ( temp )[ 0 : 2 ] + str ( temp )[ 5 : 7 ] + str ( temp )[ - 1 ] elif contract_symbol_condse == False : full_contract_symbol = history_data [ 'Contract Code' ][ i ] # Get the extracted 5 days Lag data. This is the main input to be # put into the Stragey function apc_curve_lag , history_data_lag = read . extract_lag_data ( \\ signal_daily_data , history_data , forecast_date , lag_size = 5 ) # Apply the strategy, The Strategy is variable strategy_output = strategy ( weekly_APC , daily_APC ) . \\ apply_strategy ( history_data_lag , apc_curve_lag , daily_cumavg , prev_cum_n , buy_range = buy_range , sell_range = sell_range , quantile = quantile ) print ( '====================================' ) print ( forecast_date , full_contract_symbol , 'MR signal generated!' , strategy_output [ 'direction' ], i ) # make a list of data to be written into bookkeep static_info = [ asset_name , full_contract_symbol , \\ Timezone , open_hr , close_hr ] # put all the data in a singular list data = [ forecast_date , price_code ] + \\ [ strategy_output [ 'direction' ]] + \\ static_info + strategy_output [ 'data' ] #print(\"data\", data, len(data)) # Storing the data bucket = book . store_to_bucket_single ( data ) dict_contracts_quant_signals = pd . DataFrame ( bucket ) #sort by date (the first column) dict_contracts_quant_signals = dict_contracts_quant_signals . sort_values ( by = dict_contracts_quant_signals . columns . values [ 0 ]) return dict_contracts_quant_signals","title":"loop_signal"},{"location":"app/run_gen_monthly_MR_dir/#app.run_gen_monthly_MR_dir.run_gen_MR_signals_preloaded_monthly","text":"A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters: Strategy ( strategy object ) \u2013 The strategy function in use in generating the signal. filename_list ( list ) \u2013 The saved filename list. signal_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl ( dict ) \u2013 A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date ( str ) \u2013 The starting date. end_date ( str ) \u2013 The ending date. open_hr_dict ( dict ) \u2013 A dictionary for the input opening hour strings. close_hr_dict ( dict ) \u2013 A dictionary for the input closing hour strings. timezone_dict ( dict ) \u2013 A dictionary for the Time Zone name strings. buy_range ( tuple , default: ([0.1, 0.35], [0.5, 0.9], 0.05) ) \u2013 The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range ( tuple , default: ([0.65, 0.9], [0.1, 0.5], 0.95) ) \u2013 The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not ( bool , default: True ) \u2013 A boolean value to indicate whether to save the result in a file or not. The default is False. Returns: dataframe \u2013 signal data. Source code in app/run_gen_monthly_MR_dir.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 @util . time_it def run_gen_MR_signals_preloaded_monthly ( strategy : type [ Strategy ], filename_list : list [ str ], signal_daily_pkl : dict , signal_monthly_pkl : dict , history_daily_pkl : dict , daily_cumavg_pkl : dict , start_date : str , end_date : str , open_hr_dict : dict , close_hr_dict : dict , timezone_dict : dict , buy_range : tuple = ([ 0.10 , 0.35 ], [ 0.50 , 0.90 ], 0.05 ), sell_range : tuple = ([ 0.65 , 0.90 ], [ 0.10 , 0.50 ], 0.95 ), quantile : list [ float ] = [ 0.05 , 0.1 , 0.25 , 0.4 , 0.5 , 0.6 , 0.75 , 0.9 , 0.95 ], save_or_not : bool = True ) -> pd . DataFrame : \"\"\" A method that run Mean Reversion signal generation form a preloaded dictionary. The dictionary contains a key-value pairs with the asset name as keys and a dataframe as value. This method depends upon the function run_gen_MR_signals to iterate over the input lists and calculate the signal for each assets independently. Parameters ---------- Strategy : strategy object The strategy function in use in generating the signal. filename_list : list The saved filename list. signal_pkl : dict A dictionary read from a pkl file that contains the signal data in a dataframe as values and keywords as key. history_daily_pkl : dict A dictionary read from a pkl file that contains the daily historical data in a dataframe as values and keywords as key. openprice_pkl : dict A dictionary read from a pkl file that contains the daily openning price data in a dataframe as values and keywords as key.. start_date : str The starting date. end_date : str The ending date. open_hr_dict : dict A dictionary for the input opening hour strings. close_hr_dict : dict A dictionary for the input closing hour strings. timezone_dict : dict A dictionary for the Time Zone name strings. buy_range : tuple, optional The buy range in the format of (entry, exit, stop loss). The default is ([0.25,0.4],[0.6,0.75],0.05). sell_range : tuple, optional The sell range in the format of (entry, exit, stop loss). The default is ([0.6,0.75],[0.25,0.4],0.95). save_or_not : bool, optional A boolean value to indicate whether to save the result in a file or not. The default is False. Returns ------- dataframe signal data. \"\"\" # run meanreversion signal generation on the basis of individual programme # Loop the whole list in one go with all the contracts or Loop it one contract at a time? master_dict , symbol_list = dict (), list ( signal_monthly_pkl . keys ()) print ( symbol_list , filename_list ) for symbol in symbol_list : filename = filename_list [ symbol ] print ( 'filename' , filename ) # The reading part takes the longest time: 13 seconds. The loop itself takes # input 1, APC. Load the master table in memory and test multple strategies @util . save_csv ( \" {} \" . format ( filename ), save_or_not = save_or_not ) def run_gen_MR_indi (): book = Bookkeep ( bucket_type = 'None' , custom_keywords_list = MONTHLY_BOOK_COLS ) print ( \"symbol\" , symbol ) #signal file input signal_daily_file = signal_daily_pkl [ symbol ] signal_monthly_file = signal_monthly_pkl [ symbol ] # Prepare monthly APC file ** Crucial step in making the whole sctip works signal_monthly_file = signal_monthly_file [ signal_monthly_file [ 'CONTINUOUS_FORWARD' ] == 1 ] # input 2, Portara history file. history_daily_file = history_daily_pkl [ symbol ] #history_minute_file = history_minute_pkl[symbol] # Find the opening price at 03:30 UK time. If not found, # loop through the next 30 minutes to find the opening price daily_cumavg_file = daily_cumavg_pkl [ symbol ] open_hr = open_hr_dict [ symbol ] close_hr = close_hr_dict [ symbol ] Timezone = timezone_dict [ symbol ] # The strategy will be ran in loop_signal decorator dict_contracts_quant_signals = loop_signal ( strategy , book , signal_daily_file , signal_monthly_file , history_daily_file , daily_cumavg_file , start_date , end_date , buy_range = buy_range , sell_range = sell_range , open_hr = open_hr , close_hr = close_hr , quantile = quantile , asset_name = symbol , Timezone = Timezone , loop_symbol = symbol ) return dict_contracts_quant_signals master_dict [ symbol ] = run_gen_MR_indi () return master_dict","title":"run_gen_MR_signals_preloaded_monthly"},{"location":"app/run_plot_heatmap/","text":"Run Plot Backtest Heatmap Created on Tue Sep 24 14:37:07 2024 @author: dexter","title":"Run Plot Backtest Heatmap"},{"location":"app/run_plot_heatmap/#run-plot-backtest-heatmap","text":"Created on Tue Sep 24 14:37:07 2024 @author: dexter","title":"Run Plot Backtest Heatmap"},{"location":"app/run_preprocess/","text":"Run Preprocess Created on Sun Jun 23 23:08:50 2024 @author: dexter The purpose of this script is to convert data into a suitable format for fast processing. While this script takes a longer time to complete, the rest of the back-test workflow will be less time consuming. run_preprocess () The main method for preprocessing. The aim of preprocessing is to create aggegrate pickle files so that the runtime of signal generation and back-test can be reduced. Source code in app/run_preprocess.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def run_preprocess () -> None : \"\"\" The main method for preprocessing. The aim of preprocessing is to create aggegrate pickle files so that the runtime of signal generation and back-test can be reduced. \"\"\" print ( \"============Running Preprocessing==========\" ) # load all raw data into pkl format #create_aggegrate_pkl(APC_FILE_LOC, read.read_reformat_APC_data, # save_filename = DAILY_APC_PKL) #create_aggegrate_pkl(HISTORY_DAILY_FILE_LOC, read.read_reformat_Portara_daily_data, # save_filename = DAILY_DATA_PKL) #create_aggegrate_pkl(HISTORY_MINTUE_FILE_LOC, read.read_reformat_Portara_minute_data, # save_filename = DAILY_MINUTE_DATA_PKL) # calculate and load the open price data into a pkl file #create_open_price_list(HISTORY_DAILY_FILE_LOC, HISTORY_MINTUE_FILE_LOC) #create_aggegrate_pkl(OPEN_PRICE_FILE_LOC, read.read_reformat_openprice_data, # save_filename = DAILY_OPENPRICE_PKL) # make monthly APC pkl #create_aggegrate_pkl(APC_FILE_MONTHLY_LOC, read.read_reformat_APC_data, # save_filename = MONTHLY_APC_PKL, # symbol_list = SYMBOL_LIST_SHORT) #create_aggegrate_pkl(APC_FILE_WEEKLY_30AVG_LOC, read.read_reformat_APC_data, # save_filename = WEEKLY_30AVG_APC_PKL, # symbol_list = SYMBOL_LIST_SHORT) #create_cumavg_list(HISTORY_DAILY_FILE_LOC) #create_aggegrate_pkl(HISTORY_DAILY_CUMAVG_IN_MONTH, read.read_reformat_generic, # save_filename = DAILY_CUMAVG_MONTH_PKL) #create_minute_cumavg_list(HISTORY_MINTUE_FILE_LOC, HISTORY_DAILY_CUMAVG_IN_MONTH, # ) create_aggegrate_pkl ( HISTORY_MINUTE_CUMAVG_IN_MONTH , read . read_reformat_dateNtime , save_filename = MINUTE_CUMAVG_MONTH_PKL )","title":"Run Preprocess"},{"location":"app/run_preprocess/#run-preprocess","text":"Created on Sun Jun 23 23:08:50 2024 @author: dexter The purpose of this script is to convert data into a suitable format for fast processing. While this script takes a longer time to complete, the rest of the back-test workflow will be less time consuming.","title":"Run Preprocess"},{"location":"app/run_preprocess/#app.run_preprocess.run_preprocess","text":"The main method for preprocessing. The aim of preprocessing is to create aggegrate pickle files so that the runtime of signal generation and back-test can be reduced. Source code in app/run_preprocess.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def run_preprocess () -> None : \"\"\" The main method for preprocessing. The aim of preprocessing is to create aggegrate pickle files so that the runtime of signal generation and back-test can be reduced. \"\"\" print ( \"============Running Preprocessing==========\" ) # load all raw data into pkl format #create_aggegrate_pkl(APC_FILE_LOC, read.read_reformat_APC_data, # save_filename = DAILY_APC_PKL) #create_aggegrate_pkl(HISTORY_DAILY_FILE_LOC, read.read_reformat_Portara_daily_data, # save_filename = DAILY_DATA_PKL) #create_aggegrate_pkl(HISTORY_MINTUE_FILE_LOC, read.read_reformat_Portara_minute_data, # save_filename = DAILY_MINUTE_DATA_PKL) # calculate and load the open price data into a pkl file #create_open_price_list(HISTORY_DAILY_FILE_LOC, HISTORY_MINTUE_FILE_LOC) #create_aggegrate_pkl(OPEN_PRICE_FILE_LOC, read.read_reformat_openprice_data, # save_filename = DAILY_OPENPRICE_PKL) # make monthly APC pkl #create_aggegrate_pkl(APC_FILE_MONTHLY_LOC, read.read_reformat_APC_data, # save_filename = MONTHLY_APC_PKL, # symbol_list = SYMBOL_LIST_SHORT) #create_aggegrate_pkl(APC_FILE_WEEKLY_30AVG_LOC, read.read_reformat_APC_data, # save_filename = WEEKLY_30AVG_APC_PKL, # symbol_list = SYMBOL_LIST_SHORT) #create_cumavg_list(HISTORY_DAILY_FILE_LOC) #create_aggegrate_pkl(HISTORY_DAILY_CUMAVG_IN_MONTH, read.read_reformat_generic, # save_filename = DAILY_CUMAVG_MONTH_PKL) #create_minute_cumavg_list(HISTORY_MINTUE_FILE_LOC, HISTORY_DAILY_CUMAVG_IN_MONTH, # ) create_aggegrate_pkl ( HISTORY_MINUTE_CUMAVG_IN_MONTH , read . read_reformat_dateNtime , save_filename = MINUTE_CUMAVG_MONTH_PKL )","title":"run_preprocess"},{"location":"app/run_update_db/","text":"Run Update DB Created on Wed Apr 24 23:27:00 2024 @author: dexter This script updates the daily APC data. It pulls data from external servers to the local directory. download_latest_APC ( auth_pack , asset_pack , start_date = '2021-01-01' ) A method to download the latest APC from in its entirety. This method is considered the 'slow' method due to the time in downloading all the record directly from Argus. Parameters: auth_pack ( dict ) \u2013 A authethication package containing the username and the password in access of Argus Data Studio. asset_pack ( dict ) \u2013 An asset package containing the categories, keywords, and symbol of the asset itself. start_date ( str , default: '2021-01-01' ) \u2013 The start date. The default is \"2021-01-01\". Returns: signal_data ( DataFrame ) \u2013 The APC data in a data frame. Source code in app/run_update_db.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def download_latest_APC ( auth_pack : dict , asset_pack : dict , start_date : str = \"2021-01-01\" ) -> pd . DataFrame : \"\"\" A method to download the latest APC from in its entirety. This method is considered the 'slow' method due to the time in downloading all the record directly from Argus. Parameters ---------- auth_pack : dict A authethication package containing the username and the password in access of Argus Data Studio. asset_pack : dict An asset package containing the categories, keywords, and symbol of the asset itself. start_date : str, optional The start date. The default is \"2021-01-01\". Returns ------- signal_data : DataFrame The APC data in a data frame. \"\"\" # input is a dictionary or json file username = auth_pack [ 'username' ] password = auth_pack [ 'password' ] categories = asset_pack [ 'categories' ] keywords = asset_pack [ 'keywords' ] symbol = asset_pack [ 'symbol' ] end_date = datetime . date . today () . strftime ( \"%Y-%m- %d \" ) # download the relevant APC data from the server signal_data = read . get_apc_from_server ( username , password , start_date , end_date , categories , keywords = keywords , symbol = symbol ) return signal_data download_latest_APC_fast ( auth_pack , asset_pack , old_filename , time_proxy = 'PERIOD' ) A method to download the latest APC based on the existing APC file in the data directory. This method is considered the 'fast' method because it only downloads and update the latest APC that is not in the old file. Parameters: auth_pack ( dict ) \u2013 A authethication package containing the username and the password in access of Argus Data Studio. asset_pack ( dict ) \u2013 An asset package containing the categories, keywords, and symbol of the asset itself. old_filename ( str ) \u2013 The name of the old APC file. Returns: signal_data ( TYPE ) \u2013 The APC data in a data frame. Source code in app/run_update_db.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def download_latest_APC_fast ( auth_pack : dict , asset_pack : dict , old_filename : str , time_proxy = \"PERIOD\" ) -> pd . DataFrame : #tested \"\"\" A method to download the latest APC based on the existing APC file in the data directory. This method is considered the 'fast' method because it only downloads and update the latest APC that is not in the old file. Parameters ---------- auth_pack : dict A authethication package containing the username and the password in access of Argus Data Studio. asset_pack : dict An asset package containing the categories, keywords, and symbol of the asset itself. old_filename : str The name of the old APC file. Returns ------- signal_data : TYPE The APC data in a data frame. \"\"\" # Check the last entry in the old file and only download the data # Read the old files old_data = pd . read_csv ( old_filename ) #Find the date of the latest entry latest_entry = str ( old_data [ time_proxy ] . iloc [ - 1 ]) # download the latest APC from the latest_entry till today temp = download_latest_APC ( auth_pack , asset_pack , start_date = latest_entry ) # for some reason I have to turn the Forecast column elements to str first # to align them with the old data temp [ time_proxy ] = [ temp [ time_proxy ] . iloc [ i ] . \\ strftime ( \"%Y-%m- %d \" ) for i , _ in enumerate ( temp [ time_proxy ])] # concandenate the old filedownload_latest_APC_list signal_data = pd . concat ([ old_data , temp ], ignore_index = True ) signal_data . sort_values ( by = time_proxy ) return signal_data download_latest_APC_list ( auth_pack , save_filename_list , categories_list , keywords_list , symbol_list , fast_dl = True ) The master method that allows you to download APC in bulk, as well as choosing whether to use the fast or slow download method. Parameters: auth_pack ( dict ) \u2013 A authethication package containing the username and the password in access of Argus Data Studio. save_filename_list ( list ) \u2013 A list of filename for saving. categories_list ( list ) \u2013 A list of category key words. keywords_list ( list ) \u2013 A list of keywords for a search. symbol_list ( list ) \u2013 A list of contract symbols. fast_dl ( bool , default: True ) \u2013 Choose whether you want to enable fast download. The default is True. Returns: str \u2013 \"All APC files downloaded!\". Source code in app/run_update_db.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @util . time_it def download_latest_APC_list ( auth_pack : dict , save_filename_list : list , categories_list : list , keywords_list : list , symbol_list : list , fast_dl : bool = True ) -> str : \"\"\" The master method that allows you to download APC in bulk, as well as choosing whether to use the fast or slow download method. Parameters ---------- auth_pack : dict A authethication package containing the username and the password in access of Argus Data Studio. save_filename_list : list A list of filename for saving. categories_list : list A list of category key words. keywords_list : list A list of keywords for a search. symbol_list : list A list of contract symbols. fast_dl : bool, optional Choose whether you want to enable fast download. The default is True. Returns ------- str \"All APC files downloaded!\". \"\"\" # a function to download the APC of a list of asset # input username and password.json for filename , cat , key , sym in zip ( save_filename_list , categories_list , keywords_list , symbol_list ): @util . save_csv ( \" {} \" . format ( filename )) def download_latest_APC_indi ( cat , key , sym ): asset_pack = { 'categories' : cat , 'keywords' : key , 'symbol' : sym } if fast_dl == True : # Fast download. It loads old files signal_data = download_latest_APC_fast ( auth_pack , asset_pack , filename ) elif fast_dl == False : # Slow download. It downlaod all data from db fresh signal_data = download_latest_APC ( auth_pack , asset_pack ) print ( \"File: {} is generated.\" . format ( filename )) return signal_data download_latest_APC_indi ( cat , key , sym ) return \"All APC files downloaded!\"","title":"Run Update DB"},{"location":"app/run_update_db/#run-update-db","text":"Created on Wed Apr 24 23:27:00 2024 @author: dexter This script updates the daily APC data. It pulls data from external servers to the local directory.","title":"Run Update DB"},{"location":"app/run_update_db/#app.run_update_db.download_latest_APC","text":"A method to download the latest APC from in its entirety. This method is considered the 'slow' method due to the time in downloading all the record directly from Argus. Parameters: auth_pack ( dict ) \u2013 A authethication package containing the username and the password in access of Argus Data Studio. asset_pack ( dict ) \u2013 An asset package containing the categories, keywords, and symbol of the asset itself. start_date ( str , default: '2021-01-01' ) \u2013 The start date. The default is \"2021-01-01\". Returns: signal_data ( DataFrame ) \u2013 The APC data in a data frame. Source code in app/run_update_db.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def download_latest_APC ( auth_pack : dict , asset_pack : dict , start_date : str = \"2021-01-01\" ) -> pd . DataFrame : \"\"\" A method to download the latest APC from in its entirety. This method is considered the 'slow' method due to the time in downloading all the record directly from Argus. Parameters ---------- auth_pack : dict A authethication package containing the username and the password in access of Argus Data Studio. asset_pack : dict An asset package containing the categories, keywords, and symbol of the asset itself. start_date : str, optional The start date. The default is \"2021-01-01\". Returns ------- signal_data : DataFrame The APC data in a data frame. \"\"\" # input is a dictionary or json file username = auth_pack [ 'username' ] password = auth_pack [ 'password' ] categories = asset_pack [ 'categories' ] keywords = asset_pack [ 'keywords' ] symbol = asset_pack [ 'symbol' ] end_date = datetime . date . today () . strftime ( \"%Y-%m- %d \" ) # download the relevant APC data from the server signal_data = read . get_apc_from_server ( username , password , start_date , end_date , categories , keywords = keywords , symbol = symbol ) return signal_data","title":"download_latest_APC"},{"location":"app/run_update_db/#app.run_update_db.download_latest_APC_fast","text":"A method to download the latest APC based on the existing APC file in the data directory. This method is considered the 'fast' method because it only downloads and update the latest APC that is not in the old file. Parameters: auth_pack ( dict ) \u2013 A authethication package containing the username and the password in access of Argus Data Studio. asset_pack ( dict ) \u2013 An asset package containing the categories, keywords, and symbol of the asset itself. old_filename ( str ) \u2013 The name of the old APC file. Returns: signal_data ( TYPE ) \u2013 The APC data in a data frame. Source code in app/run_update_db.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def download_latest_APC_fast ( auth_pack : dict , asset_pack : dict , old_filename : str , time_proxy = \"PERIOD\" ) -> pd . DataFrame : #tested \"\"\" A method to download the latest APC based on the existing APC file in the data directory. This method is considered the 'fast' method because it only downloads and update the latest APC that is not in the old file. Parameters ---------- auth_pack : dict A authethication package containing the username and the password in access of Argus Data Studio. asset_pack : dict An asset package containing the categories, keywords, and symbol of the asset itself. old_filename : str The name of the old APC file. Returns ------- signal_data : TYPE The APC data in a data frame. \"\"\" # Check the last entry in the old file and only download the data # Read the old files old_data = pd . read_csv ( old_filename ) #Find the date of the latest entry latest_entry = str ( old_data [ time_proxy ] . iloc [ - 1 ]) # download the latest APC from the latest_entry till today temp = download_latest_APC ( auth_pack , asset_pack , start_date = latest_entry ) # for some reason I have to turn the Forecast column elements to str first # to align them with the old data temp [ time_proxy ] = [ temp [ time_proxy ] . iloc [ i ] . \\ strftime ( \"%Y-%m- %d \" ) for i , _ in enumerate ( temp [ time_proxy ])] # concandenate the old filedownload_latest_APC_list signal_data = pd . concat ([ old_data , temp ], ignore_index = True ) signal_data . sort_values ( by = time_proxy ) return signal_data","title":"download_latest_APC_fast"},{"location":"app/run_update_db/#app.run_update_db.download_latest_APC_list","text":"The master method that allows you to download APC in bulk, as well as choosing whether to use the fast or slow download method. Parameters: auth_pack ( dict ) \u2013 A authethication package containing the username and the password in access of Argus Data Studio. save_filename_list ( list ) \u2013 A list of filename for saving. categories_list ( list ) \u2013 A list of category key words. keywords_list ( list ) \u2013 A list of keywords for a search. symbol_list ( list ) \u2013 A list of contract symbols. fast_dl ( bool , default: True ) \u2013 Choose whether you want to enable fast download. The default is True. Returns: str \u2013 \"All APC files downloaded!\". Source code in app/run_update_db.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @util . time_it def download_latest_APC_list ( auth_pack : dict , save_filename_list : list , categories_list : list , keywords_list : list , symbol_list : list , fast_dl : bool = True ) -> str : \"\"\" The master method that allows you to download APC in bulk, as well as choosing whether to use the fast or slow download method. Parameters ---------- auth_pack : dict A authethication package containing the username and the password in access of Argus Data Studio. save_filename_list : list A list of filename for saving. categories_list : list A list of category key words. keywords_list : list A list of keywords for a search. symbol_list : list A list of contract symbols. fast_dl : bool, optional Choose whether you want to enable fast download. The default is True. Returns ------- str \"All APC files downloaded!\". \"\"\" # a function to download the APC of a list of asset # input username and password.json for filename , cat , key , sym in zip ( save_filename_list , categories_list , keywords_list , symbol_list ): @util . save_csv ( \" {} \" . format ( filename )) def download_latest_APC_indi ( cat , key , sym ): asset_pack = { 'categories' : cat , 'keywords' : key , 'symbol' : sym } if fast_dl == True : # Fast download. It loads old files signal_data = download_latest_APC_fast ( auth_pack , asset_pack , filename ) elif fast_dl == False : # Slow download. It downlaod all data from db fresh signal_data = download_latest_APC ( auth_pack , asset_pack ) print ( \"File: {} is generated.\" . format ( filename )) return signal_data download_latest_APC_indi ( cat , key , sym ) return \"All APC files downloaded!\"","title":"download_latest_APC_list"}]}